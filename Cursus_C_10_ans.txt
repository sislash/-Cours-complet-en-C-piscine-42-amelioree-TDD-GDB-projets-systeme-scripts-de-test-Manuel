# ğŸ“˜ Piscine Personnelle - Cursus complet

## Introduction:

Ce document n'est pas qu'un simple recueil d'exercices. Il reprÃ©sente une approche pÃ©dagogique complÃ¨te pour maÃ®triser la programmation en C, inspirÃ©e du modÃ¨le de la Piscine de l'ecole 42, mais personnalisÃ©e pour un apprentissage approfondit.

Son originalitÃ© repose sur une combinaison de facteurs.

StructurÃ© comme une formation professionnelle, Chaque bloc est conÃ§u pour bÃ¢tir progressivement des compÃ©tences solides, allant des bases aux concepts les plus avancÃ©s.
RÃ©digÃ© avec la bienveillance dâ€™un mentor, Le ton se veut encourageant, clair et orientÃ© vers la rÃ©ussite de l'apprenant. Les explications sont dÃ©taillÃ©es mais accessibles, et le parcours est pensÃ© pour minimiser la frustration.
OrganisÃ© comme un projet rÃ©el, La progression est logique et les compÃ©tences acquises sont directement applicables Ã  des projets concrets, prÃ©parant ainsi l'apprenant aux dÃ©fis du monde professionnel.

## ğŸ“„ Mentions lÃ©gales & crÃ©dits

-   Auteur : **Megnoux Xavier**
-   Provenance : **belgique , liege**
-   Aide Ã  la rÃ©daction : **ChatGPT â€” ModÃ¨le GPT-4**
-   Document librement consultable et partageable Ã  titre personnel.
-   ğŸ“Œ Non affiliÃ© Ã  42. Utilise des mÃ©thodes inspirÃ©es de l'Ã©cole 42 (piscine, TDD, progression, rÃ©striction).
-   Tous les exemples de code sont originaux et gÃ©nÃ©rÃ©s dans un but pÃ©dagogique. Aucun extrait propriÃ©taire ou issu de tiers.

##ğŸ“œ Licence Personnelle dâ€™Utilisation
Nom du document : Cursus_C_10_ans
Auteur : Megnoux Xavier
Contact : [sckavens@gmail.com]
Date de crÃ©ation : [20-02-2024]
DerniÃ¨re mise Ã  jour : [08-07-2025]

##ğŸŸ¢ Utilisation autorisÃ©e
Ce document est librement utilisable Ã  des fins personnelles, pÃ©dagogiques et non commerciales.
Tu peux :

- Le lire, lâ€™Ã©tudier et le recopier pour ton apprentissage personnel.
- Le partager gratuitement avec dâ€™autres personnes dans un cadre privÃ© (amis, proches, groupe dâ€™Ã©tude).
- Lâ€™imprimer pour un usage individuel.

##ğŸ”´ Utilisation professionnelle ou commerciale interdite sans autorisation
Toute utilisation professionnelle, acadÃ©mique ou commerciale du prÃ©sent document est interdite sans l'accord explicite
de l'auteur.
Cela comprend notamment :

- Son usage dans une Ã©cole, une formation payante, une entreprise ou un centre de formation.
- Toute forme d'intÃ©gration Ã  une plateforme Ã©ducative, Ã  un site web Ã  but lucratif ou Ã  un programme dâ€™enseignement
    officiel.
- Toute vente, monÃ©tisation directe ou indirecte, ou reproduction dans des Å“uvres publiÃ©es.

##ğŸ“¬ Pour toute demande de licence professionnelle, partenariat ou usage Ã©largi :
##â¡ï¸ Me contacter directement (voir contact ci-dessus).

##ğŸ› ï¸ Modifications et dÃ©rivÃ©s
Tu peux adapter le contenu pour ton usage personnel uniquement, mais toute modification ou dÃ©rivÃ© destinÃ© Ã  Ãªtre
partagÃ© (mÃªme gratuitement) doit impÃ©rativement Ãªtre soumis Ã  validation prÃ©alable auprÃ¨s de lâ€™auteur.
Usage                                          |AutorisÃ© ?
-----------------------------------------------|-------------------------------------
AmÃ©lioration pour soi : autorisÃ©e              | âœ… Oui
Modifier et diffuser Ã  d'autres                | ğŸ”’ Non, sans autorisation
Traduire ou inclure dans un projet             | ğŸ”’ Non, sans autorisation

##ğŸ’¼ Mentions obligatoires
Lors de toute copie, adaptation, prÃ©sentation ou diffusion autorisÃ©e du document original ou modifiÃ©, les Ã©lÃ©ments
suivants doivent obligatoirement Ãªtre mentionnÃ©s :

- Le nom de lâ€™auteur original : Megnoux Xavier
- Un lien vers le document source (si en ligne)
- Lâ€™indication : "Document original utilisÃ© avec l'autorisation de son auteur"

##âš–ï¸ Clause de respect moral
Le contenu de ce document est fourni dans un but pÃ©dagogique et personnel.
Il ne doit pas Ãªtre dÃ©naturÃ©, dÃ©tournÃ© de son contexte, ni utilisÃ© pour des pratiques contraires Ã  lâ€™Ã©thique ou Ã  la
bienveillance Ã©ducative.

##ğŸ”” **Ã€ propos de ce document :**
Ce cursus n'est **pas un cours thÃ©orique complet du langage C**. Il repose sur l'idÃ©e que l'Ã©lÃ¨ve utilise **un ou plusieurs livres de rÃ©fÃ©rence** pour apprendre les notions fondamentales (syntaxe, structures, pointeurs, mÃ©moire, etc.).

##ğŸ¯ Ce document sert de **guide pratique**, basÃ© sur une approche progressive, rigoureuse, structurÃ©e par TDD.
**Chaque exercice introduit un concept du C par la pratique**, mais il ne le dÃ©taille pas toujours en profondeur.  

##ğŸ“š L'Ã©lÃ¨ve est invitÃ© Ã  se rÃ©fÃ©rer Ã  ses livres pour :
- Les boucles `while`, `for`
- Les conditions `if`, `else`
- La gestion de la mÃ©moire (`malloc`, `free`)
- Les conversions ASCII â int
- La manipulation des pointeurs
- Les structures, fonctions, etc.

##Exemples de livres compatibles :
- *Le langage C* â€“ Brian W. Kernighan & Dennis M. Ritchie
- *Apprendre Ã  programmer en C* â€“ Claude Delannoy
- *C Programming: A Modern Approach* â€“ K. N. King

##ğŸ§  Le but ici est de **mettre en pratique immÃ©diatement** ce que tu apprends dans ces ouvrages, grÃ¢ce Ã  une **progression claire**, une **structure TDD** et des **scripts de test automatisÃ©s**.

## ğŸ¯ Objectif du document

CrÃ©er une formation autonome, progressive, et complÃ¨te pour apprendre la programmation systÃ¨me en langage 'C', en partant de zÃ©ro jusqu'Ã  des compÃ©tences de niveau master.

Ce cours intÃ¨gre :

-   Le langage **C standard** + normes 42
-   Les outils professionnels : **Makefile**, **test.sh**, **Git**, **GDB**, **arborescence claire**
-   Des projets Ã  long terme : **norminette**, **moulinette**, **jeu ASCII**,
    **reverseengineering**, **shell**, **mini-projet graphique**
-   Des exercices **corrigÃ©s**, **guidÃ©s**, et **annotÃ©s** (TDD, debug, rÃ©flexion)
-   Un chemin balisÃ© (blocs + progression + fiches de suivi)
-   Des **bonus en assembleur et reverse engineering** pour approfondir le bas niveau

## ğŸ”§ PrÃ©paration : outils nÃ©cessaires
Tu nâ€™as besoin que dâ€™un **terminal Unix/Linux** et dâ€™un Ã©diteur de texte. Aucun IDE.

### ğŸ§° Outils utilisÃ©s dans ce document
-   **`gcc`** : le compilateur C standard.
-   **`make`** : pour automatiser la compilation.
-   **`git`** : pour le contrÃ´le de version.
-   **`gdb`** : le dÃ©bogueur.
-   **`man`** : pour consulter les pages de manuel.
-   **`norminette`** (si tu suis les normes 42) : pour vÃ©rifier le style du code.

### âš™ï¸ Installation (Debian/Ubuntu)
```bash
sudo apt update
sudo apt install build-essential git manpages-dev
```

### ğŸ“ Structure des fichiers
Chaque exercice suit une structure de rÃ©pertoire prÃ©cise pour faciliter le TDD (Test-Driven Development) et
l'organisation.

```bash
â”œâ”€â”€ex00/
â”‚   â”œâ”€â”€ include/
â”‚   â”‚   â””â”€â”€ ft_putchar.h
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ ft_putchar.c
â”‚   â””â”€â”€ test/
â”‚         â”œâ”€â”€ expected.txt
â”‚         â”œâ”€â”€ main.c
â”‚         â””â”€â”€ test.sh
â”œâ”€â”€ ex01
â”‚   â”œâ”€â”€ include
â”‚   â”‚   â””â”€â”€ ft_print_alphabet.h
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â””â”€â”€ ft_print_alphabet.c
â”‚   â””â”€â”€ test
â”‚         â”œâ”€â”€ expected.txt
â”‚         â”œâ”€â”€ main.c
â”‚         â””â”€â”€ test.sh
â””â”€â”€ Makefile
```

- exXX/ : Un rÃ©pertoire par exercice.
- exXX/include/ : Contient les fichiers d'en-tÃªte (.h) pour les prototypes de fonctions.
- exXX/src/ : Contient les fichiers source (.c) de tes fonctions.
- exXX/test/ : Contient le code de test (main.c), le rÃ©sultat attendu (expected.txt), et le script
  de test (test.sh).
- Makefile (Ã  la racine) : Pour compiler tous les exercices.

## ğŸ§­ Sommaire
1. ğŸš€ Bloc 1 [ğŸŸ¢ Facile]: Les Fondamentaux en C
2. ğŸ“¦ Bloc 2 [ğŸŸ¢ Facile]: Libft++ et Fonctions standard
3. ğŸ”„ Bloc 3 [ğŸŸ¡ IntermÃ©diaire]: Get Next Line, Parsing et Buffers
4. ğŸ§µ Bloc 4 [ğŸŸ¡ IntermÃ©diaire]: Pipex et manipulation de processus
5. ğŸš Bloc 5 [ğŸŸ  AvancÃ©]: Minishell & analyse syntaxique avancÃ©e
6. ğŸ¨ AnnÃ©e 2 [ğŸŸ  AvancÃ©]: Graphisme et rÃ©seau (Cub3D++, MiniRT++)
7. ğŸ’» AnnÃ©e 3 [ğŸ”´ TrÃ¨s avancÃ©]: Moteur, FS, Shell avancÃ©
8. ğŸ§  AnnÃ©es 4-5 [ğŸ”´ TrÃ¨s avancÃ©]: OS, compilateurs, sÃ©curitÃ©
9. ğŸ› ï¸ AnnÃ©es 6-10 [ğŸ”´ğŸ”´ Expert]: OS perso, automation, CI/CD, Norminette++

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Piscine BoostÃ©e - Bloc 1 (Partie 1/5) [ğŸŸ¢ Facile]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

##Introduction :##
Bienvenue dans ta Piscine BoostÃ©e personnelle.
Tu dois :

- RÃ©flÃ©chis par toi-mÃªme.
- Ne pas recopier.
- Commencer doucement Ã  tester ton code (TDD minimal).
- Respecter la norme stricte Ã©tablie.
- Utiliser une structure de projet propre dÃ¨s que possible.
- au-dessus de chaque fichiers .c et .h tu devras placer un header.

/* ***************************************************************************/
/*                                                                           */ 
/* nom_du_fichier.c                                                          */
/*                                                                           */
/* By: prenom.nom@email.com                                                  */
/*                                                                           */
/* Created: AAAA/MM/JJ HH:MM:SS by prenom.nom                                */
/* Updated: AAAA/MM/JJ HH:MM:SS by prenom.nom                                */
/*                                                                           */
/* ***************************************************************************/

[Rappel] important pour l'organisation de ton code
Ã€ respecter dÃ¨s l'exercice 1 :

[Rappel] Structure des fichiers pour ex00
Chaque exercice suit une structure de rÃ©pertoire prÃ©cise pour faciliter le TDD (Test-Driven Development) et l'organisation.

```bash
â”œâ”€â”€ex00/
â”‚   â”œâ”€â”€ include/
â”‚   â”‚   â””â”€â”€ ft_putchar.h
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ ft_putchar.c
â”‚   â””â”€â”€ test/
â”‚         â”œâ”€â”€ expected.txt
â”‚         â”œâ”€â”€ main.c
â”‚         â””â”€â”€ test.sh
â”œâ”€â”€ ex01
â”‚   â”œâ”€â”€ include
â”‚   â”‚   â””â”€â”€ ft_print_alphabet.h
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â””â”€â”€ ft_print_alphabet.c
â”‚   â””â”€â”€ test
â”‚         â”œâ”€â”€ expected.txt
â”‚         â”œâ”€â”€ main.c
â”‚         â””â”€â”€ test.sh
â””â”€â”€ Makefile
```

-------------------------------------------------
##exercice_test_environement - prÃ©paratoire â€” ft_success
-------------------------------------------------

###Objectif :###
Avant dâ€™Ã©crire la moindre fonction, tu vas :
- VÃ©rifier que ton Makefile fonctionne
- Structurer correctement ton dossier
- Compiler un petit projet C simple
- ExÃ©cuter un script de test (test.sh)
- Apprendre la logique du TDD le plus basique possible
- Câ€™est un test de prÃ©paration, comme un check systÃ¨me avant le vrai dÃ©collage.

Ce que tu dois avoir Ã  la fin :
Une arborescence propre.

```css
ex00-preparatoire/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ ft_success.h
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_success.c
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ expected.txt
â”‚   â””â”€â”€ test.sh
â””â”€â”€ Makefile
```

Code source minimal :
include/ft_success.h

```c
#ifndef FT_SUCCESS_H
# define FT_SUCCESS_H

int ft_success(void);

#endif
```

src/ft_success.c

```c
int ft_success(void)
{
    return (0);
}
```

test/main.c

```c
#include "../include/ft_success.h"
#include <stdio.h>

int main(void)
{
    if (ft_success() == 0)
    {
        printf("SUCCESS\n");
        return (0);
    }
    else
    {
        printf("FAIL\n");
        return (1);
    }
}
```

test/expected.txt
```sh
SUCCESS
```

test/test.sh
```bash
#!/bin/bash

# Couleurs
GREEN="\033[0;32m"
RED="\033[0;31m"
NC="\033[0m" # No Color

# Compilation
gcc -Wall -Wextra -Werror -Iinclude src/ft_success.c test/main.c -o success_test

# ExÃ©cution
./success_test > test/output.txt

# Comparaison
if diff test/output.txt test/expected.txt > /dev/null; then
    echo -e "${GREEN} ft_success : Test rÃ©ussi${NC}"
    rm -f test/output.txt success_test
    exit 0
else
    echo -e "${RED} ft_success : Ã‰chec du test${NC}"
    echo "Contenu obtenu :"
    cat test/output.txt
    echo "Attendu :"
    cat test/expected.txt
    rm -f test/output.txt success_test
    exit 1
fi
```

Makefile (version locale pour ex00-preparatoire uniquement)
```makefile
NAME = success_test

CC = gcc
CFLAGS = -Wall -Wextra -Werror

SRC = src/ft_success.c
TEST = test/main.c
INCLUDES = -Iinclude

all: $(NAME)

$(NAME): $(SRC) $(TEST)
	$(CC) $(CFLAGS) $(INCLUDES) $(SRC) $(TEST) -o $(NAME)

test: all
	@chmod +x test/test.sh
	@./test/test.sh

clean:
	rm -f $(NAME) test/output.txt

fclean: clean

re: fclean all

.PHONY: all clean fclean re test
```

###Bulle pÃ©dagogique :###
Avant d'apprendre Ã  Ã©crire une fonction, tu dois apprendre Ã  Ã©crire un projet propre.
Ce test est lÃ  pour te rassurer : tout fonctionne OK. Maintenant, tu peux y aller sereinement !

Petit conseil bonus.
Si tu as un message d'erreur pendant l'exÃ©cution :
- VÃ©rifie tes droits sur test.sh (chmod +x test.sh)
- VÃ©rifie les chemins (../include, ../srcâ€¦)
- Lance `make test` Ã  la racine du dossier

###RÃ©sultat attendu en lanÃ§ant:###

```bash
make test
```

Tu dois voir :

ft_success : Test rÃ©ussi

-------------------------------------------------
## 0.0.0) ex00: ft_putchar
-------------------------------------------------

###Le but :###  
Afficher un seul caractÃ¨re sur la sortie standard.

Câ€™est ton tout premier exercice en langage C.  
Tu vas apprendre Ã  **parler directement Ã  lâ€™ordinateur** en lui envoyant une lettre Ã  afficher.  
Ce sera le dÃ©but de ta communication avec le systÃ¨me.

###prototype :###
include/ft_putchar.h

```c
#ifndef FT_PUTCHAR_H
# define FT_PUTCHAR_H

# include <unistd.h> // NÃ©cessaire pour la dÃ©claration de write() (man 2 write)

void ft_putchar(char c);

#endif // FT_PUTCHAR_H
```

src/ft_putchar.c

```c
#include <unistd.h>

void ft_putchar(char c)
{
    write(1, &c, 1);
}
```

###Explication :###
Tu dois Ã©crire directement sur la sortie standard (l'Ã©cran) en utilisant une fonction systÃ¨me de bas niveau.

La fonction write() est un appel systÃ¨me (low-level) qui te permet dâ€™Ã©crire des donnÃ©es dans un fichier ou vers lâ€™Ã©cran.

```c
write(1, &c, 1);
Ã‰lÃ©ment	Signification
1	descripteur de sortie standard
&c	adresse du caractÃ¨re Ã  Ã©crire
1	nombre dâ€™octets Ã  Ã©crire (1)
```

Petit rappel sur les descripteurs de fichier.
Chaque programme en C (sous Unix/Linux) utilise 3 descripteurs standards dÃ¨s son lancement :

```c
write(fd, &c, 1);
fd (file descriptor)	Utilisation par dÃ©faut
0	EntrÃ©e standard (clavier)
1	Sortie standard (Ã©cran)
2	Sortie dâ€™erreur standard
```

Cela signifie que :
write(1, &c, 1); Ã©crit Ã  lâ€™Ã©cran
write(2, &msg, len); affiche une erreur
read(0, &buf, n); lit depuis le clavier

###Interdictions :###
Interdit	           | Raison
-----------------------|-------------------------------------------------------------
- `printf`             | Fonction plus haut niveau, non autorisÃ©e ici.
- `puts`	           | Idem, elle ajoute un retour Ã  la ligne automatiquement.
- `putchar`            | Tu es en train de la coder toi-mÃªme !

Tu dois uniquement utiliser write.

###Bulle d'ami :###
"Ton premier dialogue avec l'ordinateur : lui Ã©crire un caractÃ¨re directement. Câ€™est brut, direct, efficace."

###Mini-TDD :###
Ã‰cris un test simple pour vÃ©rifier que ton ft_putchar affiche bien un caractÃ¨re.

TDD â€” Qu'est-ce que c'est exactement ?
TDD signifie Test-Driven Development (DÃ©veloppement dirigÃ© par les tests).

Principe :
- Ã‰cris un test qui Ã©choue (car le code nâ€™existe pas encore).
- Ã‰cris juste assez de code pour que le test passe OK.
- AmÃ©liore ton code si nÃ©cessaire (refactorisation), tout en gardant les tests verts.

Avantage	       |Explication
-------------------|----------------------------------------------------------------
Moins de bugs	   | Tu dÃ©tectes immÃ©diatement les erreurs
Code plus clair	   | Tu te concentres sur ce qui est attendu
Confiance	       | Tu sais que ton code fonctionne, mÃªme aprÃ¨s une modif
Discipline	       | Tu avances petit Ã  petit, de faÃ§on propre

###Exemple de test :###
test_putchar.c

```c
#include <unistd.h>

/*DÃ©claration de la fonction Ã  tester*/

void ft_putchar(char c);

int main(void)
{
    // Test simple
    ft_putchar('A');
    write(1, "\n", 1); // Retour Ã  la ligne

    // Test attendu : est-ce que 'A' s'affiche ?
    // (Pas automatique ici : c'est visuel, mais on peut capturer la sortie plus tard)

    return 0;
}
```

###Ã‰tapes TDD :###
1ï¸. Lance le test âœ Il Ã©choue si ft_putchar nâ€™est pas codÃ©e
2ï¸. ImplÃ©mente le code minimal pour que le test rÃ©ussisse
3ï¸. Relance le test âœ Tu dois voir :

```txt
A
```

Bravo ! Test validÃ©.

###RÃ©sumÃ© rapide :###
Cycle du TDD Ã‰tape de ce que tu fais
Ã‰chec du test	Tu sais que tu dois coder
SuccÃ¨s du test	Ton implÃ©mentation est correcte
Refactorisation	Tu peux amÃ©liorer sans casser

###Remarque importante :###
Un "test", au dÃ©but, câ€™est juste Ã©crire un petit main.c qui vÃ©rifie le rÃ©sultat attendu, sans framework compliquÃ©.

Mini-TDD conseillÃ© pour ft_putchar
Test	                | Attendu
------------------------|----------------------------------
ft_putchar('Z');	    | Affiche Z
ft_putchar('0');	    | Affiche 0
ft_putchar('\n');	    | Affiche un retour Ã  la ligne

###Maintenant TDD un peu plus complexe ! :###
TDD (Test-Driven Development) en vrai
Le TDD consiste Ã  Ã©crire les tests avant le code.

1. Fichier de test â€” test/main.c

```c
#include "../include/ft_putchar.h" // Inclut ton fichier d'en-tÃªte

int main(void) {
    ft_putchar('A');
    ft_putchar('\n'); // Ajout d'un retour Ã  la ligne pour une meilleure visualisation
    return 0;
}
```

2. Fichier attendu â€” test/expected.txt

```txt
A
```

3. Script de test â€” test/test.sh

```bash
#!/bin/bash

# Compiler le programme de test
gcc -Wall -Wextra -Werror -Iinclude src/ft_putchar.c test/main.c -o ex00_test

# ExÃ©cuter le programme et rediriger sa sortie vers un fichier temporaire
./../ex00_test > test/output.txt

# Comparer la sortie avec le fichier attendu
diff test/output.txt test/expected.txt > /dev/null

# VÃ©rifier le code de retour de diff
if [ $? -eq 0 ]; then
    echo "ex00: Test rÃ©ussi"
else
    echo "ex00: Erreur - La sortie ne correspond pas Ã  l'attendu"
fi

# Nettoyer les fichiers temporaires
rm -f ex00_test test/output.txt
```

###ExÃ©cution du test :###
Dans ton terminal :

```bash
cd ex00
./test/test.sh
```

###Compilation :###
Tu dois avoir un Makefile Ã  la racine de ton projet pour gÃ©rer la compilation de tous tes exercices.

Makefile â€” racine du projet

```makefile
# Makefile
# Ce Makefile est Ã  placer Ã  la racine de ton projet (au mÃªme niveau que le rÃ©pertoire ex00)

CC = gcc

NAME = piscine

# Liste de tous les rÃ©pertoires d'exercice Ã  compiler et tester
EXERCICES = ex00 ex01

SRC_ex00 = ft_putchar
SRC_ex01 = ft_print_alphabet

CFLAGS = -Wall -Wextra -Werror

# Option de debuggage
DEBUG = -g

# Fonction pour compiler un exercice donnÃ©
define compile_exercise
	@echo "Compiling $1..."
	$(CC) $(CFLAGS) -I$1/include $1/src/$(eval SRC_FILE := $(SRC_$1))$(SRC_FILE).c $1/test/main.c -o $1_test
endef

# Compilation de tous les exercices
all: $(EXERCICES)

# Compilation individuelle de chaque exercice
$(EXERCICES):
	$(call compile_exercise,$@)

# Nettoyage des exÃ©cutables et fichiers temporaires
clean:
	@echo "cleaning up..."
	rm -f $(EXERCICES:%=%_test)
	@find . -name "*.out" -delete
	@rm -f */test/output.txt
	@rm -f *.o

# ExÃ©cution de tous les tests
test: clean all
	@echo "Running all test..."
	@for dir in $(EXERCICES); do \
		if [ -f $$dir/test/test.sh ]; then \
			cd $$dir && ./test/test.sh && cd - > /dev/null; \
		else \
			echo "Skipping test for $$dir: test/test.sh not found."; \
		fi; \
	done

.PHONY: all clean test $(EXERCICES)
```

###Pour compiler ex00 :###
Depuis la racine de ton projet :

```bash
make ex00
```

Ceci crÃ©era un exÃ©cutable ex00_test.

Challenge complÃ©mentaire (si tu veux aller plus loin)
Affiche une ligne complÃ¨te avec plusieurs appels Ã  ft_putchar (ex : "HELLO\n")
CrÃ©e un test avec un caractÃ¨re spÃ©cial ('\t', '\n', '@')
Essaie d'afficher un caractÃ¨re Ã  partir de son code ASCII :

```c
ft_putchar(65); // devrait afficher 'A'
```

###Petit quiz mental :###
Que va afficher ce code ?

```c
ft_putchar('A' + 1);
```

RÃ©ponse : Il affiche B, car 'A' + 1 donne le caractÃ¨re suivant.

VoilÃ , tu viens de rÃ©ussir ton premier programme C testable, structurÃ© et propre.
Câ€™est le premier bloc fondamental de ta progression. Bravo ! 

-------------------------------------------------
## 0.0.1) ex01: ft_print_alphabet
-------------------------------------------------

###Le but :###
Afficher toutes les lettres minuscules de l'alphabet en ordre croissant.

###Prototype :###

```c
void ft_print_alphabet(void);
```

###Explication :###
On utilise un caractÃ¨re `char` initialisÃ© Ã  `'a'` et une boucle `while` ou `for` jusqu'Ã  `'z'`.  
Ã€ chaque itÃ©ration, on affiche la lettre courante avec `write(1, &c, 1)`, puis on incrÃ©mente le
caractÃ¨re.

###Interdictions :###
- Pas de printf
- Pas de puts
- Pas de boucle interdite, mais pas de fonction de lib standard non plus.
- Utiliser uniquement write

###Bulle d'ami :###
"Apprends Ã  rÃ©pÃ©ter des actions simples pour construire de grands rÃ©sultats."

###Mini-TDD :###
CrÃ©e un programme test qui appelle `ft_print_alphabet()` puis redirige la sortie dans un fichier.  
Compare-le avec un fichier attendu contenant :  

`abcdefghijklmnopqrstuvwxyz`

###Exemple de TDD complet :###
1ï¸. Fichier de test (test/main.c)

test/main.c
```c

#include "../include/ft_print_alphabet.h"

int main(void)
{
  ft_print_alphabet();
  return 0;
}
```
2ï¸. Fichier attendu (test/expected.txt)

abcdefghijklmnopqrstuvwxyz

3ï¸. Script de test automatique (test/test.sh)

```bash
#!/bin/bash

# Compiler dans build.sh "astuce faite `watch -n 0.5 ./build.sh`, pour une compilation automatique".  
gcc -Wall -Wextra -Werror -Iinclude src/ft_print_alphabet.c test/main.c -o ex01_test

# ExÃ©cuter et rediriger la sortie
./ex01_test > test/output.txt

# Comparer
diff test/output.txt test/expected.txt > /dev/null

# Affichage rÃ©sultat
if [ $? -eq 0 ]; then
    echo "ex01: Test rÃ©ussi"
else
    echo "ex01: Test Ã©chouÃ©"
fi

# Nettoyage
rm -f ex01_test test/output.txt
```

4ï¸. Compilation avec Makefile
Ajoute dans ton Makefile Ã  la racine :

```makefile
EXERCISES = ex00 ex01
SRC_ex01 = ft_print_alphabet
```

###Cycle TDD rÃ©sumÃ© :###
Ã‰tape Action
1. Ã‰cris un test test/main.c
2. Code minimal ft_print_alphabet.c
3. Test OK ?
4. Refacto si besoin  (par exemple : meilleur nom de variable, clartÃ©)

###Bonus :###
Tester plusieurs fois d'affilÃ©e

```bash
cd ex01
./test/test.sh
```

###Ou depuis la racine :###
```bash
make ex01 && ./ex01_test
```

-------------------------------------------------
## 0.0.2) ex02: ft_print_reverse_alphabet
-------------------------------------------------

###Le but :###
Afficher l'alphabet minuscule en ordre dÃ©croissant.

###Prototype :###

```c
void ft_print_reverse_alphabet(void);
```

###Explication :###
On initialise un caractÃ¨re `char c = 'z'`.  
Tant que `c >= 'a'`, on l'affiche avec `write(1, &c, 1)` puis on dÃ©crÃ©mente avec `c--`.

###Interdictions :###
- Pas de printf
- Seulement write

###Bulle d'ami :###
"Penser en arriÃ¨re est parfois la meilleure faÃ§on d'avancer."

###Mini-TDD :###
CrÃ©e un test qui appelle la fonction, redirige la sortie standard dans un fichier,  
puis vÃ©rifie que ce fichier contient bien :  
`zyxwvutsrqponmlkjihgfedcba`

###TDD complet :###
pour ft_print_reverse_alphabet
1ï¸. Fichier de test (test/main.c)

test/main.c
```c
#include "../include/ft_print_reverse_alphabet.h"

int main(void)
{
  ft_print_reverse_alphabet();
  return 0;
}
```

2ï¸. Fichier attendu (test/expected.txt)

```txt
zyxwvutsrqponmlkjihgfedcba
```

3ï¸. Script de test automatique (test/test.sh)

```bash
#!/bin/bash

# Compiler
gcc -Wall -Wextra -Werror -Iinclude src/ft_print_reverse_alphabet.c test/main.c -o ex02_test

# ExÃ©cuter et rediriger la sortie
./ex02_test > test/output.txt

# Comparer
diff test/output.txt test/expected.txt > /dev/null

# RÃ©sultat
if [ $? -eq 0 ]; then
    echo "ex02: Test rÃ©ussi"
else
    echo "ex02: Test Ã©chouÃ©"
fi

# Nettoyage
rm -f ex02_test test/output.txt
```

###EntrÃ©e dans le Makefile principal :###
Ajoute dans ton Makefile ce qu'il manque pour compiler.

###Tester manuellement :###

```bash
cd ex02
./test/test.sh
```

###RÃ©sumÃ© TDD :###
Ã‰tape Description
1ï¸. Ã‰cris le test (main.c)  Avant de coder
2ï¸. ImplÃ©mente la fonction  Code minimal
3ï¸. Lancer test.sh  Valider comportement
4ï¸. Refacto ou extension  Si besoin

-------------------------------------------------
## 0.0.3) ex03: ft_print_numbers
-------------------------------------------------

###Le but :###
Afficher tous les chiffres de 0 Ã  9.

###Prototype :###
```c
void ft_print_numbers(void);
```

###Explication :###
On initialise une variable `char c = '0'`.  
Tant que `c <= '9'`, on affiche chaque chiffre avec `write(1, &c, 1)` puis on incrÃ©mente `c`.
Chaque chiffre est un caractÃ¨re affichÃ© individuellement.

###Interdictions :###
- Pas de printf
- Seulement write

###Bulle d'ami :###
"Chaque chiffre est juste un petit caractÃ¨re, pense en ASCII."

###Mini-TDD :###
CrÃ©e un fichier de test qui appelle `ft_print_numbers()` puis redirige la sortie standard vers un
fichier.
Compare ensuite ce fichier Ã  un `expected.txt` contenant :  
`0123456789`

###TDD complet :###
pour ft_print_numbers

2ï¸. Fichier attendu (test/expected.txt)

0123456789

3ï¸. Script de test automatique (test/test.sh)

```bash
#!/bin/bash

# Compiler
gcc -Wall -Wextra -Werror -Iinclude src/ft_print_numbers.c test/main.c -o ex03_test

# ExÃ©cuter et rediriger la sortie
./ex03_test > test/output.txt

# Comparer
diff test/output.txt test/expected.txt > /dev/null

# RÃ©sultat
if [ $? -eq 0 ]; then
    echo "ex03: Test rÃ©ussi"
else
    echo "ex03: Test Ã©chouÃ©"
fi

# Nettoyage
rm -f ex03_test test/output.txt
```

###EntrÃ©e dans le Makefile principal :###
Ajoute dans ton Makefile ce qu'il manque pour compiler.

###Tester manuellement :###

```bash
cd ex03
./test/test.sh
```

###RÃ©sumÃ© TDD :###
Ã‰tape Description
1ï¸. Ã‰cris le test (main.c)  Avant dâ€™implÃ©menter
2ï¸. ImplÃ©mente la fonction  Boucle simple
3ï¸. ExÃ©cute test.sh VÃ©rifie le rÃ©sultat
4ï¸. Refacto possible  Si besoin

-------------------------------------------------
## 0.0.4) ex04: ft_is_negative
-------------------------------------------------

###Le but :###
Afficher 'N' si le nombre est nÃ©gatif, sinon 'P' pour positif ou nul.

###Prototype :###

```c
void ft_is_negative(int n);
```

###Explication :###
Utiliser une simple condition pour tester la valeur du nombre.
Si la valeur n est infÃ©rieure Ã  0, on affiche 'N'.
Sinon (n â‰¥ 0), on affiche 'P'.
On utilise write(1, &c, 1) pour afficher un seul caractÃ¨re.

###Interdictions :###
- Pas de printf
- Utiliser uniquement write

###Bulle d'ami :###
"Comparer, c'est trier le monde en deux: les positifs et les nÃ©gatifs."

###Mini-TDD :###
CrÃ©e un programme de test qui appelle ft_is_negative() avec :
>un nombre nÃ©gatif â†’ affiche N
>zÃ©ro â†’ affiche P
>un nombre positif â†’ affiche P

###TDD complet :###
1ï¸. Fichier de test (test/main.c)

// test/main.c
```c
#include "../include/ft_is_negative.h"

int main(void)
{
  ft_is_negative(-1);  // Devrait afficher N
  write(1, "\n", 1);
  ft_is_negative(0);   // Devrait afficher P
  write(1, "\n", 1);
  ft_is_negative(83);  // Devrait afficher P
  write(1, "\n", 1);
  return 0;
}
```
2. Fichier attendu (test/expected.txt)

```txt
N
P
P
```

3ï¸. Script de test automatique (test/test.sh)
Oublie pas de crÃ©er le fichier et l'entrÃ©e dans le Makefile principal.

###ExÃ©cution du test :###

```bash
cd ex04
./test/test.sh
```

-------------------------------------------------
## 0.0.5) ex05: ft_print_comb
-------------------------------------------------

###Le but :###
Afficher toutes les combinaisons de 3 chiffres diffÃ©rents triÃ©s par ordre croissant.

###Prototype :###

```c
void ft_print_comb(void);
```

###Explication :###
Combiner trois chiffres en Ã©vitant les rÃ©pÃ©titions.
On utilise trois boucles imbriquÃ©es :
  >i de '0' Ã  '7'
  >j de i + 1 Ã  '8'
  >k de j + 1 Ã  '9'
Ã€ chaque itÃ©ration, on affiche les trois chiffres avec write,
suivis de ", " sauf pour la derniÃ¨re combinaison 789.

###Interdictions :###
- Pas de printf
- write uniquement

###Bulle d'ami :###
"Chaque chiffre doit Ãªtre plus grand que le prÃ©cÃ©dent."

###Mini-TDD :###
- CrÃ©e un test qui redirige la sortie de ft_print_comb() vers un fichier,
- puis vÃ©rifie quâ€™il contient exactement 120 combinaisons dans lâ€™ordre croissant,
- ex : 012, 013, ..., 789 (sans virgule finale).
- la comparaison diff est sensible aux espaces finaux et retours Ã  la ligne
- certaines sorties peuvent Ãªtre longues et doivent Ãªtre tronquÃ©es dans expected.txt avec head -n 1 ou Ã©quivalent si
  besoin.

###TDD complet :###

1. Fichier attendu (test/expected.txt)
Contenu Ã  gÃ©nÃ©rer automatiquement (ou copier manuellement depuis l'exÃ©cution correcte une fois) :

012, 013, 014, 015, 016, 017, 018, 019, 023, 024, 025, 026, 027, 028, 029, 034, 035, 036, 037, 038, 039, 045, 046, 047, 048, 049, 056, 057, 058, 059, 067, 068, 069, 078, 079, 089, 123, 124, 125, 126, 127, 128, 129, 134, 135, 136, 137, 138, 139, 145, 146, 147, 148, 149, 156, 157, 158, 159, 167, 168, 169, 178, 179, 189, 234, 235, 236, 237, 238, 239, 245, 246, 247, 248, 249, 256, 257, 258, 259, 267, 268, 269, 278, 279, 289, 345, 346, 347, 348, 349, 356, 357, 358, 359, 367, 368, 369, 378, 379, 389, 456, 457, 458, 459, 467, 468, 469, 478, 479, 489, 567, 568, 569, 578, 579, 589, 678, 679, 689, 789

(Pas de retour Ã  la ligne Ã  la fin si on veut comparer Ã  lâ€™identique)

Script de test.
Oublie pas le Makefile.

###ExÃ©cution du test :###

```bash
cd ex05
./test/test.sh
```

-------------------------------------------------
## 0.0.6) ex06: ft_print_comb2
-------------------------------------------------

###Le but :###
Afficher toutes les combinaisons possibles de deux nombres Ã  deux chiffres (00 01 Ã  98 99), triÃ©es, sÃ©parÃ©es par ", " (sauf la derniÃ¨re).

###Prototype :###

```c
void ft_print_comb2(void);
```

###Explication :###
Comparer deux nombres de 00 Ã  99 et afficher ceux dans le bon ordre.
On utilise deux boucles i et j allant de 0 Ã  99.
Pour chaque paire (i, j), si i < j, on affiche la combinaison avec le bon format (00 01).
Chaque nombre est affichÃ© avec deux chiffres (ajouter '0' si nÃ©cessaire).
Chaque combinaison est sÃ©parÃ©e par ", " sauf la derniÃ¨re (98 99).

###Interdictions :###
Pas de printf
write uniquement

###Bulle d'ami :###
"Chaque nombre est une paire, traite-les comme un duo insÃ©parable."

###Mini-TDD :###
CrÃ©e un test qui redirige la sortie de ft_print_comb2() vers un fichier.
Le fichier doit contenir 4950 combinaisons allant de 00 01 Ã  98 99,
sÃ©parÃ©es par ", ", sans virgule finale Ã  la fin.

###TDD :###

1. Fichier attendu (test/expected.txt)
Ce fichier contient une seule ligne gÃ©nÃ©rÃ©e avec :

test/expected.txt

00 01, 00 02, 00 03, 00 04, 00 05, 00 06, 00 07, 00 08, 00 09, 00 10, 00 11, 00 12, 00 13, 00 14, 00 15, 00 16, 00 17, 00 18, 00 19, 00 20, 00 21, 00 22, 00 23, 00 24, 00 25, 00 26, 00 27, 00 28, 00 29, 00 30, 00 31, 00 32, 00 33, 00 34, 00 35, 00 36, 00 37, 00 38, 00 39, 00 40, 00 41, 00 42, 00 43, 00 44, 00 45, 00 46, 00 47, 00 48, 00 49, 00 50, 00 51, 00 52, 00 53, 00 54, 00 55, 00 56, 00 57, 00 58, 00 59, 00 60, 00 61, 00 62, 00 63, 00 64, 00 65, 00 66, 00 67, 00 68, 00 69, 00 70, 00 71, 00 72, 00 73, 00 74, 00 75, 00 76, 00 77, 00 78, 00 79, 00 80, 00 81, 00 82, 00 83, 00 84, 00 85, 00 86, 00 87, 00 88, 00 89, 00 90, 00 91, 00 92, 00 93, 00 94, 00 95, 00 96, 00 97, 00 98, 00 99, 01 02, 01 03, 01 04, 01 05, 01 06, 01 07, 01 08, 01 09, 01 10, 01 11, 01 12, 01 13, 01 14, 01 15, 01 16, 01 17, 01 18, 01 19, 01 20, 01 21, 01 22, 01 23, 01 24, 01 25, 01 26, 01 27, 01 28, 01 29, 01 30, 01 31, 01 32, 01 33, 01 34, 01 35, 01 36, 01 37, 01 38, 01 39, 01 40, 01 41, 01 42, 01 43, 01 44, 01 45, 01 46, 01 47, 01 48, 01 49, 01 50, 01 51, 01 52, 01 53, 01 54, 01 55, 01 56, 01 57, 01 58, 01 59, 01 60, 01 61, 01 62, 01 63, 01 64, 01 65, 01 66, 01 67, 01 68, 01 69, 01 70, 01 71, 01 72, 01 73, 01 74, 01 75, 01 76, 01 77, 01 78, 01 79, 01 80, 01 81, 01 82, 01 83, 01 84, 01 85, 01 86, 01 87, 01 88, 01 89, 01 90, 01 91, 01 92, 01 93, 01 94, 01 95, 01 96, 01 97, 01 98, 01 99, 02 03, 02 04, 02 05, 02 06, 02 07, 02 08, 02 09, 02 10, 02 11, 02 12, 02 13, 02 14, 02 15, 02 16, 02 17, 02 18, 02 19, 02 20, 02 21, 02 22, 02 23, 02 24, 02 25, 02 26, 02 27, 02 28, 02 29, 02 30, 02 31, 02 32, 02 33, 02 34, 02 35, 02 36, 02 37, 02 38, 02 39, 02 40, 02 41, 02 42, 02 43, 02 44, 02 45, 02 46, 02 47, 02 48, 02 49, 02 50, 02 51, 02 52, 02 53, 02 54, 02 55, 02 56, 02 57, 02 58, 02 59, 02 60, 02 61, 02 62, 02 63, 02 64, 02 65, 02 66, 02 67, 02 68, 02 69, 02 70, 02 71, 02 72, 02 73, 02 74, 02 75, 02 76, 02 77, 02 78, 02 79, 02 80, 02 81, 02 82, 02 83, 02 84, 02 85, 02 86, 02 87, 02 88, 02 89, 02 90, 02 91, 02 92, 02 93, 02 94, 02 95, 02 96, 02 97, 02 98, 02 99, 03 04, 03 05, 03 06, 03 07, 03 08, 03 09, 03 10, 03 11, 03 12, 03 13, 03 14, 03 15, 03 16, 03 17, 03 18, 03 19, 03 20, 03 21, 03 22, 03 23, 03 24, 03 25, 03 26, 03 27, 03 28, 03 29, 03 30, 03 31, 03 32, 03 33, 03 34, 03 35, 03 36, 03 37, 03 38, 03 39, 03 40, 03 41, 03 42, 03 43, 03 44, 03 45, 03 46, 03 47, 03 48, 03 49, 03 50, 03 51, 03 52, 03 53, 03 54, 03 55, 03 56, 03 57, 03 58, 03 59, 03 60, 03 61, 03 62, 03 63, 03 64, 03 65, 03 66, 03 67, 03 68, 03 69, 03 70, 03 71, 03 72, 03 73, 03 74, 03 75, 03 76, 03 77, 03 78, 03 79, 03 80, 03 81, 03 82, 03 83, 03 84, 03 85, 03 86, 03 87, 03 88, 03 89, 03 90, 03 91, 03 92, 03 93, 03 94, 03 95, 03 96, 03 97, 03 98, 03 99, 04 05, 04 06, 04 07, 04 08, 04 09, 04 10, 04 11, 04 12, 04 13, 04 14, 04 15, 04 16, 04 17, 04 18, 04 19, 04 20, 04 21, 04 22, 04 23, 04 24, 04 25, 04 26, 04 27, 04 28, 04 29, 04 30, 04 31, 04 32, 04 33, 04 34, 04 35, 04 36, 04 37, 04 38, 04 39, 04 40, 04 41, 04 42, 04 43, 04 44, 04 45, 04 46, 04 47, 04 48, 04 49, 04 50, 04 51, 04 52, 04 53, 04 54, 04 55, 04 56, 04 57, 04 58, 04 59, 04 60, 04 61, 04 62, 04 63, 04 64, 04 65, 04 66, 04 67, 04 68, 04 69, 04 70, 04 71, 04 72, 04 73, 04 74, 04 75, 04 76, 04 77, 04 78, 04 79, 04 80, 04 81, 04 82, 04 83, 04 84, 04 85, 04 86, 04 87, 04 88, 04 89, 04 90, 04 91, 04 92, 04 93, 04 94, 04 95, 04 96, 04 97, 04 98, 04 99, 05 06, 05 07, 05 08, 05 09, 05 10, 05 11, 05 12, 05 13, 05 14, 05 15, 05 16, 05 17, 05 18, 05 19, 05 20, 05 21, 05 22, 05 23, 05 24, 05 25, 05 26, 05 27, 05 28, 05 29, 05 30, 05 31, 05 32, 05 33, 05 34, 05 35, 05 36, 05 37, 05 38, 05 39, 05 40, 05 41, 05 42, 05 43, 05 44, 05 45, 05 46, 05 47, 05 48, 05 49, 05 50, 05 51, 05 52, 05 53, 05 54, 05 55, 05 56, 05 57, 05 58, 05 59, 05 60, 05 61, 05 62, 05 63, 05 64, 05 65, 05 66, 05 67, 05 68, 05 69, 05 70, 05 71, 05 72, 05 73, 05 74, 05 75, 05 76, 05 77, 05 78, 05 79, 05 80, 05 81, 05 82, 05 83, 05 84, 05 85, 05 86, 05 87, 05 88, 05 89, 05 90, 05 91, 05 92, 05 93, 05 94, 05 95, 05 96, 05 97, 05 98, 05 99, 06 07, 06 08, 06 09, 06 10, 06 11, 06 12, 06 13, 06 14, 06 15, 06 16, 06 17, 06 18, 06 19, 06 20, 06 21, 06 22, 06 23, 06 24, 06 25, 06 26, 06 27, 06 28, 06 29, 06 30, 06 31, 06 32, 06 33, 06 34, 06 35, 06 36, 06 37, 06 38, 06 39, 06 40, 06 41, 06 42, 06 43, 06 44, 06 45, 06 46, 06 47, 06 48, 06 49, 06 50, 06 51, 06 52, 06 53, 06 54, 06 55, 06 56, 06 57, 06 58, 06 59, 06 60, 06 61, 06 62, 06 63, 06 64, 06 65, 06 66, 06 67, 06 68, 06 69, 06 70, 06 71, 06 72, 06 73, 06 74, 06 75, 06 76, 06 77, 06 78, 06 79, 06 80, 06 81, 06 82, 06 83, 06 84, 06 85, 06 86, 06 87, 06 88, 06 89, 06 90, 06 91, 06 92, 06 93, 06 94, 06 95, 06 96, 06 97, 06 98, 06 99, 07 08, 07 09, 07 10, 07 11, 07 12, 07 13, 07 14, 07 15, 07 16, 07 17, 07 18, 07 19, 07 20, 07 21, 07 22, 07 23, 07 24, 07 25, 07 26, 07 27, 07 28, 07 29, 07 30, 07 31, 07 32, 07 33, 07 34, 07 35, 07 36, 07 37, 07 38, 07 39, 07 40, 07 41, 07 42, 07 43, 07 44, 07 45, 07 46, 07 47, 07 48, 07 49, 07 50, 07 51, 07 52, 07 53, 07 54, 07 55, 07 56, 07 57, 07 58, 07 59, 07 60, 07 61, 07 62, 07 63, 07 64, 07 65, 07 66, 07 67, 07 68, 07 69, 07 70, 07 71, 07 72, 07 73, 07 74, 07 75, 07 76, 07 77, 07 78, 07 79, 07 80, 07 81, 07 82, 07 83, 07 84, 07 85, 07 86, 07 87, 07 88, 07 89, 07 90, 07 91, 07 92, 07 93, 07 94, 07 95, 07 96, 07 97, 07 98, 07 99, 08 09, 08 10, 08 11, 08 12, 08 13, 08 14, 08 15, 08 16, 08 17, 08 18, 08 19, 08 20, 08 21, 08 22, 08 23, 08 24, 08 25, 08 26, 08 27, 08 28, 08 29, 08 30, 08 31, 08 32, 08 33, 08 34, 08 35, 08 36, 08 37, 08 38, 08 39, 08 40, 08 41, 08 42, 08 43, 08 44, 08 45, 08 46, 08 47, 08 48, 08 49, 08 50, 08 51, 08 52, 08 53, 08 54, 08 55, 08 56, 08 57, 08 58, 08 59, 08 60, 08 61, 08 62, 08 63, 08 64, 08 65, 08 66, 08 67, 08 68, 08 69, 08 70, 08 71, 08 72, 08 73, 08 74, 08 75, 08 76, 08 77, 08 78, 08 79, 08 80, 08 81, 08 82, 08 83, 08 84, 08 85, 08 86, 08 87, 08 88, 08 89, 08 90, 08 91, 08 92, 08 93, 08 94, 08 95, 08 96, 08 97, 08 98, 08 99, 09 10, 09 11, 09 12, 09 13, 09 14, 09 15, 09 16, 09 17, 09 18, 09 19, 09 20, 09 21, 09 22, 09 23, 09 24, 09 25, 09 26, 09 27, 09 28, 09 29, 09 30, 09 31, 09 32, 09 33, 09 34, 09 35, 09 36, 09 37, 09 38, 09 39, 09 40, 09 41, 09 42, 09 43, 09 44, 09 45, 09 46, 09 47, 09 48, 09 49, 09 50, 09 51, 09 52, 09 53, 09 54, 09 55, 09 56, 09 57, 09 58, 09 59, 09 60, 09 61, 09 62, 09 63, 09 64, 09 65, 09 66, 09 67, 09 68, 09 69, 09 70, 09 71, 09 72, 09 73, 09 74, 09 75, 09 76, 09 77, 09 78, 09 79, 09 80, 09 81, 09 82, 09 83, 09 84, 09 85, 09 86, 09 87, 09 88, 09 89, 09 90, 09 91, 09 92, 09 93, 09 94, 09 95, 09 96, 09 97, 09 98, 09 99, 10 11, 10 12, 10 13, 10 14, 10 15, 10 16, 10 17, 10 18, 10 19, 10 20, 10 21, 10 22, 10 23, 10 24, 10 25, 10 26, 10 27, 10 28, 10 29, 10 30, 10 31, 10 32, 10 33, 10 34, 10 35, 10 36, 10 37, 10 38, 10 39, 10 40, 10 41, 10 42, 10 43, 10 44, 10 45, 10 46, 10 47, 10 48, 10 49, 10 50, 10 51, 10 52, 10 53, 10 54, 10 55, 10 56, 10 57, 10 58, 10 59, 10 60, 10 61, 10 62, 10 63, 10 64, 10 65, 10 66, 10 67, 10 68, 10 69, 10 70, 10 71, 10 72, 10 73, 10 74, 10 75, 10 76, 10 77, 10 78, 10 79, 10 80, 10 81, 10 82, 10 83, 10 84, 10 85, 10 86, 10 87, 10 88, 10 89, 10 90, 10 91, 10 92, 10 93, 10 94, 10 95, 10 96, 10 97, 10 98, 10 99, 11 12, 11 13, 11 14, 11 15, 11 16, 11 17, 11 18, 11 19, 11 20, 11 21, 11 22, 11 23, 11 24, 11 25, 11 26, 11 27, 11 28, 11 29, 11 30, 11 31, 11 32, 11 33, 11 34, 11 35, 11 36, 11 37, 11 38, 11 39, 11 40, 11 41, 11 42, 11 43, 11 44, 11 45, 11 46, 11 47, 11 48, 11 49, 11 50, 11 51, 11 52, 11 53, 11 54, 11 55, 11 56, 11 57, 11 58, 11 59, 11 60, 11 61, 11 62, 11 63, 11 64, 11 65, 11 66, 11 67, 11 68, 11 69, 11 70, 11 71, 11 72, 11 73, 11 74, 11 75, 11 76, 11 77, 11 78, 11 79, 11 80, 11 81, 11 82, 11 83, 11 84, 11 85, 11 86, 11 87, 11 88, 11 89, 11 90, 11 91, 11 92, 11 93, 11 94, 11 95, 11 96, 11 97, 11 98, 11 99, 12 13, 12 14, 12 15, 12 16, 12 17, 12 18, 12 19, 12 20, 12 21, 12 22, 12 23, 12 24, 12 25, 12 26, 12 27, 12 28, 12 29, 12 30, 12 31, 12 32, 12 33, 12 34, 12 35, 12 36, 12 37, 12 38, 12 39, 12 40, 12 41, 12 42, 12 43, 12 44, 12 45, 12 46, 12 47, 12 48, 12 49, 12 50, 12 51, 12 52, 12 53, 12 54, 12 55, 12 56, 12 57, 12 58, 12 59, 12 60, 12 61, 12 62, 12 63, 12 64, 12 65, 12 66, 12 67, 12 68, 12 69, 12 70, 12 71, 12 72, 12 73, 12 74, 12 75, 12 76, 12 77, 12 78, 12 79, 12 80, 12 81, 12 82, 12 83, 12 84, 12 85, 12 86, 12 87, 12 88, 12 89, 12 90, 12 91, 12 92, 12 93, 12 94, 12 95, 12 96, 12 97, 12 98, 12 99, 13 14, 13 15, 13 16, 13 17, 13 18, 13 19, 13 20, 13 21, 13 22, 13 23, 13 24, 13 25, 13 26, 13 27, 13 28, 13 29, 13 30, 13 31, 13 32, 13 33, 13 34, 13 35, 13 36, 13 37, 13 38, 13 39, 13 40, 13 41, 13 42, 13 43, 13 44, 13 45, 13 46, 13 47, 13 48, 13 49, 13 50, 13 51, 13 52, 13 53, 13 54, 13 55, 13 56, 13 57, 13 58, 13 59, 13 60, 13 61, 13 62, 13 63, 13 64, 13 65, 13 66, 13 67, 13 68, 13 69, 13 70, 13 71, 13 72, 13 73, 13 74, 13 75, 13 76, 13 77, 13 78, 13 79, 13 80, 13 81, 13 82, 13 83, 13 84, 13 85, 13 86, 13 87, 13 88, 13 89, 13 90, 13 91, 13 92, 13 93, 13 94, 13 95, 13 96, 13 97, 13 98, 13 99, 14 15, 14 16, 14 17, 14 18, 14 19, 14 20, 14 21, 14 22, 14 23, 14 24, 14 25, 14 26, 14 27, 14 28, 14 29, 14 30, 14 31, 14 32, 14 33, 14 34, 14 35, 14 36, 14 37, 14 38, 14 39, 14 40, 14 41, 14 42, 14 43, 14 44, 14 45, 14 46, 14 47, 14 48, 14 49, 14 50, 14 51, 14 52, 14 53, 14 54, 14 55, 14 56, 14 57, 14 58, 14 59, 14 60, 14 61, 14 62, 14 63, 14 64, 14 65, 14 66, 14 67, 14 68, 14 69, 14 70, 14 71, 14 72, 14 73, 14 74, 14 75, 14 76, 14 77, 14 78, 14 79, 14 80, 14 81, 14 82, 14 83, 14 84, 14 85, 14 86, 14 87, 14 88, 14 89, 14 90, 14 91, 14 92, 14 93, 14 94, 14 95, 14 96, 14 97, 14 98, 14 99, 15 16, 15 17, 15 18, 15 19, 15 20, 15 21, 15 22, 15 23, 15 24, 15 25, 15 26, 15 27, 15 28, 15 29, 15 30, 15 31, 15 32, 15 33, 15 34, 15 35, 15 36, 15 37, 15 38, 15 39, 15 40, 15 41, 15 42, 15 43, 15 44, 15 45, 15 46, 15 47, 15 48, 15 49, 15 50, 15 51, 15 52, 15 53, 15 54, 15 55, 15 56, 15 57, 15 58, 15 59, 15 60, 15 61, 15 62, 15 63, 15 64, 15 65, 15 66, 15 67, 15 68, 15 69, 15 70, 15 71, 15 72, 15 73, 15 74, 15 75, 15 76, 15 77, 15 78, 15 79, 15 80, 15 81, 15 82, 15 83, 15 84, 15 85, 15 86, 15 87, 15 88, 15 89, 15 90, 15 91, 15 92, 15 93, 15 94, 15 95, 15 96, 15 97, 15 98, 15 99, 16 17, 16 18, 16 19, 16 20, 16 21, 16 22, 16 23, 16 24, 16 25, 16 26, 16 27, 16 28, 16 29, 16 30, 16 31, 16 32, 16 33, 16 34, 16 35, 16 36, 16 37, 16 38, 16 39, 16 40, 16 41, 16 42, 16 43, 16 44, 16 45, 16 46, 16 47, 16 48, 16 49, 16 50, 16 51, 16 52, 16 53, 16 54, 16 55, 16 56, 16 57, 16 58, 16 59, 16 60, 16 61, 16 62, 16 63, 16 64, 16 65, 16 66, 16 67, 16 68, 16 69, 16 70, 16 71, 16 72, 16 73, 16 74, 16 75, 16 76, 16 77, 16 78, 16 79, 16 80, 16 81, 16 82, 16 83, 16 84, 16 85, 16 86, 16 87, 16 88, 16 89, 16 90, 16 91, 16 92, 16 93, 16 94, 16 95, 16 96, 16 97, 16 98, 16 99, 17 18, 17 19, 17 20, 17 21, 17 22, 17 23, 17 24, 17 25, 17 26, 17 27, 17 28, 17 29, 17 30, 17 31, 17 32, 17 33, 17 34, 17 35, 17 36, 17 37, 17 38, 17 39, 17 40, 17 41, 17 42, 17 43, 17 44, 17 45, 17 46, 17 47, 17 48, 17 49, 17 50, 17 51, 17 52, 17 53, 17 54, 17 55, 17 56, 17 57, 17 58, 17 59, 17 60, 17 61, 17 62, 17 63, 17 64, 17 65, 17 66, 17 67, 17 68, 17 69, 17 70, 17 71, 17 72, 17 73, 17 74, 17 75, 17 76, 17 77, 17 78, 17 79, 17 80, 17 81, 17 82, 17 83, 17 84, 17 85, 17 86, 17 87, 17 88, 17 89, 17 90, 17 91, 17 92, 17 93, 17 94, 17 95, 17 96, 17 97, 17 98, 17 99, 18 19, 18 20, 18 21, 18 22, 18 23, 18 24, 18 25, 18 26, 18 27, 18 28, 18 29, 18 30, 18 31, 18 32, 18 33, 18 34, 18 35, 18 36, 18 37, 18 38, 18 39, 18 40, 18 41, 18 42, 18 43, 18 44, 18 45, 18 46, 18 47, 18 48, 18 49, 18 50, 18 51, 18 52, 18 53, 18 54, 18 55, 18 56, 18 57, 18 58, 18 59, 18 60, 18 61, 18 62, 18 63, 18 64, 18 65, 18 66, 18 67, 18 68, 18 69, 18 70, 18 71, 18 72, 18 73, 18 74, 18 75, 18 76, 18 77, 18 78, 18 79, 18 80, 18 81, 18 82, 18 83, 18 84, 18 85, 18 86, 18 87, 18 88, 18 89, 18 90, 18 91, 18 92, 18 93, 18 94, 18 95, 18 96, 18 97, 18 98, 18 99, 19 20, 19 21, 19 22, 19 23, 19 24, 19 25, 19 26, 19 27, 19 28, 19 29, 19 30, 19 31, 19 32, 19 33, 19 34, 19 35, 19 36, 19 37, 19 38, 19 39, 19 40, 19 41, 19 42, 19 43, 19 44, 19 45, 19 46, 19 47, 19 48, 19 49, 19 50, 19 51, 19 52, 19 53, 19 54, 19 55, 19 56, 19 57, 19 58, 19 59, 19 60, 19 61, 19 62, 19 63, 19 64, 19 65, 19 66, 19 67, 19 68, 19 69, 19 70, 19 71, 19 72, 19 73, 19 74, 19 75, 19 76, 19 77, 19 78, 19 79, 19 80, 19 81, 19 82, 19 83, 19 84, 19 85, 19 86, 19 87, 19 88, 19 89, 19 90, 19 91, 19 92, 19 93, 19 94, 19 95, 19 96, 19 97, 19 98, 19 99, 20 21, 20 22, 20 23, 20 24, 20 25, 20 26, 20 27, 20 28, 20 29, 20 30, 20 31, 20 32, 20 33, 20 34, 20 35, 20 36, 20 37, 20 38, 20 39, 20 40, 20 41, 20 42, 20 43, 20 44, 20 45, 20 46, 20 47, 20 48, 20 49, 20 50, 20 51, 20 52, 20 53, 20 54, 20 55, 20 56, 20 57, 20 58, 20 59, 20 60, 20 61, 20 62, 20 63, 20 64, 20 65, 20 66, 20 67, 20 68, 20 69, 20 70, 20 71, 20 72, 20 73, 20 74, 20 75, 20 76, 20 77, 20 78, 20 79, 20 80, 20 81, 20 82, 20 83, 20 84, 20 85, 20 86, 20 87, 20 88, 20 89, 20 90, 20 91, 20 92, 20 93, 20 94, 20 95, 20 96, 20 97, 20 98, 20 99, 21 22, 21 23, 21 24, 21 25, 21 26, 21 27, 21 28, 21 29, 21 30, 21 31, 21 32, 21 33, 21 34, 21 35, 21 36, 21 37, 21 38, 21 39, 21 40, 21 41, 21 42, 21 43, 21 44, 21 45, 21 46, 21 47, 21 48, 21 49, 21 50, 21 51, 21 52, 21 53, 21 54, 21 55, 21 56, 21 57, 21 58, 21 59, 21 60, 21 61, 21 62, 21 63, 21 64, 21 65, 21 66, 21 67, 21 68, 21 69, 21 70, 21 71, 21 72, 21 73, 21 74, 21 75, 21 76, 21 77, 21 78, 21 79, 21 80, 21 81, 21 82, 21 83, 21 84, 21 85, 21 86, 21 87, 21 88, 21 89, 21 90, 21 91, 21 92, 21 93, 21 94, 21 95, 21 96, 21 97, 21 98, 21 99, 22 23, 22 24, 22 25, 22 26, 22 27, 22 28, 22 29, 22 30, 22 31, 22 32, 22 33, 22 34, 22 35, 22 36, 22 37, 22 38, 22 39, 22 40, 22 41, 22 42, 22 43, 22 44, 22 45, 22 46, 22 47, 22 48, 22 49, 22 50, 22 51, 22 52, 22 53, 22 54, 22 55, 22 56, 22 57, 22 58, 22 59, 22 60, 22 61, 22 62, 22 63, 22 64, 22 65, 22 66, 22 67, 22 68, 22 69, 22 70, 22 71, 22 72, 22 73, 22 74, 22 75, 22 76, 22 77, 22 78, 22 79, 22 80, 22 81, 22 82, 22 83, 22 84, 22 85, 22 86, 22 87, 22 88, 22 89, 22 90, 22 91, 22 92, 22 93, 22 94, 22 95, 22 96, 22 97, 22 98, 22 99, 23 24, 23 25, 23 26, 23 27, 23 28, 23 29, 23 30, 23 31, 23 32, 23 33, 23 34, 23 35, 23 36, 23 37, 23 38, 23 39, 23 40, 23 41, 23 42, 23 43, 23 44, 23 45, 23 46, 23 47, 23 48, 23 49, 23 50, 23 51, 23 52, 23 53, 23 54, 23 55, 23 56, 23 57, 23 58, 23 59, 23 60, 23 61, 23 62, 23 63, 23 64, 23 65, 23 66, 23 67, 23 68, 23 69, 23 70, 23 71, 23 72, 23 73, 23 74, 23 75, 23 76, 23 77, 23 78, 23 79, 23 80, 23 81, 23 82, 23 83, 23 84, 23 85, 23 86, 23 87, 23 88, 23 89, 23 90, 23 91, 23 92, 23 93, 23 94, 23 95, 23 96, 23 97, 23 98, 23 99, 24 25, 24 26, 24 27, 24 28, 24 29, 24 30, 24 31, 24 32, 24 33, 24 34, 24 35, 24 36, 24 37, 24 38, 24 39, 24 40, 24 41, 24 42, 24 43, 24 44, 24 45, 24 46, 24 47, 24 48, 24 49, 24 50, 24 51, 24 52, 24 53, 24 54, 24 55, 24 56, 24 57, 24 58, 24 59, 24 60, 24 61, 24 62, 24 63, 24 64, 24 65, 24 66, 24 67, 24 68, 24 69, 24 70, 24 71, 24 72, 24 73, 24 74, 24 75, 24 76, 24 77, 24 78, 24 79, 24 80, 24 81, 24 82, 24 83, 24 84, 24 85, 24 86, 24 87, 24 88, 24 89, 24 90, 24 91, 24 92, 24 93, 24 94, 24 95, 24 96, 24 97, 24 98, 24 99, 25 26, 25 27, 25 28, 25 29, 25 30, 25 31, 25 32, 25 33, 25 34, 25 35, 25 36, 25 37, 25 38, 25 39, 25 40, 25 41, 25 42, 25 43, 25 44, 25 45, 25 46, 25 47, 25 48, 25 49, 25 50, 25 51, 25 52, 25 53, 25 54, 25 55, 25 56, 25 57, 25 58, 25 59, 25 60, 25 61, 25 62, 25 63, 25 64, 25 65, 25 66, 25 67, 25 68, 25 69, 25 70, 25 71, 25 72, 25 73, 25 74, 25 75, 25 76, 25 77, 25 78, 25 79, 25 80, 25 81, 25 82, 25 83, 25 84, 25 85, 25 86, 25 87, 25 88, 25 89, 25 90, 25 91, 25 92, 25 93, 25 94, 25 95, 25 96, 25 97, 25 98, 25 99, 26 27, 26 28, 26 29, 26 30, 26 31, 26 32, 26 33, 26 34, 26 35, 26 36, 26 37, 26 38, 26 39, 26 40, 26 41, 26 42, 26 43, 26 44, 26 45, 26 46, 26 47, 26 48, 26 49, 26 50, 26 51, 26 52, 26 53, 26 54, 26 55, 26 56, 26 57, 26 58, 26 59, 26 60, 26 61, 26 62, 26 63, 26 64, 26 65, 26 66, 26 67, 26 68, 26 69, 26 70, 26 71, 26 72, 26 73, 26 74, 26 75, 26 76, 26 77, 26 78, 26 79, 26 80, 26 81, 26 82, 26 83, 26 84, 26 85, 26 86, 26 87, 26 88, 26 89, 26 90, 26 91, 26 92, 26 93, 26 94, 26 95, 26 96, 26 97, 26 98, 26 99, 27 28, 27 29, 27 30, 27 31, 27 32, 27 33, 27 34, 27 35, 27 36, 27 37, 27 38, 27 39, 27 40, 27 41, 27 42, 27 43, 27 44, 27 45, 27 46, 27 47, 27 48, 27 49, 27 50, 27 51, 27 52, 27 53, 27 54, 27 55, 27 56, 27 57, 27 58, 27 59, 27 60, 27 61, 27 62, 27 63, 27 64, 27 65, 27 66, 27 67, 27 68, 27 69, 27 70, 27 71, 27 72, 27 73, 27 74, 27 75, 27 76, 27 77, 27 78, 27 79, 27 80, 27 81, 27 82, 27 83, 27 84, 27 85, 27 86, 27 87, 27 88, 27 89, 27 90, 27 91, 27 92, 27 93, 27 94, 27 95, 27 96, 27 97, 27 98, 27 99, 28 29, 28 30, 28 31, 28 32, 28 33, 28 34, 28 35, 28 36, 28 37, 28 38, 28 39, 28 40, 28 41, 28 42, 28 43, 28 44, 28 45, 28 46, 28 47, 28 48, 28 49, 28 50, 28 51, 28 52, 28 53, 28 54, 28 55, 28 56, 28 57, 28 58, 28 59, 28 60, 28 61, 28 62, 28 63, 28 64, 28 65, 28 66, 28 67, 28 68, 28 69, 28 70, 28 71, 28 72, 28 73, 28 74, 28 75, 28 76, 28 77, 28 78, 28 79, 28 80, 28 81, 28 82, 28 83, 28 84, 28 85, 28 86, 28 87, 28 88, 28 89, 28 90, 28 91, 28 92, 28 93, 28 94, 28 95, 28 96, 28 97, 28 98, 28 99, 29 30, 29 31, 29 32, 29 33, 29 34, 29 35, 29 36, 29 37, 29 38, 29 39, 29 40, 29 41, 29 42, 29 43, 29 44, 29 45, 29 46, 29 47, 29 48, 29 49, 29 50, 29 51, 29 52, 29 53, 29 54, 29 55, 29 56, 29 57, 29 58, 29 59, 29 60, 29 61, 29 62, 29 63, 29 64, 29 65, 29 66, 29 67, 29 68, 29 69, 29 70, 29 71, 29 72, 29 73, 29 74, 29 75, 29 76, 29 77, 29 78, 29 79, 29 80, 29 81, 29 82, 29 83, 29 84, 29 85, 29 86, 29 87, 29 88, 29 89, 29 90, 29 91, 29 92, 29 93, 29 94, 29 95, 29 96, 29 97, 29 98, 29 99, 30 31, 30 32, 30 33, 30 34, 30 35, 30 36, 30 37, 30 38, 30 39, 30 40, 30 41, 30 42, 30 43, 30 44, 30 45, 30 46, 30 47, 30 48, 30 49, 30 50, 30 51, 30 52, 30 53, 30 54, 30 55, 30 56, 30 57, 30 58, 30 59, 30 60, 30 61, 30 62, 30 63, 30 64, 30 65, 30 66, 30 67, 30 68, 30 69, 30 70, 30 71, 30 72, 30 73, 30 74, 30 75, 30 76, 30 77, 30 78, 30 79, 30 80, 30 81, 30 82, 30 83, 30 84, 30 85, 30 86, 30 87, 30 88, 30 89, 30 90, 30 91, 30 92, 30 93, 30 94, 30 95, 30 96, 30 97, 30 98, 30 99, 31 32, 31 33, 31 34, 31 35, 31 36, 31 37, 31 38, 31 39, 31 40, 31 41, 31 42, 31 43, 31 44, 31 45, 31 46, 31 47, 31 48, 31 49, 31 50, 31 51, 31 52, 31 53, 31 54, 31 55, 31 56, 31 57, 31 58, 31 59, 31 60, 31 61, 31 62, 31 63, 31 64, 31 65, 31 66, 31 67, 31 68, 31 69, 31 70, 31 71, 31 72, 31 73, 31 74, 31 75, 31 76, 31 77, 31 78, 31 79, 31 80, 31 81, 31 82, 31 83, 31 84, 31 85, 31 86, 31 87, 31 88, 31 89, 31 90, 31 91, 31 92, 31 93, 31 94, 31 95, 31 96, 31 97, 31 98, 31 99, 32 33, 32 34, 32 35, 32 36, 32 37, 32 38, 32 39, 32 40, 32 41, 32 42, 32 43, 32 44, 32 45, 32 46, 32 47, 32 48, 32 49, 32 50, 32 51, 32 52, 32 53, 32 54, 32 55, 32 56, 32 57, 32 58, 32 59, 32 60, 32 61, 32 62, 32 63, 32 64, 32 65, 32 66, 32 67, 32 68, 32 69, 32 70, 32 71, 32 72, 32 73, 32 74, 32 75, 32 76, 32 77, 32 78, 32 79, 32 80, 32 81, 32 82, 32 83, 32 84, 32 85, 32 86, 32 87, 32 88, 32 89, 32 90, 32 91, 32 92, 32 93, 32 94, 32 95, 32 96, 32 97, 32 98, 32 99, 33 34, 33 35, 33 36, 33 37, 33 38, 33 39, 33 40, 33 41, 33 42, 33 43, 33 44, 33 45, 33 46, 33 47, 33 48, 33 49, 33 50, 33 51, 33 52, 33 53, 33 54, 33 55, 33 56, 33 57, 33 58, 33 59, 33 60, 33 61, 33 62, 33 63, 33 64, 33 65, 33 66, 33 67, 33 68, 33 69, 33 70, 33 71, 33 72, 33 73, 33 74, 33 75, 33 76, 33 77, 33 78, 33 79, 33 80, 33 81, 33 82, 33 83, 33 84, 33 85, 33 86, 33 87, 33 88, 33 89, 33 90, 33 91, 33 92, 33 93, 33 94, 33 95, 33 96, 33 97, 33 98, 33 99, 34 35, 34 36, 34 37, 34 38, 34 39, 34 40, 34 41, 34 42, 34 43, 34 44, 34 45, 34 46, 34 47, 34 48, 34 49, 34 50, 34 51, 34 52, 34 53, 34 54, 34 55, 34 56, 34 57, 34 58, 34 59, 34 60, 34 61, 34 62, 34 63, 34 64, 34 65, 34 66, 34 67, 34 68, 34 69, 34 70, 34 71, 34 72, 34 73, 34 74, 34 75, 34 76, 34 77, 34 78, 34 79, 34 80, 34 81, 34 82, 34 83, 34 84, 34 85, 34 86, 34 87, 34 88, 34 89, 34 90, 34 91, 34 92, 34 93, 34 94, 34 95, 34 96, 34 97, 34 98, 34 99, 35 36, 35 37, 35 38, 35 39, 35 40, 35 41, 35 42, 35 43, 35 44, 35 45, 35 46, 35 47, 35 48, 35 49, 35 50, 35 51, 35 52, 35 53, 35 54, 35 55, 35 56, 35 57, 35 58, 35 59, 35 60, 35 61, 35 62, 35 63, 35 64, 35 65, 35 66, 35 67, 35 68, 35 69, 35 70, 35 71, 35 72, 35 73, 35 74, 35 75, 35 76, 35 77, 35 78, 35 79, 35 80, 35 81, 35 82, 35 83, 35 84, 35 85, 35 86, 35 87, 35 88, 35 89, 35 90, 35 91, 35 92, 35 93, 35 94, 35 95, 35 96, 35 97, 35 98, 35 99, 36 37, 36 38, 36 39, 36 40, 36 41, 36 42, 36 43, 36 44, 36 45, 36 46, 36 47, 36 48, 36 49, 36 50, 36 51, 36 52, 36 53, 36 54, 36 55, 36 56, 36 57, 36 58, 36 59, 36 60, 36 61, 36 62, 36 63, 36 64, 36 65, 36 66, 36 67, 36 68, 36 69, 36 70, 36 71, 36 72, 36 73, 36 74, 36 75, 36 76, 36 77, 36 78, 36 79, 36 80, 36 81, 36 82, 36 83, 36 84, 36 85, 36 86, 36 87, 36 88, 36 89, 36 90, 36 91, 36 92, 36 93, 36 94, 36 95, 36 96, 36 97, 36 98, 36 99, 37 38, 37 39, 37 40, 37 41, 37 42, 37 43, 37 44, 37 45, 37 46, 37 47, 37 48, 37 49, 37 50, 37 51, 37 52, 37 53, 37 54, 37 55, 37 56, 37 57, 37 58, 37 59, 37 60, 37 61, 37 62, 37 63, 37 64, 37 65, 37 66, 37 67, 37 68, 37 69, 37 70, 37 71, 37 72, 37 73, 37 74, 37 75, 37 76, 37 77, 37 78, 37 79, 37 80, 37 81, 37 82, 37 83, 37 84, 37 85, 37 86, 37 87, 37 88, 37 89, 37 90, 37 91, 37 92, 37 93, 37 94, 37 95, 37 96, 37 97, 37 98, 37 99, 38 39, 38 40, 38 41, 38 42, 38 43, 38 44, 38 45, 38 46, 38 47, 38 48, 38 49, 38 50, 38 51, 38 52, 38 53, 38 54, 38 55, 38 56, 38 57, 38 58, 38 59, 38 60, 38 61, 38 62, 38 63, 38 64, 38 65, 38 66, 38 67, 38 68, 38 69, 38 70, 38 71, 38 72, 38 73, 38 74, 38 75, 38 76, 38 77, 38 78, 38 79, 38 80, 38 81, 38 82, 38 83, 38 84, 38 85, 38 86, 38 87, 38 88, 38 89, 38 90, 38 91, 38 92, 38 93, 38 94, 38 95, 38 96, 38 97, 38 98, 38 99, 39 40, 39 41, 39 42, 39 43, 39 44, 39 45, 39 46, 39 47, 39 48, 39 49, 39 50, 39 51, 39 52, 39 53, 39 54, 39 55, 39 56, 39 57, 39 58, 39 59, 39 60, 39 61, 39 62, 39 63, 39 64, 39 65, 39 66, 39 67, 39 68, 39 69, 39 70, 39 71, 39 72, 39 73, 39 74, 39 75, 39 76, 39 77, 39 78, 39 79, 39 80, 39 81, 39 82, 39 83, 39 84, 39 85, 39 86, 39 87, 39 88, 39 89, 39 90, 39 91, 39 92, 39 93, 39 94, 39 95, 39 96, 39 97, 39 98, 39 99, 40 41, 40 42, 40 43, 40 44, 40 45, 40 46, 40 47, 40 48, 40 49, 40 50, 40 51, 40 52, 40 53, 40 54, 40 55, 40 56, 40 57, 40 58, 40 59, 40 60, 40 61, 40 62, 40 63, 40 64, 40 65, 40 66, 40 67, 40 68, 40 69, 40 70, 40 71, 40 72, 40 73, 40 74, 40 75, 40 76, 40 77, 40 78, 40 79, 40 80, 40 81, 40 82, 40 83, 40 84, 40 85, 40 86, 40 87, 40 88, 40 89, 40 90, 40 91, 40 92, 40 93, 40 94, 40 95, 40 96, 40 97, 40 98, 40 99, 41 42, 41 43, 41 44, 41 45, 41 46, 41 47, 41 48, 41 49, 41 50, 41 51, 41 52, 41 53, 41 54, 41 55, 41 56, 41 57, 41 58, 41 59, 41 60, 41 61, 41 62, 41 63, 41 64, 41 65, 41 66, 41 67, 41 68, 41 69, 41 70, 41 71, 41 72, 41 73, 41 74, 41 75, 41 76, 41 77, 41 78, 41 79, 41 80, 41 81, 41 82, 41 83, 41 84, 41 85, 41 86, 41 87, 41 88, 41 89, 41 90, 41 91, 41 92, 41 93, 41 94, 41 95, 41 96, 41 97, 41 98, 41 99, 42 43, 42 44, 42 45, 42 46, 42 47, 42 48, 42 49, 42 50, 42 51, 42 52, 42 53, 42 54, 42 55, 42 56, 42 57, 42 58, 42 59, 42 60, 42 61, 42 62, 42 63, 42 64, 42 65, 42 66, 42 67, 42 68, 42 69, 42 70, 42 71, 42 72, 42 73, 42 74, 42 75, 42 76, 42 77, 42 78, 42 79, 42 80, 42 81, 42 82, 42 83, 42 84, 42 85, 42 86, 42 87, 42 88, 42 89, 42 90, 42 91, 42 92, 42 93, 42 94, 42 95, 42 96, 42 97, 42 98, 42 99, 43 44, 43 45, 43 46, 43 47, 43 48, 43 49, 43 50, 43 51, 43 52, 43 53, 43 54, 43 55, 43 56, 43 57, 43 58, 43 59, 43 60, 43 61, 43 62, 43 63, 43 64, 43 65, 43 66, 43 67, 43 68, 43 69, 43 70, 43 71, 43 72, 43 73, 43 74, 43 75, 43 76, 43 77, 43 78, 43 79, 43 80, 43 81, 43 82, 43 83, 43 84, 43 85, 43 86, 43 87, 43 88, 43 89, 43 90, 43 91, 43 92, 43 93, 43 94, 43 95, 43 96, 43 97, 43 98, 43 99, 44 45, 44 46, 44 47, 44 48, 44 49, 44 50, 44 51, 44 52, 44 53, 44 54, 44 55, 44 56, 44 57, 44 58, 44 59, 44 60, 44 61, 44 62, 44 63, 44 64, 44 65, 44 66, 44 67, 44 68, 44 69, 44 70, 44 71, 44 72, 44 73, 44 74, 44 75, 44 76, 44 77, 44 78, 44 79, 44 80, 44 81, 44 82, 44 83, 44 84, 44 85, 44 86, 44 87, 44 88, 44 89, 44 90, 44 91, 44 92, 44 93, 44 94, 44 95, 44 96, 44 97, 44 98, 44 99, 45 46, 45 47, 45 48, 45 49, 45 50, 45 51, 45 52, 45 53, 45 54, 45 55, 45 56, 45 57, 45 58, 45 59, 45 60, 45 61, 45 62, 45 63, 45 64, 45 65, 45 66, 45 67, 45 68, 45 69, 45 70, 45 71, 45 72, 45 73, 45 74, 45 75, 45 76, 45 77, 45 78, 45 79, 45 80, 45 81, 45 82, 45 83, 45 84, 45 85, 45 86, 45 87, 45 88, 45 89, 45 90, 45 91, 45 92, 45 93, 45 94, 45 95, 45 96, 45 97, 45 98, 45 99, 46 47, 46 48, 46 49, 46 50, 46 51, 46 52, 46 53, 46 54, 46 55, 46 56, 46 57, 46 58, 46 59, 46 60, 46 61, 46 62, 46 63, 46 64, 46 65, 46 66, 46 67, 46 68, 46 69, 46 70, 46 71, 46 72, 46 73, 46 74, 46 75, 46 76, 46 77, 46 78, 46 79, 46 80, 46 81, 46 82, 46 83, 46 84, 46 85, 46 86, 46 87, 46 88, 46 89, 46 90, 46 91, 46 92, 46 93, 46 94, 46 95, 46 96, 46 97, 46 98, 46 99, 47 48, 47 49, 47 50, 47 51, 47 52, 47 53, 47 54, 47 55, 47 56, 47 57, 47 58, 47 59, 47 60, 47 61, 47 62, 47 63, 47 64, 47 65, 47 66, 47 67, 47 68, 47 69, 47 70, 47 71, 47 72, 47 73, 47 74, 47 75, 47 76, 47 77, 47 78, 47 79, 47 80, 47 81, 47 82, 47 83, 47 84, 47 85, 47 86, 47 87, 47 88, 47 89, 47 90, 47 91, 47 92, 47 93, 47 94, 47 95, 47 96, 47 97, 47 98, 47 99, 48 49, 48 50, 48 51, 48 52, 48 53, 48 54, 48 55, 48 56, 48 57, 48 58, 48 59, 48 60, 48 61, 48 62, 48 63, 48 64, 48 65, 48 66, 48 67, 48 68, 48 69, 48 70, 48 71, 48 72, 48 73, 48 74, 48 75, 48 76, 48 77, 48 78, 48 79, 48 80, 48 81, 48 82, 48 83, 48 84, 48 85, 48 86, 48 87, 48 88, 48 89, 48 90, 48 91, 48 92, 48 93, 48 94, 48 95, 48 96, 48 97, 48 98, 48 99, 49 50, 49 51, 49 52, 49 53, 49 54, 49 55, 49 56, 49 57, 49 58, 49 59, 49 60, 49 61, 49 62, 49 63, 49 64, 49 65, 49 66, 49 67, 49 68, 49 69, 49 70, 49 71, 49 72, 49 73, 49 74, 49 75, 49 76, 49 77, 49 78, 49 79, 49 80, 49 81, 49 82, 49 83, 49 84, 49 85, 49 86, 49 87, 49 88, 49 89, 49 90, 49 91, 49 92, 49 93, 49 94, 49 95, 49 96, 49 97, 49 98, 49 99, 50 51, 50 52, 50 53, 50 54, 50 55, 50 56, 50 57, 50 58, 50 59, 50 60, 50 61, 50 62, 50 63, 50 64, 50 65, 50 66, 50 67, 50 68, 50 69, 50 70, 50 71, 50 72, 50 73, 50 74, 50 75, 50 76, 50 77, 50 78, 50 79, 50 80, 50 81, 50 82, 50 83, 50 84, 50 85, 50 86, 50 87, 50 88, 50 89, 50 90, 50 91, 50 92, 50 93, 50 94, 50 95, 50 96, 50 97, 50 98, 50 99, 51 52, 51 53, 51 54, 51 55, 51 56, 51 57, 51 58, 51 59, 51 60, 51 61, 51 62, 51 63, 51 64, 51 65, 51 66, 51 67, 51 68, 51 69, 51 70, 51 71, 51 72, 51 73, 51 74, 51 75, 51 76, 51 77, 51 78, 51 79, 51 80, 51 81, 51 82, 51 83, 51 84, 51 85, 51 86, 51 87, 51 88, 51 89, 51 90, 51 91, 51 92, 51 93, 51 94, 51 95, 51 96, 51 97, 51 98, 51 99, 52 53, 52 54, 52 55, 52 56, 52 57, 52 58, 52 59, 52 60, 52 61, 52 62, 52 63, 52 64, 52 65, 52 66, 52 67, 52 68, 52 69, 52 70, 52 71, 52 72, 52 73, 52 74, 52 75, 52 76, 52 77, 52 78, 52 79, 52 80, 52 81, 52 82, 52 83, 52 84, 52 85, 52 86, 52 87, 52 88, 52 89, 52 90, 52 91, 52 92, 52 93, 52 94, 52 95, 52 96, 52 97, 52 98, 52 99, 53 54, 53 55, 53 56, 53 57, 53 58, 53 59, 53 60, 53 61, 53 62, 53 63, 53 64, 53 65, 53 66, 53 67, 53 68, 53 69, 53 70, 53 71, 53 72, 53 73, 53 74, 53 75, 53 76, 53 77, 53 78, 53 79, 53 80, 53 81, 53 82, 53 83, 53 84, 53 85, 53 86, 53 87, 53 88, 53 89, 53 90, 53 91, 53 92, 53 93, 53 94, 53 95, 53 96, 53 97, 53 98, 53 99, 54 55, 54 56, 54 57, 54 58, 54 59, 54 60, 54 61, 54 62, 54 63, 54 64, 54 65, 54 66, 54 67, 54 68, 54 69, 54 70, 54 71, 54 72, 54 73, 54 74, 54 75, 54 76, 54 77, 54 78, 54 79, 54 80, 54 81, 54 82, 54 83, 54 84, 54 85, 54 86, 54 87, 54 88, 54 89, 54 90, 54 91, 54 92, 54 93, 54 94, 54 95, 54 96, 54 97, 54 98, 54 99, 55 56, 55 57, 55 58, 55 59, 55 60, 55 61, 55 62, 55 63, 55 64, 55 65, 55 66, 55 67, 55 68, 55 69, 55 70, 55 71, 55 72, 55 73, 55 74, 55 75, 55 76, 55 77, 55 78, 55 79, 55 80, 55 81, 55 82, 55 83, 55 84, 55 85, 55 86, 55 87, 55 88, 55 89, 55 90, 55 91, 55 92, 55 93, 55 94, 55 95, 55 96, 55 97, 55 98, 55 99, 56 57, 56 58, 56 59, 56 60, 56 61, 56 62, 56 63, 56 64, 56 65, 56 66, 56 67, 56 68, 56 69, 56 70, 56 71, 56 72, 56 73, 56 74, 56 75, 56 76, 56 77, 56 78, 56 79, 56 80, 56 81, 56 82, 56 83, 56 84, 56 85, 56 86, 56 87, 56 88, 56 89, 56 90, 56 91, 56 92, 56 93, 56 94, 56 95, 56 96, 56 97, 56 98, 56 99, 57 58, 57 59, 57 60, 57 61, 57 62, 57 63, 57 64, 57 65, 57 66, 57 67, 57 68, 57 69, 57 70, 57 71, 57 72, 57 73, 57 74, 57 75, 57 76, 57 77, 57 78, 57 79, 57 80, 57 81, 57 82, 57 83, 57 84, 57 85, 57 86, 57 87, 57 88, 57 89, 57 90, 57 91, 57 92, 57 93, 57 94, 57 95, 57 96, 57 97, 57 98, 57 99, 58 59, 58 60, 58 61, 58 62, 58 63, 58 64, 58 65, 58 66, 58 67, 58 68, 58 69, 58 70, 58 71, 58 72, 58 73, 58 74, 58 75, 58 76, 58 77, 58 78, 58 79, 58 80, 58 81, 58 82, 58 83, 58 84, 58 85, 58 86, 58 87, 58 88, 58 89, 58 90, 58 91, 58 92, 58 93, 58 94, 58 95, 58 96, 58 97, 58 98, 58 99, 59 60, 59 61, 59 62, 59 63, 59 64, 59 65, 59 66, 59 67, 59 68, 59 69, 59 70, 59 71, 59 72, 59 73, 59 74, 59 75, 59 76, 59 77, 59 78, 59 79, 59 80, 59 81, 59 82, 59 83, 59 84, 59 85, 59 86, 59 87, 59 88, 59 89, 59 90, 59 91, 59 92, 59 93, 59 94, 59 95, 59 96, 59 97, 59 98, 59 99, 60 61, 60 62, 60 63, 60 64, 60 65, 60 66, 60 67, 60 68, 60 69, 60 70, 60 71, 60 72, 60 73, 60 74, 60 75, 60 76, 60 77, 60 78, 60 79, 60 80, 60 81, 60 82, 60 83, 60 84, 60 85, 60 86, 60 87, 60 88, 60 89, 60 90, 60 91, 60 92, 60 93, 60 94, 60 95, 60 96, 60 97, 60 98, 60 99, 61 62, 61 63, 61 64, 61 65, 61 66, 61 67, 61 68, 61 69, 61 70, 61 71, 61 72, 61 73, 61 74, 61 75, 61 76, 61 77, 61 78, 61 79, 61 80, 61 81, 61 82, 61 83, 61 84, 61 85, 61 86, 61 87, 61 88, 61 89, 61 90, 61 91, 61 92, 61 93, 61 94, 61 95, 61 96, 61 97, 61 98, 61 99, 62 63, 62 64, 62 65, 62 66, 62 67, 62 68, 62 69, 62 70, 62 71, 62 72, 62 73, 62 74, 62 75, 62 76, 62 77, 62 78, 62 79, 62 80, 62 81, 62 82, 62 83, 62 84, 62 85, 62 86, 62 87, 62 88, 62 89, 62 90, 62 91, 62 92, 62 93, 62 94, 62 95, 62 96, 62 97, 62 98, 62 99, 63 64, 63 65, 63 66, 63 67, 63 68, 63 69, 63 70, 63 71, 63 72, 63 73, 63 74, 63 75, 63 76, 63 77, 63 78, 63 79, 63 80, 63 81, 63 82, 63 83, 63 84, 63 85, 63 86, 63 87, 63 88, 63 89, 63 90, 63 91, 63 92, 63 93, 63 94, 63 95, 63 96, 63 97, 63 98, 63 99, 64 65, 64 66, 64 67, 64 68, 64 69, 64 70, 64 71, 64 72, 64 73, 64 74, 64 75, 64 76, 64 77, 64 78, 64 79, 64 80, 64 81, 64 82, 64 83, 64 84, 64 85, 64 86, 64 87, 64 88, 64 89, 64 90, 64 91, 64 92, 64 93, 64 94, 64 95, 64 96, 64 97, 64 98, 64 99, 65 66, 65 67, 65 68, 65 69, 65 70, 65 71, 65 72, 65 73, 65 74, 65 75, 65 76, 65 77, 65 78, 65 79, 65 80, 65 81, 65 82, 65 83, 65 84, 65 85, 65 86, 65 87, 65 88, 65 89, 65 90, 65 91, 65 92, 65 93, 65 94, 65 95, 65 96, 65 97, 65 98, 65 99, 66 67, 66 68, 66 69, 66 70, 66 71, 66 72, 66 73, 66 74, 66 75, 66 76, 66 77, 66 78, 66 79, 66 80, 66 81, 66 82, 66 83, 66 84, 66 85, 66 86, 66 87, 66 88, 66 89, 66 90, 66 91, 66 92, 66 93, 66 94, 66 95, 66 96, 66 97, 66 98, 66 99, 67 68, 67 69, 67 70, 67 71, 67 72, 67 73, 67 74, 67 75, 67 76, 67 77, 67 78, 67 79, 67 80, 67 81, 67 82, 67 83, 67 84, 67 85, 67 86, 67 87, 67 88, 67 89, 67 90, 67 91, 67 92, 67 93, 67 94, 67 95, 67 96, 67 97, 67 98, 67 99, 68 69, 68 70, 68 71, 68 72, 68 73, 68 74, 68 75, 68 76, 68 77, 68 78, 68 79, 68 80, 68 81, 68 82, 68 83, 68 84, 68 85, 68 86, 68 87, 68 88, 68 89, 68 90, 68 91, 68 92, 68 93, 68 94, 68 95, 68 96, 68 97, 68 98, 68 99, 69 70, 69 71, 69 72, 69 73, 69 74, 69 75, 69 76, 69 77, 69 78, 69 79, 69 80, 69 81, 69 82, 69 83, 69 84, 69 85, 69 86, 69 87, 69 88, 69 89, 69 90, 69 91, 69 92, 69 93, 69 94, 69 95, 69 96, 69 97, 69 98, 69 99, 70 71, 70 72, 70 73, 70 74, 70 75, 70 76, 70 77, 70 78, 70 79, 70 80, 70 81, 70 82, 70 83, 70 84, 70 85, 70 86, 70 87, 70 88, 70 89, 70 90, 70 91, 70 92, 70 93, 70 94, 70 95, 70 96, 70 97, 70 98, 70 99, 71 72, 71 73, 71 74, 71 75, 71 76, 71 77, 71 78, 71 79, 71 80, 71 81, 71 82, 71 83, 71 84, 71 85, 71 86, 71 87, 71 88, 71 89, 71 90, 71 91, 71 92, 71 93, 71 94, 71 95, 71 96, 71 97, 71 98, 71 99, 72 73, 72 74, 72 75, 72 76, 72 77, 72 78, 72 79, 72 80, 72 81, 72 82, 72 83, 72 84, 72 85, 72 86, 72 87, 72 88, 72 89, 72 90, 72 91, 72 92, 72 93, 72 94, 72 95, 72 96, 72 97, 72 98, 72 99, 73 74, 73 75, 73 76, 73 77, 73 78, 73 79, 73 80, 73 81, 73 82, 73 83, 73 84, 73 85, 73 86, 73 87, 73 88, 73 89, 73 90, 73 91, 73 92, 73 93, 73 94, 73 95, 73 96, 73 97, 73 98, 73 99, 74 75, 74 76, 74 77, 74 78, 74 79, 74 80, 74 81, 74 82, 74 83, 74 84, 74 85, 74 86, 74 87, 74 88, 74 89, 74 90, 74 91, 74 92, 74 93, 74 94, 74 95, 74 96, 74 97, 74 98, 74 99, 75 76, 75 77, 75 78, 75 79, 75 80, 75 81, 75 82, 75 83, 75 84, 75 85, 75 86, 75 87, 75 88, 75 89, 75 90, 75 91, 75 92, 75 93, 75 94, 75 95, 75 96, 75 97, 75 98, 75 99, 76 77, 76 78, 76 79, 76 80, 76 81, 76 82, 76 83, 76 84, 76 85, 76 86, 76 87, 76 88, 76 89, 76 90, 76 91, 76 92, 76 93, 76 94, 76 95, 76 96, 76 97, 76 98, 76 99, 77 78, 77 79, 77 80, 77 81, 77 82, 77 83, 77 84, 77 85, 77 86, 77 87, 77 88, 77 89, 77 90, 77 91, 77 92, 77 93, 77 94, 77 95, 77 96, 77 97, 77 98, 77 99, 78 79, 78 80, 78 81, 78 82, 78 83, 78 84, 78 85, 78 86, 78 87, 78 88, 78 89, 78 90, 78 91, 78 92, 78 93, 78 94, 78 95, 78 96, 78 97, 78 98, 78 99, 79 80, 79 81, 79 82, 79 83, 79 84, 79 85, 79 86, 79 87, 79 88, 79 89, 79 90, 79 91, 79 92, 79 93, 79 94, 79 95, 79 96, 79 97, 79 98, 79 99, 80 81, 80 82, 80 83, 80 84, 80 85, 80 86, 80 87, 80 88, 80 89, 80 90, 80 91, 80 92, 80 93, 80 94, 80 95, 80 96, 80 97, 80 98, 80 99, 81 82, 81 83, 81 84, 81 85, 81 86, 81 87, 81 88, 81 89, 81 90, 81 91, 81 92, 81 93, 81 94, 81 95, 81 96, 81 97, 81 98, 81 99, 82 83, 82 84, 82 85, 82 86, 82 87, 82 88, 82 89, 82 90, 82 91, 82 92, 82 93, 82 94, 82 95, 82 96, 82 97, 82 98, 82 99, 83 84, 83 85, 83 86, 83 87, 83 88, 83 89, 83 90, 83 91, 83 92, 83 93, 83 94, 83 95, 83 96, 83 97, 83 98, 83 99, 84 85, 84 86, 84 87, 84 88, 84 89, 84 90, 84 91, 84 92, 84 93, 84 94, 84 95, 84 96, 84 97, 84 98, 84 99, 85 86, 85 87, 85 88, 85 89, 85 90, 85 91, 85 92, 85 93, 85 94, 85 95, 85 96, 85 97, 85 98, 85 99, 86 87, 86 88, 86 89, 86 90, 86 91, 86 92, 86 93, 86 94, 86 95, 86 96, 86 97, 86 98, 86 99, 87 88, 87 89, 87 90, 87 91, 87 92, 87 93, 87 94, 87 95, 87 96, 87 97, 87 98, 87 99, 88 89, 88 90, 88 91, 88 92, 88 93, 88 94, 88 95, 88 96, 88 97, 88 98, 88 99, 89 90, 89 91, 89 92, 89 93, 89 94, 89 95, 89 96, 89 97, 89 98, 89 99, 90 91, 90 92, 90 93, 90 94, 90 95, 90 96, 90 97, 90 98, 90 99, 91 92, 91 93, 91 94, 91 95, 91 96, 91 97, 91 98, 91 99, 92 93, 92 94, 92 95, 92 96, 92 97, 92 98, 92 99, 93 94, 93 95, 93 96, 93 97, 93 98, 93 99, 94 95, 94 96, 94 97, 94 98, 94 99, 95 96, 95 97, 95 98, 95 99, 96 97, 96 98, 96 99, 97 98, 97 99, 98 99

###ExÃ©cution du test :###

```bash
cd ex06
./test/test.sh
```

-------------------------------------------------
## 0.0.7) ex07: ft_putnbr
-------------------------------------------------

###Le but :###
Afficher un nombre entier (int) en toutes circonstances (positif, nÃ©gatif, 0, INT_MIN).

###Structure recommandÃ©e###

```bash
ex07/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ ft_putnbr.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ ft_putnbr.c
â”‚   â””â”€â”€ ft_putchar.c
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ expected.txt
â”‚   â””â”€â”€ test.sh
â””â”€â”€ Makefile
```

###Prototype :###

```c
void ft_putnbr(int nb);
```

###Explication :###
On vÃ©rifie si le nombre est nÃ©gatif. Si oui, on affiche '-' et on inverse le signe (attention Ã 
INT_MIN).
Ensuite, on utilise une fonction rÃ©cursive :
Si le nombre est supÃ©rieur ou Ã©gal Ã  10, on appelle ft_putnbr(nb / 10), puis on affiche le chiffre des unitÃ©s: (nb % 10 + '0')et affichÃ© avec write.

###Interdictions :###
- Pas de printf
- write uniquement

###Bulle d'ami :###
"Un nombre est juste une succession de chiffres Ã  dÃ©rouler."

###Mini-TDD :###
CrÃ©er un main() de test pour afficher les valeurs suivantes avec ft_putnbr() :

>42
>-42
>0
>-2147483648

###TDD :###
Fichier de test : test/main.c

```c
#include "../include/ft_putnbr.h"

int main(void)
{
  ft_putnbr(83);
  ft_putchar('\n');
  ft_putnbr(-83);
  ft_putchar('\n');
  ft_putnbr(0);
  ft_putchar('\n');
  ft_putnbr(-2147483648);
  ft_putchar('\n');
  return 0;
}
```

Fichier : test.sh
```sh
diff test/output.txt test/expected.txt && echo "OK" || echo "FAIL" (Ã  tester)
```

```sh
#!/bin/bash

# Compilation
gcc -Wall -Wextra -Werror -Iinclude src/*.c test/main.c -o ex07_test

# ExÃ©cution + redirection de sortie
./../ex07_test > test/output.txt

# Comparaison
diff test/output.txt test/expected.txt > /dev/null

if [ $? -eq 0 ]; then
  echo "ex07: Test rÃ©ussi"
else
  echo "ex07: Erreur - La sortie ne correspond pas Ã  expected.txt"
fi

# Nettoyage
rm -f ex07_test test/output.txt
```

Fichier : expected.txt

>83
>-83
>0
>-2147483648

Fichier : Makefile

```Makefile
SRC_ex07 = ft_putnbr ft_putchar

define compile_exercise
	@echo "Compiling $1..."
	$(CC) $(CFLAGS\) -I$1/include $(addprefix $1/src/, $(SRC_$1:=.c)) $1/test/main.c -o $1_test
endef
```

###Pour tester :###

```bash
cd ex07
./test/test.sh
```

###RÃ©sumÃ© TDD :###
Ã‰tape Action
1ï¸. Ã‰cris main.c pour tester 4 cas
2ï¸. CrÃ©e expected.txt
3ï¸. ImplÃ©mente ft_putnbr.c
4ï¸. Lance test.sh pour valider

-------------------------------------------------
## 0.0.8) ex08: ft_print_combn
-------------------------------------------------

###Le but :###
Afficher toutes les combinaisons possibles de n chiffres diffÃ©rents croissants.

###Prototype :###

```c
void ft_print_combn(int n);
```

###Explication :###
CrÃ©er un tableau de n chiffres allant de 0 Ã  9, en respectant l'ordre strictement croissant.
IncrÃ©menter la combinaison actuelle tant que la derniÃ¨re position nâ€™a pas atteint sa limite.
Ã€ chaque affichage :
Pour n = 1 on affiche chaque chiffre 0, 1, ..., 9, .
On ajoute ", " sauf pour la derniÃ¨re combinaison (n chiffres allant de 10 - n Ã  9).

Par exemple :
>pour n = 2, on affiche 01, 02, ..., 89.
>pour n = 3, on affiche 012, 013, ..., 789.
>Le cas n = 9 donne 012345678.

###Interdictions :###
- Pas de printf
- write uniquement

###Bulle d'ami :###
"Chaque choix ouvre la porte au suivant, comme un escalier numÃ©rique."

###Mini-TDD :###
CrÃ©er un test qui appelle ft_print_combn() avec 
>n = 1 â†’ 0, 1, ..., 9
>n = 2 â†’ 01, 02, ..., 89
>n = 3 â†’ 012, ..., 789
>n = 4 â†’ 0123, ..., 6789
>n = 9 â†’ 012345678
et compare les sorties avec les rÃ©sultats attendus.
Utilise diff avec un fichier expected.txt gÃ©nÃ©rÃ© manuellement ou par script.

Fichier de test : test/main.c

```c
#include "../include/ft_print_combn.h"

int main(void)
{
  ft_print_combn(2);
  ft_putchar('\n');
  ft_print_combn(3);
  ft_putchar('\n');
  ft_print_combn(1);
  ft_putchar('\n');
  ft_print_combn(4);
  ft_putchar('\n');
  ft_print_combn(9);
  ft_putchar('\n');
  return 0;
}
```

Fichier attendu : test/expected.txt

```txt
01, 02, 03, ..., 89
012, 013, ..., 789
0, 1, ..., 9
0123, 0124, ..., 6789
012345678
```
-------------------------------------------------
#Module 1 â€” preprocessor/ â€” Fondamentaux du PrÃ©processeur C#
-------------------------------------------------

Module preprocessor/ â€” Fondamentaux du PrÃ©processeur [ğŸ”§ Niveau Facile Ã  Moyen]

Objectif pÃ©dagogique
Le prÃ©processeur C est la toute premiÃ¨re Ã©tape du processus de compilation. Il agit **avant mÃªme que le compilateur ne voie ton code** : il le **modifie**, le **rÃ©Ã©crit** ou le **masque** selon des rÃ¨gles dÃ©finies.

Ce module va t'apprendre Ã  :

- CrÃ©er des macros simples et avancÃ©es  
- Utiliser des inclusions conditionnelles (`#ifdef`, `#ifndef`)  
- Exploiter les macros spÃ©ciales comme `__FILE__`, `__LINE__`, etc.  
- Comprendre la **portabilitÃ©** du code via les directives de compilation  
- Ã‰viter les **piÃ¨ges classiques** liÃ©s Ã  des macros mal conÃ§ues

---

Outils utilisÃ©s

- `gcc -E` : affiche le code *prÃ©processeur* gÃ©nÃ©rÃ© (avant compilation rÃ©elle)
- `gcc -DDEBUG` : permet de dÃ©finir une macro Ã  la compilation
- `man cpp` : le manuel de rÃ©fÃ©rence du prÃ©processeur C
- Aucune bibliothÃ¨que externe requise
- Utilisation stricte de `write()` (pas de `printf`)

---

Concepts abordÃ©s

1. Macros de substitution

```c
#define PI 3.14159
#define HELLO "Bonjour le monde !"
Les macros agissent comme un copier-coller aveugle dans le code.
Quand le compilateur voit PI, il remplace littÃ©ralement par 3.14159.

Astuce :

Pas de point-virgule (;) Ã  la fin dâ€™une macro !

Ce ne sont pas des variables, et nâ€™occupent aucune mÃ©moire.

2. Macros avec arguments
```c
#define SQUARE(x) ((x) * (x))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
```

Toujours protÃ©ger les arguments avec des parenthÃ¨ses, sinon :

```c
#define BAD(x) x * x
int r = BAD(1+2); // devient => 1 + 2 * 1 + 2 = 5 au lieu de 9 âŒ
```

Ce piÃ¨ge est cÃ©lÃ¨bre. Il permet de comprendre que le prÃ©processeur ne comprend pas les prioritÃ©s arithmÃ©tiques. Il fait un simple remplacement texte.

3. Inclusion conditionnelle

```c
#ifdef DEBUG
    write(1, "Mode debug activÃ©\n", 18);
#endif
```

Cette directive permet dâ€™exÃ©cuter un bloc uniquement si une macro est dÃ©finie.
TrÃ¨s utilisÃ© pour :
DÃ©sactiver des logs dans le binaire final
SÃ©parer du code spÃ©cifique Ã  une plateforme
CrÃ©er du code modulaire sans duplication

4. Inclusion unique (header guard)

```c
#ifndef MON_HEADER_H
#define MON_HEADER_H

// contenu...

#endif
```

Sans cette protection, un #include multiple du mÃªme fichier pourrait provoquer des doublons de dÃ©finition, donc une erreur de compilation.
RÃ¨gle pro : TOUS tes headers doivent Ãªtre protÃ©gÃ©s. Toujours. Sans exception.

5. Macros spÃ©ciales
Ces macros sont automatiquement remplacÃ©es par des informations du contexte de compilation :

__FILE__ â†’ nom du fichier courant
__LINE__ â†’ numÃ©ro de ligne actuel
__DATE__ â†’ date de compilation
__TIME__ â†’ heure de compilation

Astuce bonus :

```c
#define TRACE write(1, __FILE__ ":" __DATE__ "\n", sizeof(__FILE__ ":" __DATE__ "\n") - 1)
```

Exercices
- preprocessor/ex00 â€” Macro SQUARE(x)
- Objectif : CrÃ©er une macro qui retourne le carrÃ© dâ€™un entier.
- But pÃ©dagogique : Comprendre les effets de bord, les parenthÃ¨ses obligatoires.

```c
#define SQUARE(x) ((x) * (x))
```

Ã€ tester :

SQUARE(4) â†’ 16

SQUARE(1+2) â†’ âœ… ((1+2)*(1+2)) = 9

BAD(1+2) â†’ âŒ (voir piÃ¨ge ci-dessus)

Conseil : ajoute un fichier test.sh avec redirection > logs/output.txt
Nâ€™oublie pas que tu ne peux pas utiliser printf, alors remplace-le par write() + ft_putnbr().

preprocessor/ex01 â€” Afficher les mÃ©tadonnÃ©es
Objectif : Afficher __FILE__, __LINE__, __DATE__, __TIME__

```c
#include <unistd.h>

void  ft_putnbr(int nb);
void  ft_putstr(char *str);

int main(void)
{
  ft_putstr("Fichier : ");
  ft_putstr(__FILE__); write(1, "\n", 1);

  ft_putstr("Ligne   : ");
  ft_putnbr(__LINE__); write(1, "\n", 1);

  ft_putstr("Date    : ");
  ft_putstr(__DATE__); write(1, "\n", 1);

  ft_putstr("Heure   : ");
  ft_putstr(__TIME__); write(1, "\n", 1);

  return 0;
}
```

Tu peux crÃ©er ta propre lib libft_print/ pour ft_putstr() et ft_putnbr(), rÃ©utilisable dans tout le projet.

preprocessor/ex02 â€” Activer ou dÃ©sactiver le mode debug
Objectif : Utiliser #ifdef et -DDEBUG pour afficher un message


```c
#include <unistd.h>

int main(void) {
#ifdef DEBUG
    write(1, "Mode debug activÃ©\n", 18);
#else
    write(1, "Mode normal\n", 12);
#endif
    return 0;
}
```

Compilation :

```bash
gcc -DDEBUG ex02.c -o ex02_debug
gcc ex02.c -o ex02_nodebug
```

Conseil : compare les deux binaires avec diff <(./ex02_debug) <(./ex02_nodebug)

preprocessor/ex03 â€” Message au moment de la compilation
Objectif : Utiliser #pragma message

```c
#pragma message("Compilation en cours â€” attention au code !")

int main(void) {
    return 0;
}
```

Ce message nâ€™apparaÃ®t pas Ã  l'exÃ©cution, mais dans le terminal au moment du gcc.

UtilitÃ© :
Laisser un avertissement visuel au compilateur
Ã‰viter de commettre du code instable

Astuces bonus
Pour afficher le code gÃ©nÃ©rÃ© aprÃ¨s prÃ©traitement :

```bash
gcc -E mon_programme.c > preprocessed.c
```

Tu verras comment le compilateur voit ton code aprÃ¨s le passage du prÃ©processeur.
Exemple de fichier config.h global :

```c
#ifndef CONFIG_H
#define CONFIG_H

#define VERSION "1.0.0"
#define AUTHOR "Megnoux Xavier"
#define DEBUG_LEVEL 2

#endif
```

Tu peux inclure ce fichier dans tous tes projets pour avoir une signature claire.
Mini Makefile Ã  utiliser

```makefile
# Makefile
NAME = ex02
SRC = ex02.c

debug:
  @gcc -Wall -Wextra -Werror -DDEBUG $(SRC) -o $(NAME)_debug
  @./$(NAME)_debug

nodebug:
  @gcc -Wall -Wextra -Werror $(SRC) -o $(NAME)_nodebug
  @./$(NAME)_nodebug
```

Ã€ retenir :
Les macros ne sont pas des fonctions.

Le prÃ©processeur est aveugle :
il ne comprend pas la sÃ©mantique, juste le texte.
Il ne faut jamais faire confiance Ã  une macro sans parenthÃ¨ses.
Câ€™est un outil puissant pour la portabilitÃ©, la compilation conditionnelle et la gestion de la version.

Pourquoi câ€™est fondamental ?

Tu peux crÃ©er des logs temporaires sans polluer ton code final.
Tu protÃ¨ges tous tes headers.
Tu Ã©cris du code plus propre, plus modulaire, et plus rapide Ã  compiler.
Câ€™est le premier pas vers des outils comme cmake, autoconf, etc.

Prochaine Ã©tape :
On retourne dans la piscine avec lâ€™exercice ex09, en commenÃ§ant Ã  explorer les pointeurs, la mÃ©moire, et des choses plus profondes.

-------------------------------------------------
##0.0.9) ex09 â€” ft_ultimate_ft : 9 niveaux de rÃ©alitÃ© !
-------------------------------------------------
###Objectif :###
Comprendre et manipuler plusieurs niveaux de pointeurs (jusquâ€™Ã  9) pour accÃ©der Ã  une valeur finale et la modifier. Cet exercice est symbolique : il dÃ©montre que peu importe le nombre de couches dâ€™indirection, le principe reste identique.

###Prototype :###

```c
void ft_ultimate_ft(int *********nbr);
```

Explication mÃ©moire :
Un pointeur est une boÃ®te contenant lâ€™adresse dâ€™une autre boÃ®te.
Cet exercice imbrique 9 boÃ®tes jusquâ€™Ã  la valeur finale.

Niveau  Type  Contenu
val int 0
p1  int*  adresse de val
p2  int** adresse de p1
... ... ...
p9  int*********  adresse de p8

Et donc :

```c
*********nbr = 42;
```

Cela modifie bien val Ã  travers les 9 niveaux !

###Bulle dâ€™ami :###
"Chaque * est une loupe : elle permet de descendre dâ€™un niveau vers la rÃ©alitÃ©. Avec neuf loupes, tu peux toucher la vÃ©ritÃ©."

###Arborescence du projet :###

```bash
ex09/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ ft_ultimate_ft.h
â”‚   â”œâ”€â”€ ft_putnbr.h
â”‚   â””â”€â”€ ft_putstr.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ ft_ultimate_ft.c
â”‚   â”œâ”€â”€ ft_putnbr.c
â”‚   â””â”€â”€ ft_putstr.c
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ expected.txt
â”‚   â”œâ”€â”€ output.txt
â”‚   â””â”€â”€ test.sh
â””â”€â”€ Makefile
```

include/ft_ultimate_ft.h

```c
#ifndef FT_ULTIMATE_FT_H
# define FT_ULTIMATE_FT_H

void ft_ultimate_ft(int *********nbr);

#endif
```

src/ft_ultimate_ft.c

```c
#include "ft_ultimate_ft.h"

void ft_ultimate_ft(int *********nbr)
{
    *********nbr = 42;
}
```

include/ft_putnbr.h

```c
#ifndef FT_PUTNBR_H
# define FT_PUTNBR_H

void ft_putnbr(int nb);

#endif
```

src/ft_putnbr.c

```c
#include <unistd.h>
#include "ft_putnbr.h"

void ft_putchar(char c)
{
    write(1, &c, 1);
}

void ft_putnbr(int nb)
{
    if (nb == -2147483648)
    {
        write(1, "-2147483648", 11);
        return;
    }
    if (nb < 0)
    {
        ft_putchar('-');
        nb = -nb;
    }
    if (nb >= 10)
        ft_putnbr(nb / 10);
    ft_putchar(nb % 10 + '0');
}
```

include/ft_putstr.h

```c
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
```

src/ft_putstr.c

```c
#include <unistd.h>
#include "ft_putstr.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}
```

test/main.c

```c
#include "../include/ft_ultimate_ft.h"
#include "../include/ft_putnbr.h"
#include "../include/ft_putstr.h"
#include <unistd.h>

int main(void)
{
    int val = 0;
    int *p1 = &val;
    int **p2 = &p1;
    int ***p3 = &p2;
    int ****p4 = &p3;
    int *****p5 = &p4;
    int ******p6 = &p5;
    int *******p7 = &p6;
    int ********p8 = &p7;
    int *********p9 = &p8;

    ft_ultimate_ft(p9);

    ft_putstr("RÃ©sultat : ");
    ft_putnbr(val);
    write(1, "\n", 1); // RÃ©sultat attendu : 42

    return 0;
}
```

test/expected.txt

```txt
42
```

test/test.sh

```bash
#!/bin/bash

cd .. > /dev/null
make > /dev/null
./ex09 > test/output.txt

echo "RÃ©sultat attendu :"
cat test/expected.txt
echo "RÃ©sultat obtenu :"
cat test/output.txt
echo

diff test/output.txt test/expected.txt && echo "Test OK" || echo "Test FAIL"
```

###Makefile :###

```makefile
NAME = ex09
CC = gcc
CFLAGS = -Wall -Wextra -Werror
SRC = src/ft_ultimate_ft.c src/ft_putnbr.c src/ft_putstr.c test/main.c
INC = -Iinclude

all: $(NAME)

$(NAME):
  $(CC) $(CFLAGS) $(SRC) $(INC) -o $(NAME)

clean:
  rm -f $(NAME)
  rm -f test/output.txt

fclean: clean

re: fclean all
```

###Reverse Engineering :###

```bash
nm ex09 | grep ft_ultimate_ft
objdump -d ex09 | grep -A10 ft_ultimate_ft
```

Extrait ASM possible :

```asm
ft_ultimate_ft:
  mov    DWORD PTR [rdi], 0x2a    ; 42 en hexadÃ©cimal
  ret
```
Ã€ retenir
Concept DÃ©tail
Pointeurs imbriquÃ©s Chaque * descend dâ€™un niveau
AccÃ¨s par indirection Tu ne modifies pas la variable directement
Manipulation sÃ©curisÃ©e  Pas de cast, pas d'artifice
PuretÃ© C  Aucun outil non autorisÃ©
PÃ©dagogie mÃ©moire Tu explores la pile de maniÃ¨re symbolique

Bonus Universitaire â€” Pour aller plus loin
Ajoute un affichage des adresses mÃ©moire :

exemple avec stdio.h mai interdi donc ici, Ã  faire avec write()

```c
#include <stdio.h>

printf("Adresse de val : %p\n", (void *)&val);
printf("Adresse de p1  : %p\n", (void *)&p1);
printf("Adresse de p9  : %p\n", (void *)p9);
```

Et visualise le dÃ©routant mais magnifique labyrinthe de pointeurs.

Ce que tu apprends ici :
Base posÃ©e  Ce que tu sauras faire ensuite
Manipuler des structures imbriquÃ©es Structs, arbres, graphes
Passer des pointeurs Ã  des fonctions  Tri, swap, double pointeurs
Ne plus avoir peur des Ã©toiles *  MÃªme dans char ***argv
Travailler proprement Avec fichiers sÃ©parÃ©s, Makefile et tests

-------------------------------------------------
# Piscine BoostÃ©e - Bloc 1 (Partie 2/5) [ğŸŸ¢ Facile]
-------------------------------------------------
## 0.0.10) ft_swap â€” [ğŸŸ¢ Facile] Lâ€™art de lâ€™Ã©change mÃ©moire
-------------------------------------------------

###Objectif :###
Ã‰changer les **valeurs de deux entiers** passÃ©s par **adresse mÃ©moire** grÃ¢ce Ã  des pointeurs.

###Prototype :###

```c
void ft_swap(int *a, int *b);
```

###Explication pÃ©dagogique :###
Un pointeur (int *a) est une variable qui contient l'adresse mÃ©moire d'une autre variable.
Lorsque tu passes &x Ã  une fonction, tu transmets la rÃ©fÃ©rence de x.
Modifier *a dans la fonction revient Ã  modifier directement x dans la fonction appelante.

Ce mÃ©canisme est fondamental en C et sert dans :
les algorithmes de tri,
les structures de donnÃ©es,
la gestion dynamique de mÃ©moire.

###Interdictions :###

Interdit                                |Raison pÃ©dagogique
----------------------------------------|----------------------------
printf, scanf, stdlib.h, stdio.h        | Non autorisÃ©s en piscine
Cast de type (ex : (int) ou (void *))   | Hors contexte
Retour de valeur                        | Lâ€™effet doit Ãªtre visible par pointeur

Utilisation de plus dâ€™un tampon On tâ€™entraÃ®ne Ã  Ãªtre minimaliste et prÃ©cis

###Obligatoire :###
AutorisÃ©                                                     | Notes
-------------------------------------------------------------|----------------------------------------------------------
write(1, ...), ft_putchar, ft_putstr, ft_putnbr maison       | Pour l'affichage
Un seul int tmp;                                             | Pour stocker temporairement une valeur pendant lâ€™Ã©change
Pointeurs (*a, *b)                                           | Pour modifier directement la mÃ©moire

###Bulle dâ€™ami :###
"Un bon Ã©change commence toujours par cacher une des deux valeurs dans une boÃ®te temporaire."

###Visualisation mÃ©moire (avant/aprÃ¨s) :###
Avant :
  x = 5    y = 10

  &x â†’ 0x100 â†’ 5
  &y â†’ 0x104 â†’ 10

AprÃ¨s ft_swap(&x, &y) :
  x = 10   y = 5

####Arborescence du projet ex10/ :###

```bash
ex10/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ ft_swap.h
â”‚   â”œâ”€â”€ ft_putstr.h
â”‚   â”œâ”€â”€ ft_putnbr.h
â”‚   â””â”€â”€ ft_putchar.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ ft_swap.c
â”‚   â”œâ”€â”€ ft_putstr.c
â”‚   â”œâ”€â”€ ft_putnbr.c
â”‚   â””â”€â”€ ft_putchar.c
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ expected.txt
â”‚   â””â”€â”€ test.sh
â””â”€â”€ Makefile
```

include/ft_swap.h

```c
#ifndef FT_SWAP_H
# define FT_SWAP_H

void ft_swap(int *a, int *b);

#endif
```

src/ft_swap.c

```c
#include "ft_swap.h"

void ft_swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}
```

include/ft_putstr.h

```c
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
```

src/ft_putstr.c

```c
#include <unistd.h>
#include "ft_putstr.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}
```

include/ft_putchar.h

```c
#ifndef FT_PUTCHAR_H
# define FT_PUTCHAR_H

void ft_putchar(char c);

#endif
```

src/ft_putchar.c

```c
#include <unistd.h>
#include "ft_putchar.h"

void ft_putchar(char c)
{
    write(1, &c, 1);
}
```

include/ft_putnbr.h

```c
#ifndef FT_PUTNBR_H
# define FT_PUTNBR_H

void ft_putnbr(int nb);

#endif
```

src/ft_putnbr.c

```c
#include "ft_putchar.h"
#include "ft_putnbr.h"

void ft_putnbr(int nb)
{
    if (nb == -2147483648)
    {
        write(1, "-2147483648", 11);
        return;
    }
    if (nb < 0)
    {
        ft_putchar('-');
        nb = -nb;
    }
    if (nb >= 10)
        ft_putnbr(nb / 10);
    ft_putchar(nb % 10 + '0');
}
```

test/main.c

```c

#include "../include/ft_swap.h"
#include "../include/ft_putstr.h"
#include "../include/ft_putnbr.h"
#include <unistd.h>

int main(void)
{
    int a = 5;
    int b = 10;

    ft_swap(&a, &b);

    ft_putstr("a = ");
    ft_putnbr(a);
    ft_putstr(", b = ");
    ft_putnbr(b);
    write(1, "\n", 1); // RÃ©sultat attendu : a = 10, b = 5

    return 0;
}
```

test/expected.txt

```txt
a = 10, b = 5
```

test/test.sh

```bash
#!/bin/bash

cd .. > /dev/null
make > /dev/null
./ex10 > test/output.txt

echo "RÃ©sultat attendu :"
cat test/expected.txt
echo "RÃ©sultat obtenu :"
cat test/output.txt
echo

diff test/output.txt test/expected.txt && echo "Test OK" || echo "Test FAIL"
```

###Makefile :###

```makefile
NAME = ex10
CC = gcc
CFLAGS = -Wall -Wextra -Werror
SRC = src/ft_swap.c src/ft_putstr.c src/ft_putnbr.c src/ft_putchar.c test/main.c
INC = -Iinclude

all: $(NAME)

$(NAME):
  $(CC) $(CFLAGS) $(SRC) $(INC) -o $(NAME)

clean:
  rm -f $(NAME)

fclean: clean
  rm -f test/output.txt

re: fclean all
```

###Reverse Engineering :###

nm :

```bash
nm ex10 | grep ft_swap
```

objdump :

```bash
objdump -d ex10 | grep -A20 ft_swap
```

Exemple ASM probable (x86_64) :

```asm
ft_swap:
    mov eax, DWORD PTR [rdi]   ; charger *a dans eax
    mov edx, DWORD PTR [rsi]   ; charger *b dans edx
    mov DWORD PTR [rdi], edx   ; *a = b
    mov DWORD PTR [rsi], eax   ; *b = a
    ret
```

Ã€ retenir :

Fait                                       |Description
-------------------------------------------|----------------------------
Pointeurs maÃ®trisÃ©s                        | Passage dâ€™adresse = modification rÃ©elle
SÃ©curitÃ© mÃ©moire                           | Pas de fuite, pas de cast, pas de malloc
UtilitÃ© future                             | Base de tous les tris : bubble sort, quick sort
Minimalisme                                | Pas de dÃ©pendance, pas de return, pas de macro

###Bonus pour plus tard :###
CrÃ©er une fonction gÃ©nÃ©rique dâ€™Ã©change :

```c
void swap(void *a, void *b, size_t size)
{
    unsigned char tmp;
    for (size_t i = 0; i < size; i++)
    {
        tmp = ((unsigned char *)a)[i];
        ((unsigned char *)a)[i] = ((unsigned char *)b)[i];
        ((unsigned char *)b)[i] = tmp;
    }
}
```

Mais tu lâ€™utiliseras dans des algorithmes gÃ©nÃ©riques (tri, tableaux, structures) plus tard.

-------------------------------------------------
## 0.0.11) ft_div_mod â€” [ğŸŸ¢ Facile] Deux sorties pour une entrÃ©e
-------------------------------------------------

ğŸ¯ Objectif :
RÃ©aliser une division entiÃ¨re (`a / b`) et un modulo (`a % b`) sans utiliser `return`, uniquement avec des **pointeurs de sortie**.

---

ğŸ“Œ Prototype :
```c
void ft_div_mod(int a, int b, int *div, int *mod);
```
ğŸ§ª Explication pÃ©dagogique :
En C, une fonction ne peut retourner quâ€™une seule valeur directement avec return.
Mais si on veut renvoyer deux valeurs, on passe des pointeurs en arguments :

*div recevra a / b

*mod recevra a % b

Câ€™est une technique classique pour contourner la limite du return.

ğŸ›‘ Interdictions :

âŒ Action interdite  ğŸ’¬ Raisons pÃ©dagogiques
return une structure  Trop avancÃ© pour cet exercice
printf, scanf, stdlib.h Pas encore autorisÃ©s
Variables globales  Mauvaise pratique en C

âœ… Obligatoire :
Utiliser les pointeurs pour Ã©crire dans la mÃ©moire du programme appelant.

ğŸ’¬ Bulle dâ€™ami :
"Diviser, câ€™est partir Ã  deux : un va droit, lâ€™autre sort du chemin."

ğŸ§  Cas pratique :

c
Copier
Modifier
int d = 0;
int m = 0;
ft_div_mod(10, 3, &d, &m);
// d = 3, m = 1
âš ï¸ Ã€ ne pas oublier :
MÃªme si cet exercice ne le demande pas, penser Ã  vÃ©rifier b != 0 dans des programmes rÃ©els pour Ã©viter une division par zÃ©ro.

ğŸ“ Arborescence du projet ex11/ :

txt
Copier
Modifier
ex11/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ ft_div_mod.h
â”‚   â”œâ”€â”€ ft_putstr.h
â”‚   â”œâ”€â”€ ft_putnbr.h
â”‚   â””â”€â”€ ft_putchar.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ ft_div_mod.c
â”‚   â”œâ”€â”€ ft_putstr.c
â”‚   â”œâ”€â”€ ft_putnbr.c
â”‚   â””â”€â”€ ft_putchar.c
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ expected.txt
â”‚   â””â”€â”€ test.sh
â””â”€â”€ Makefile
ğŸ“¦ include/ft_div_mod.h

c
Copier
Modifier
#ifndef FT_DIV_MOD_H
# define FT_DIV_MOD_H

void ft_div_mod(int a, int b, int *div, int *mod);

#endif
ğŸ“¦ src/ft_div_mod.c

c
Copier
Modifier
#include "ft_div_mod.h"

void ft_div_mod(int a, int b, int *div, int *mod)
{
    *div = a / b;
    *mod = a % b;
}
ğŸ“¦ include/ft_putstr.h

c
Copier
Modifier
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
ğŸ“¦ src/ft_putstr.c

c
Copier
Modifier
#include <unistd.h>
#include "ft_putstr.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}
ğŸ“¦ include/ft_putchar.h

c
Copier
Modifier
#ifndef FT_PUTCHAR_H
# define FT_PUTCHAR_H

void ft_putchar(char c);

#endif
ğŸ“¦ src/ft_putchar.c

c
Copier
Modifier
#include <unistd.h>
#include "ft_putchar.h"

void ft_putchar(char c)
{
    write(1, &c, 1);
}
ğŸ“¦ include/ft_putnbr.h

c
Copier
Modifier
#ifndef FT_PUTNBR_H
# define FT_PUTNBR_H

void ft_putnbr(int nb);

#endif
ğŸ“¦ src/ft_putnbr.c

c
Copier
Modifier
#include "ft_putchar.h"
#include "ft_putnbr.h"

void ft_putnbr(int nb)
{
    if (nb == -2147483648)
    {
        write(1, "-2147483648", 11);
        return;
    }
    if (nb < 0)
    {
        ft_putchar('-');
        nb = -nb;
    }
    if (nb >= 10)
        ft_putnbr(nb / 10);
    ft_putchar(nb % 10 + '0');
}
ğŸ§ª test/main.c

c
Copier
Modifier
#include "../include/ft_div_mod.h"
#include "../include/ft_putstr.h"
#include "../include/ft_putnbr.h"
#include <unistd.h>

int main(void)
{
    int d = 0;
    int m = 0;

    ft_div_mod(10, 3, &d, &m);

    ft_putstr("div = ");
    ft_putnbr(d);
    ft_putstr(", mod = ");
    ft_putnbr(m);
    write(1, "\n", 1); // RÃ©sultat attendu : div = 3, mod = 1

    return 0;
}
ğŸ“„ test/expected.txt

ini
Copier
Modifier
div = 3, mod = 1
ğŸ“„ test/test.sh

bash
Copier
Modifier
#!/bin/bash

cd .. > /dev/null
make > /dev/null
./ex11 > test/output.txt

echo "RÃ©sultat attendu :"
cat test/expected.txt
echo "RÃ©sultat obtenu :"
cat test/output.txt
echo

diff test/output.txt test/expected.txt && echo "âœ… Test OK" || echo "âŒ Test FAIL"
ğŸ“„ Makefile

makefile
Copier
Modifier
NAME = ex11
CC = gcc
CFLAGS = -Wall -Wextra -Werror
SRC = src/ft_div_mod.c src/ft_putstr.c src/ft_putnbr.c src/ft_putchar.c test/main.c
INC = -Iinclude

all: $(NAME)

$(NAME):
  $(CC) $(CFLAGS) $(SRC) $(INC) -o $(NAME)

clean:
  rm -f $(NAME)

fclean: clean
  rm -f test/output.txt

re: fclean all
ğŸ” Reverse Engineering

ğŸ“ Analyse symbolique :

bash
Copier
Modifier
nm ex11 | grep ft_div_mod
ğŸ“ DÃ©sassemblage :

bash
Copier
Modifier
objdump -d ex11 | grep -A20 ft_div_mod
ğŸ“ Exemple dâ€™ASM (x86_64) :

asm
Copier
Modifier
ft_div_mod:
    mov     eax, edi      ; a
    mov     ecx, esi      ; b
    cdq                  ; signe pour division
    idiv    ecx           ; edx:eax / ecx â†’ eax = div, edx = mod
    mov     DWORD PTR [rdx], eax
    mov     DWORD PTR [r8], edx
ğŸ“Œ Ã€ retenir

ğŸ§  Point clÃ© Description
*div et *mod  Deux rÃ©sultats simulÃ©s par pointeurs
Pas de return Simulation de multi-retour
Cas rÃ©el  Ce genre de fonction est courant en C bas-niveau
SÃ©curitÃ©  Toujours tester b != 0 dans des projets pro

ğŸ§  Astuce finale :
Tu peux vÃ©rifier ta logique mathÃ©matique avec :

c
Copier
Modifier
assert((d * b + m) == a);
Cela garantit que la division et le modulo ont bien Ã©tÃ© effectuÃ©s correctement.

-------------------------------------------------
## 0.0.12) ft_ultimate_div_mod â€” [ğŸŸ¢ Facile] Modification directe
-------------------------------------------------

ğŸ¯ Objectif :
Modifier directement deux entiers passÃ©s en pointeurs pour que :
- `*a` contienne le **rÃ©sultat entier** de `a / b`
- `*b` contienne le **reste** de `a % b`

ğŸ“Œ Prototype :
```c
void ft_ultimate_div_mod(int *a, int *b);
ğŸ§ª Explication pÃ©dagogique :
Contrairement Ã  lâ€™exercice prÃ©cÃ©dent (ft_div_mod) oÃ¹ on renvoyait les rÃ©sultats dans deux pointeurs de sortie, ici on modifie les variables dâ€™entrÃ©e elles-mÃªmes. Câ€™est une technique de modification "in-place", typique dans les fonctions systÃ¨mes (ex : strtok, fgets, bzero...).

Exemple :

c
Copier
Modifier
int a = 10;
int b = 3;
ft_ultimate_div_mod(&a, &b);
// RÃ©sultat : a = 3, b = 1
ğŸ›‘ Interdictions :

âŒ Ne pas utiliser de return

âŒ Ne pas crÃ©er de variables div ou mod externes au scope de la fonction

âœ… Tout se fait en modifiant *a et *b uniquement

ğŸ’¬ Bulle dâ€™ami :
"Quand deux amis partagent tout, chacun doit changer un peu pour lâ€™autre."

âš ï¸ Bonnes pratiques :

Penser Ã  tester que *b != 0 avant toute division pour Ã©viter un crash

Ce genre de fonction est utile en bas niveau pour compresser des structures

ğŸ“‚ Arborescence du projet ex12/ :

txt
Copier
Modifier
ex12/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ ft_ultimate_div_mod.h
â”‚   â”œâ”€â”€ ft_putstr.h
â”‚   â”œâ”€â”€ ft_putnbr.h
â”‚   â””â”€â”€ ft_putchar.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ ft_ultimate_div_mod.c
â”‚   â”œâ”€â”€ ft_putstr.c
â”‚   â”œâ”€â”€ ft_putnbr.c
â”‚   â””â”€â”€ ft_putchar.c
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ expected.txt
â”‚   â””â”€â”€ test.sh
â””â”€â”€ Makefile
ğŸ“„ include/ft_ultimate_div_mod.h

c
Copier
Modifier
#ifndef FT_ULTIMATE_DIV_MOD_H
# define FT_ULTIMATE_DIV_MOD_H

void ft_ultimate_div_mod(int *a, int *b);

#endif
ğŸ“„ src/ft_ultimate_div_mod.c

c
Copier
Modifier
#include "ft_ultimate_div_mod.h"

void ft_ultimate_div_mod(int *a, int *b)
{
    int temp_a = *a;
    *a = *a / *b;
    *b = temp_a % *b;
}
ğŸ“„ include/ft_putstr.h

c
Copier
Modifier
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
ğŸ“„ src/ft_putstr.c

c
Copier
Modifier
#include <unistd.h>
#include "ft_putstr.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}
ğŸ“„ include/ft_putnbr.h

c
Copier
Modifier
#ifndef FT_PUTNBR_H
# define FT_PUTNBR_H

void ft_putnbr(int nb);

#endif
ğŸ“„ include/ft_putchar.h

c
Copier
Modifier
#ifndef FT_PUTCHAR_H
# define FT_PUTCHAR_H

void ft_putchar(char c);

#endif
ğŸ“„ src/ft_putchar.c

c
Copier
Modifier
#include <unistd.h>
#include "ft_putchar.h"

void ft_putchar(char c)
{
    write(1, &c, 1);
}
ğŸ“„ src/ft_putnbr.c

c
Copier
Modifier
#include "ft_putnbr.h"
#include "ft_putchar.h"

void ft_putnbr(int nb)
{
    if (nb == -2147483648)
    {
        write(1, "-2147483648", 11);
        return;
    }
    if (nb < 0)
    {
        ft_putchar('-');
        nb = -nb;
    }
    if (nb >= 10)
        ft_putnbr(nb / 10);
    ft_putchar(nb % 10 + '0');
}
ğŸ§ª test/main.c

c
Copier
Modifier
#include "../include/ft_ultimate_div_mod.h"
#include "../include/ft_putstr.h"
#include "../include/ft_putnbr.h"
#include <unistd.h>

int main(void)
{
    int a = 10;
    int b = 3;

    ft_ultimate_div_mod(&a, &b);

    ft_putstr("a = ");
    ft_putnbr(a);
    ft_putstr(", b = ");
    ft_putnbr(b);
    write(1, "\n", 1); // Attendu : a = 3, b = 1

    return 0;
}
ğŸ“„ test/expected.txt

ini
Copier
Modifier
a = 3, b = 1
ğŸ“„ test/test.sh

bash
Copier
Modifier
#!/bin/bash

cd .. > /dev/null
make > /dev/null
./ex12 > test/output.txt

echo "RÃ©sultat attendu :"
cat test/expected.txt
echo "RÃ©sultat obtenu :"
cat test/output.txt
echo

diff test/output.txt test/expected.txt && echo "âœ… Test OK" || echo "âŒ Test FAIL"
ğŸ“„ Makefile

makefile
Copier
Modifier
NAME = ex12
CC = gcc
CFLAGS = -Wall -Wextra -Werror
SRC = src/ft_ultimate_div_mod.c src/ft_putstr.c src/ft_putnbr.c src/ft_putchar.c test/main.c
INC = -Iinclude

all: $(NAME)

$(NAME):
  $(CC) $(CFLAGS) $(SRC) $(INC) -o $(NAME)

clean:
  rm -f $(NAME)

fclean: clean
  rm -f test/output.txt

re: fclean all
ğŸ” Reverse Engineering (bonus avancÃ©)

ğŸ“ Voir le symbole de la fonction :

bash
Copier
Modifier
nm ex12 | grep ft_ultimate_div_mod
ğŸ“ DÃ©sassembler la fonction :

bash
Copier
Modifier
objdump -d ex12 | grep -A20 ft_ultimate_div_mod
ğŸ”¬ Exemple de code assembleur attendu :

asm
Copier
Modifier
ft_ultimate_div_mod:
  mov eax, DWORD PTR [rdi]     ; charger *a
  mov ecx, DWORD PTR [rsi]     ; charger *b
  mov edx, eax                 ; copier *a
  xor edx, edx
  div ecx                      ; eax = *a / *b, edx = *a % *b
  mov DWORD PTR [rdi], eax     ; Ã©crire le rÃ©sultat dans *a
  mov DWORD PTR [rsi], edx     ; Ã©crire le modulo dans *b
ğŸ“Œ Ã€ retenir :

Concept Description
Pointeur int *a Permet d'accÃ©der/modifier directement une variable
Pas de return Tout est en mÃ©moire
div et mod combinÃ©s Optimisation classique
SÃ©curitÃ© : division par zÃ©ro ?  Ã€ vÃ©rifier dans des projets rÃ©els

ğŸ§  Conseil final :
Cet exercice est un exemple parfait de passage par adresse et dâ€™optimisation mÃ©moire. Il tâ€™oblige Ã  rÃ©flÃ©chir Ã  lâ€™Ã©tat initial et final de tes variables, ce qui est la base du raisonnement fonctionnel et du TDD.

-------------------------------------------------
## 0.0.13) ft_putstr â€” [ğŸŸ¢ Facile] Affichage de chaÃ®nes
-------------------------------------------------

ğŸ¯ Objectif :
Afficher une chaÃ®ne de caractÃ¨res, caractÃ¨re par caractÃ¨re, en utilisant uniquement `write`.

ğŸ“Œ Prototype :
```c
void ft_putstr(char *str);
ğŸ§ª Explication pÃ©dagogique :
Tu dois parcourir une chaÃ®ne de caractÃ¨res (char *) jusquâ€™au caractÃ¨re '\0', et Ã©crire chaque caractÃ¨re un par un Ã  lâ€™aide de write(1, &str[i], 1).

Cela te permet de comprendre comment fonctionne rÃ©ellement une string en mÃ©moire.

ğŸ›‘ Interdictions :

âŒ Pas de printf, puts, fputs, strlen

âœ… Uniquement write() (appel systÃ¨me brut)

âœ… Boucle manuelle while (*str) ou indexÃ©e

ğŸ’¬ Bulle d'ami :
"Une chaÃ®ne est comme un collier de perles : tu dois les enfiler une Ã  une pour les voir briller."

ğŸ¯ Mini-TDD :

ğŸ“‚ test/main.c

c
Copier
Modifier
#include <unistd.h>

void ft_putstr(char *str);

int main(void)
{
    ft_putstr("Hello World!");
    write(1, "\n", 1); // Test visuel + ligne finale
    return 0;
}
ğŸ“‚ src/ft_putstr.c

c
Copier
Modifier
#include <unistd.h>

void ft_putstr(char *str)
{
    while (*str)
    {
        write(1, str, 1);
        str++;
    }
}
ğŸ“‚ include/ft_putstr.h

c
Copier
Modifier
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
ğŸ§± Structure du projet :

bash
Copier
Modifier
ex13/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ ft_putstr.h
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_putstr.c
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ expected.txt
â”‚   â””â”€â”€ test.sh
â””â”€â”€ Makefile
âœ… expected.txt

nginx
Copier
Modifier
Hello World!
âœ… test/test.sh

bash
Copier
Modifier
#!/bin/bash

gcc -I ../include ../src/ft_putstr.c main.c -o test_putstr
./test_putstr > output.txt
diff output.txt expected.txt && echo "âœ… OK" || echo "âŒ FAIL"
âœ… Makefile (Ã  la racine ex13/)

makefile
Copier
Modifier
NAME = test_putstr
SRC = test/main.c src/ft_putstr.c
INC = -I include

all:
  gcc $(INC) $(SRC) -o $(NAME)

clean:
  rm -f $(NAME) test/output.txt

fclean: clean

re: fclean all
ğŸ” Reverse Engineering & Analyse ASM

ğŸ“¦ Objectif : comprendre comment ft_putstr se traduit dans le binaire final.

ğŸ“ nm
bash
Copier
Modifier
nm test_putstr | grep ft_putstr
Affiche l'adresse du symbole. Exemple :

r
Copier
Modifier
0000000000001149 T ft_putstr
ğŸ§  objdump -d (dÃ©sassemblage)
bash
Copier
Modifier
objdump -d test_putstr | grep -A20 ft_putstr
Tu verras quelque chose comme :

perl
Copier
Modifier
0000000000001149 <ft_putstr>:
 1149:   55                      push   %rbp
 114a:   48 89 e5                mov    %rsp,%rbp
 114d:   48 89 7d f8             mov    %rdi,-0x8(%rbp)
 1151:   eb 0f                   jmp    1162 <ft_putstr+0x19>
...
Cela montre que le compilateur transforme ta boucle while (*str) en un ensemble dâ€™instructions bas niveau (mov, cmp, jmp, call).

ğŸ“˜ Bonus : ASM logique pÃ©dagogique
Voici une version symbolique de ce que fait ft_putstr :

asm
Copier
Modifier
ft_putstr:
    mov rsi, str        ; adresse de la chaÃ®ne
.loop:
    cmp byte ptr [rsi], 0 ; si str[i] == '\0'
    je .done
    mov dl, [rsi]       ; copie str[i]
    mov edi, 1          ; fd = 1 (stdout)
    call write
    inc rsi
    jmp .loop
.done:
    ret
ğŸ“Œ Ã€ retenir :

Commande  RÃ´le
nm  Voir les fonctions visibles dans le binaire
objdump -d  Voir les instructions assembleur
strings Affiche les chaÃ®nes prÃ©sentes dans le binaire
readelf -s  Montre les symboles ELF

ğŸ§  Note pÃ©dagogique finale :
Cet exercice est beaucoup plus profond quâ€™il nâ€™y paraÃ®t : il pose les fondations pour comprendre comment fonctionne lâ€™affichage dans un OS, et prÃ©pare aux fonctions plus complexes comme printf, ou aux interactions systÃ¨mes avancÃ©es.

-------------------------------------------------

## 0.0.14) ex14: ft_strlen

-------------------------------------------------

**Le but :**
Calculer la longueur d'une chaÃ®ne de caractÃ¨res.

**Prototype :**

```c
int ft_strlen(char *str);
```
**Explication :**
>Parcourir la chaÃ®ne caractÃ¨re par caractÃ¨re.
>Compter jusqu'Ã  rencontrer le caractÃ¨re nul (\0).
>Retourner ce compteur.

**Interdictions :**

âŒ Pas de strlen

âœ… Parcourir manuellement

ğŸ’¬ Bulle d'ami :
"Le silence (\0) marque toujours la fin d'une belle histoire."

ğŸ¯ Mini-TDD :
Ã‰cris un test pour vÃ©rifier que "hello" retourne 5.

âœ… main.c

```c
#include <unistd.h>

int ft_strlen(char *str);
void ft_putnbr(int nb);
void ft_putstr(char *str);

int main(void)
{
    int len = ft_strlen("hello");

    ft_putstr("RÃ©sultat : ");
    ft_putnbr(len);
    write(1, "\n", 1); // RÃ©sultat attendu : 5

    return 0;
}
```

âœ… expected.txt

RÃ©sultat : 5

âœ… Makefile
makefile

NAME = test_strlen
SRC = main.c ft_strlen.c ft_putstr.c ft_putnbr.c

all:
  gcc $(SRC) -o $(NAME)

clean:
  rm -f $(NAME)

âœ… test.sh
bash

#!/bin/bash

gcc main.c ft_strlen.c ft_putstr.c ft_putnbr.c -o test_strlen
./test_strlen > output.txt
diff output.txt expected.txt && echo "OK" || echo "FAIL"

âœ… RÃ©sultat attendu

RÃ©sultat : 5


-------------------------------------------------

## 0.0.15) ex15: ft_strcpy

-------------------------------------------------

**Le but :**
Copier une chaÃ®ne de caractÃ¨res dans une autre.

**Prototype :**

```c
char *ft_strcpy(char *dest, char *src);
```
**Explication :**
Parcourir la chaÃ®ne source caractÃ¨re par caractÃ¨re,
et copier chaque caractÃ¨re dans dest, y compris le caractÃ¨re nul \0 final.

**Interdictions :**

âŒ Pas de strcpy

âœ… Tout Ã  la main

ğŸ’¬ Bulle d'ami :
"Copier, c'est respecter jusqu'au dernier dÃ©tail."

ğŸ¯ Mini-TDD :
Ã‰cris un test pour copier "abc" dans un tableau et vÃ©rifier.

ğŸ“‚ main.c :

```c

#include <unistd.h>

void ft_putstr(char *str);
char *ft_strcpy(char *dest, char *src);

int main(void)
{
  char src[] = "abc";
  char dest[10];

  ft_strcpy(dest, src);

  ft_putstr("RÃ©sultat : ");
  ft_putstr(dest);
  write(1, "\n", 1); // RÃ©sultat attendu : abc

  return 0;
}
```
âœ… expected.txt :

RÃ©sultat : abc

âœ… Makefile :
makefile

NAME = test_strcpy
SRC = main.c

all:
  gcc $(SRC) -o $(NAME)

clean:
  rm -f $(NAME)

âœ… test.sh :
bash

#!/bin/bash

gcc main.c -o test_strcpy
./test_strcpy > output.txt
diff output.txt expected.txt && echo "OK" || echo "FAIL"

ğŸ§ª RÃ©sultat attendu si tout est correct :
nginx

OK

-------------------------------------------------

## 0.0.16) ex16: ft_strncpy

-------------------------------------------------

**Le but :**
Copier jusqu'Ã  n caractÃ¨res d'une chaÃ®ne source vers une destination.

**Prototype :**

```c
char *ft_strncpy(char *dest, char *src, unsigned int n);
```
**Explication :**
>Parcourt la chaÃ®ne `src` et copie caractÃ¨re par caractÃ¨re jusquâ€™Ã  `n` caractÃ¨res.
>Si `src` est plus court que `n`, le reste de `dest` est rempli de `\0`.

**Interdictions :**

âŒ Pas de strncpy

âœ… Tout Ã©crire toi-mÃªme

ğŸ’¬ Bulle d'ami :
"Quand tu copies avec soin, mÃªme ce qui reste doit Ãªtre propre."

ğŸ¯ Mini-TDD :
Ã‰cris un test pour copier "test" avec n = 6, et vÃ©rifie que dest contient :
  >'t', 'e', 's', 't', '\0', '\0'

ğŸ“‚ main.c :

```c
#include <unistd.h>

char *ft_strncpy(char *dest, char *src, unsigned int n);
// Affiche un tableau de caractÃ¨res sous forme brute (octets)
void print_buffer(char *str, unsigned int n);

int main(void)
{
    char dest[10] = "xxxxxxxxx";
    ft_strncpy(dest, "test", 6); // on copie "test" dans dest avec n = 6
    print_buffer(dest, 6);       // attendu : test.. (avec deux \0)
    return 0;
}
```

âœ… expected.txt
bash

test..

âœ… Makefile
makefile

# Makefile
NAME = test_strncpy
SRC = main.c

all:
  gcc $(SRC) -o $(NAME)

clean:
  rm -f $(NAME)

âœ… test.sh
sh

#!/bin/bash

gcc main.c -o test_strncpy
./test_strncpy > output.txt
diff output.txt expected.txt && echo "OK" || echo "FAIL"

-------------------------------------------------

## 0.0.17) ex17: ft_str_is_alpha

-------------------------------------------------

**Le but :**
VÃ©rifier si une chaÃ®ne ne contient que des lettres.

**Prototype :**

c
Copier ou Modifier

```c
int ft_str_is_alpha(char *str);
```
**Explication :**
Parcourir et tester chaque caractÃ¨re.

**Interdictions :**

âŒ Pas de fonctions toutes faites

âœ… Comparer manuellement

ğŸ’¬ Bulle d'ami :
"Chaque mot est fait uniquement de lettres... ou pas."

ğŸ¯ Mini-TDD :
Ã‰cris un test pour vÃ©rifier "Hello" (ok) et "Hello83" (pas ok).

âœ… Programme de test (main.c) :
```c
#include <unistd.h>

int ft_str_is_alpha(char *str);
// Affichage d'un entier
void ft_putnbr(int nb);
// Affichage d'une chaÃ®ne
void ft_putstr(char *str);


int main(void)
{
    int r1 = ft_str_is_alpha("Hello");
    int r2 = ft_str_is_alpha("Hello83");

    ft_putstr("Test 1 (\"Hello\") : ");
    ft_putnbr(r1);
    write(1, "\n", 1);

    ft_putstr("Test 2 (\"Hello42\") : ");
    ft_putnbr(r2);
    write(1, "\n", 1);

    return 0;
}
```

âœ… expected.txt :
nginx

Test 1 ("Hello") : 1
Test 2 ("Hello83") : 0

âœ… Makefile :
makefile

NAME = test_str_is_alpha
SRC = main.c ft_str_is_alpha.c

all:
  gcc $(SRC) -o $(NAME)

clean:
  rm -f $(NAME)

âœ… test.sh :
bash

#!/bin/bash

gcc main.c ft_str_is_alpha.c -o test_str_is_alpha
./test_str_is_alpha > output.txt
diff output.txt expected.txt && echo "OK" || echo "FAIL"

-------------------------------------------------

## 0.0.18) ex18: ft_str_is_numeric

-------------------------------------------------

**Le but :**
VÃ©rifier si une chaÃ®ne ne contient que des chiffres.

**Prototype :**

```c
int ft_str_is_numeric(char *str);
```
**Explication :**
Tester si chaque caractÃ¨re est entre '0' et '9'.

**Interdictions :**

âŒ Pas de isdigit

âœ… Comparer manuellement

ğŸ’¬ Bulle d'ami :
"Un code secret n'est fait que de chiffres."

ğŸ¯ Mini-TDD :
Ã‰cris un test pour vÃ©rifier "123456" (ok) et "123abc" (pas ok).

ğŸ’¡ Une chaÃ®ne vide est considÃ©rÃ©e comme valide (retourne 1).

-------------------------------------------------

## 0.0.19) ex19: ft_str_is_lowercase

-------------------------------------------------

**Le but :**
VÃ©rifier si une chaÃ®ne ne contient que des minuscules.

**Prototype :**

c
Copier ou Modifier

```c
int ft_str_is_lowercase(char *str);
```
**Explication :**
VÃ©rifier si chaque caractÃ¨re est entre 'a' et 'z'.

**Interdictions :**

âŒ Pas de fonction externe

âœ… Utiliser uniquement des comparaisons

ğŸ’¬ Bulle d'ami :
"Les minuscules murmurent, mais elles sont fidÃ¨les."

ğŸ¯ Mini-TDD :
Ã‰cris un test pour vÃ©rifier "bonjour" (ok) et "BonJour" (pas ok).

-------------------------------------------------

# Piscine BoostÃ©e - Bloc 1 (Partie 3/5) â€” Nouveau Format [ğŸŸ¢ Facile]

-------------------------------------------------

## 0.0.20) ex20: ft_str_is_uppercase

-------------------------------------------------

**Le but :**
VÃ©rifier si une chaÃ®ne ne contient que des majuscules.

**Prototype :**

```c
int ft_str_is_uppercase(char *str);
```
**Explication :**
VÃ©rifier chaque caractÃ¨re entre 'A' et 'Z'.

**Interdictions :**

âŒ Pas de isupper

âœ… Comparaison directe obligatoire

ğŸ’¬ Bulle d'ami :
"Les majuscules hurlent pour se faire remarquer."

ğŸ¯ Mini-TDD :
Ã‰cris un test pour "HELLO" (ok) et "Hello" (pas ok).
ğŸ” Bonus : que renvoie " " (vide) ? Devrait-il Ãªtre considÃ©rÃ© comme valide ?
ğŸ” Indice : utilise une boucle et vÃ©rifie si chaque caractÃ¨re est entre 'A' et 'Z'.

-------------------------------------------------

## 0.0.21) ex21: ft_str_is_printable

-------------------------------------------------

**Le but :**
VÃ©rifier si une chaÃ®ne ne contient que des caractÃ¨res imprimables.

**Prototype :**

```c
int ft_str_is_printable(char *str);
```
**Explication :**
Tester que chaque caractÃ¨re est dans la plage ASCII imprimable.

**Interdictions :**

âŒ Pas de fonction toute faite

âœ… Comparaison avec les codes ASCII

ğŸ’¬ Bulle d'ami :
"Ce qu'on ne voit pas peut cacher des erreurs."

ğŸ¯ Mini-TDD :
Ã‰cris un test pour vÃ©rifier "test" (ok) et une chaÃ®ne avec \n (pas ok).
ğŸ” Bonus : que fait une chaÃ®ne vide ? Est-elle "imprimable" ?
ğŸ” Indice : la plage ASCII imprimable va de 32 Ã  126 inclus.

-------------------------------------------------

## 0.0.22) ex22: ft_strupcase

-------------------------------------------------

**Le but :**
Transformer tous les caractÃ¨res minuscules d'une chaÃ®ne en majuscules.

**Prototype :**

```c
char *ft_strupcase(char *str);
```
**Explication :**
DÃ©tecter les minuscules et les transformer en majuscules ASCII.

**Interdictions :**

âŒ Pas d'appel Ã  toupper

âœ… Travail ASCII manuel

ğŸ’¬ Bulle d'ami :
"Quand tu cries plus fort, tu passes en majuscule."

ğŸ¯ Mini-TDD :
Ã‰cris un test sur `"hello"` pour obtenir `"HELLO"`.
ğŸ” Bonus : Essaie avec `"HeLlo83!"` pour vÃ©rifier que les chiffres et majuscules sont conservÃ©s.
ğŸ” Indice : la conversion se fait en soustrayant 32 du code ASCII.

-------------------------------------------------

## 0.0.23) ex23: ft_strlowcase

-------------------------------------------------

**Le but :**
Transformer tous les caractÃ¨res majuscules d'une chaÃ®ne en minuscules.

**Prototype :**

```c
char *ft_strlowcase(char *str);
```
**Explication :**
DÃ©tecter les majuscules et les transformer en minuscules ASCII.

**Interdictions :**

âŒ Pas d'appel Ã  tolower

âœ… Travail ASCII obligatoire

ğŸ’¬ Bulle d'ami :
"Descendre le ton, c'est passer de majuscule Ã  minuscule."

ğŸ¯ Mini-TDD :
Tester `"HELLO"` et obtenir `"hello"`.
ğŸ” Bonus : Essaie avec `"HEllO42!"` â†’ `"hello42!"` pour vÃ©rifier que les chiffres et minuscules sont conservÃ©s.
ğŸ” Indice : en ASCII, tu peux transformer une majuscule en minuscule en ajoutant 32.

-------------------------------------------------

## 0.0.24) ex24: ft_strcapitalize

-------------------------------------------------

**Le but :**
Mettre la premiÃ¨re lettre de chaque mot en majuscule et les autres en minuscules.

**Prototype :**

```c
char *ft_strcapitalize(char *str);
```
**Explication :**
DÃ©tecter les dÃ©buts de mots et ajuster les majuscules/minuscules.

**Interdictions :**

âŒ Pas de fonction externe

âœ… GÃ©rer tout toi-mÃªme

ğŸ’¬ Bulle d'ami :
"Chaque dÃ©but est important, le reste suit doucement."

ğŸ¯ Mini-TDD :
Tester `"salut, comment tu vas ?"` â†’ `"Salut, Comment Tu Vas ?"`
ğŸ” Bonus : Essaie aussi avec `"sALUT, 42mOtS tEst!"` â†’ `"Salut, 42mots Test!"`
ğŸ” Rappel : un mot commence aprÃ¨s un caractÃ¨re non-alphanumÃ©rique.

ğŸ’¡ Indice ASCII : 
- majuscule â†’ minuscule : `+32` si entre 'A' et 'Z'
- minuscule â†’ majuscule : `-32` si entre 'a' et 'z'

-------------------------------------------------

## 0.0.25) ex25: ft_strlcpy

-------------------------------------------------

**Le but :**
Copier une chaÃ®ne dans une autre avec gestion du buffer size.

**Prototype :**

```c
unsigned int ft_strlcpy(char *dest, char *src, unsigned int size);
```
**Explication :**
Copier jusqu'Ã  size-1 caractÃ¨res et terminer par \0.

**Interdictions :**

âŒ Pas de strlcpy

âœ… Faire tout manuellement

ğŸ’¬ Bulle d'ami :
"ProtÃ©ger la taille, c'est respecter la mÃ©moire."

ğŸ¯ Mini-TDD :
Tester la copie de "hello" avec size = 3 â†’ dest doit contenir "he\0"
ğŸ” Rappel : la fonction retourne la longueur de src, mÃªme si la copie est tronquÃ©e.
ğŸ” Bonus : Tester avec size = 0 â†’ dest ne doit pas Ãªtre modifiÃ©, retour = 5

-------------------------------------------------

## 0.0.26) ex26: ft_putstr_non_printable

-------------------------------------------------

**Le but :**
Afficher une chaÃ®ne, remplacer les caractÃ¨res non imprimables par leur valeur hexadÃ©cimale.

**Prototype :**
```c
void ft_putstr_non_printable(char *str);
```

**Explication :**
Si un caractÃ¨re n'est pas imprimable, afficher \ suivi de son code hexadÃ©cimal.

**Interdictions :**

âŒ Pas d'utilisation de printf/hex fonctions automatiques

âœ… Construction manuelle

ğŸ’¬ Bulle d'ami :
"Si tu ne peux pas le lire, Ã©cris son nom secret."

â„¹ï¸ Un caractÃ¨re est considÃ©rÃ© comme non imprimable sâ€™il est hors de la plage ASCII 32 Ã  126.

ğŸ¯ Mini-TDD :
Tester "Coucou\ntu vas bien ?" et vÃ©rifier l'affichage.
ğŸ” Bonus : Tester une chaÃ®ne contenant \a, \t, \v et \x7F pour explorer plus de cas non imprimables.
ğŸ§© Astuce : Pour convertir un octet en hexadÃ©cimal, divise par 16 pour obtenir le premier chiffre, puis le modulo pour le second.

-------------------------------------------------
## 0.0.27) ex27: ft_print_memory (Partie 1)
-------------------------------------------------
Le but :
Afficher l'Ã©tat brut de la mÃ©moire d'une chaÃ®ne.

**Prototype :**
```c
void *ft_print_memory(void *addr, unsigned int size);
```
**Explication :**
Afficher l'adresse mÃ©moire suivie de 16 octets imprimables ou reprÃ©sentÃ©s en hexadÃ©cimal.

ğŸ” Pour chaque ligne :
- Afficher lâ€™adresse mÃ©moire (en hexadÃ©cimal sur 16 caractÃ¨res).
- Afficher les 16 octets en hexadÃ©cimal, sÃ©parÃ©s deux Ã  deux.
- Afficher les 16 caractÃ¨res ASCII imprimables ou `.` pour les autres.

ğŸ’¡ Ce type dâ€™affichage est similaire Ã  la commande `hexdump`.

**Interdictions :**

âŒ Pas de bibliothÃ¨que externe

âœ… Respecter l'affichage proprement

ğŸ’¬ Bulle d'ami :
>"La mÃ©moire est une histoire invisible qu'il faut Ã©crire ligne par ligne."
>Astuce : Tu as dÃ©jÃ  converti des caractÃ¨res non imprimables en hexadÃ©cimal dans ex26. Ici, tu le fais de maniÃ¨re systÃ©matique, avec l'adresse comme bonus.

ğŸ¯ Mini-TDD :
CrÃ©er un petit tableau de caractÃ¨res et tester ft_print_memory.

```c
char data[] = "Hello World! 83 \n";

ft_print_memory(data, sizeof(data));
```
Exemple de ligne Ã  produire (format indicatif) :
0x0000000000abc000: 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 20 38 33 0a  Hello World! 83.

-------------------------------------------------
# Piscine BoostÃ©e - Bloc 1 (Partie 4/5) â€” Nouveau Format [ğŸŸ¢ Facile]
-------------------------------------------------
ğŸ“š Exercices BONUS spÃ©ciaux â€” Piscine BoostÃ©e
-------------------------------------------------
## 0.1.0) ex28: ft_recursive_factorial
-------------------------------------------------
Le but :
Calculer la factorielle d'un nombre (n!) en utilisant la rÃ©cursion.

**Prototype :**

```c
int ft_recursive_factorial(int nb);
```
**Explication :**
Utiliser une fonction qui s'appelle elle-mÃªme pour multiplier les nombres de n Ã  1.

**Interdictions :**

âŒ Pas de boucles (for, while)

âœ… RÃ©cursion obligatoire

ğŸ’¬ Bulle d'ami :
"Parfois, pour aller au sommet, il faut redescendre chaque marche."

ğŸ¯ Mini-TDD :
Tester ft_recursive_factorial(5) â” rÃ©sultat attendu: 120.

ğŸ’¡ Et si nb vaut 0 ? Ou un nombre nÃ©gatif ? Penses-y !

-------------------------------------------------
## 0.1.1) ex29: ft_iterative_factorial
-------------------------------------------------
Le but :
Calculer la factorielle d'un nombre (n!) en utilisant des boucles.

**Prototype :**

```c
int ft_iterative_factorial(int nb)
```
**Explication :**
Utiliser une boucle pour multiplier les nombres jusqu'Ã  n.

**Interdictions :**

âŒ Pas de rÃ©cursion

âœ… Boucles uniquement

ğŸ’¬ Bulle d'ami :
"Pas besoin de creuser, avance pas Ã  pas jusqu'au sommet."

ğŸ¯ Mini-TDD :
Tester ft_iterative_factorial(4) â” rÃ©sultat attendu: 24.

ğŸ’¡ Et si nb vaut 0 ou moins ? Ton algorithme devrait-il le gÃ©rer ?

-------------------------------------------------
## 0.1.2) ex30: ft_recursive_power
-------------------------------------------------
Le but :
Calculer la puissance d'un nombre nb exposant power par rÃ©cursion.

**Prototype :**
```c
int ft_recursive_power(int nb, int power);
```
**Explication :**
Utiliser une fonction rÃ©cursive pour multiplier plusieurs fois.

**Interdictions :**

âŒ Pas de boucle

âœ… RÃ©cursion uniquement

ğŸ’¬ Bulle d'ami :
"Chaque pas en avant double ta force."

ğŸ¯ Mini-TDD :
Tester ft_recursive_power(2, 3) â” rÃ©sultat attendu: 8.

ğŸ’¡ Et si la puissance est nÃ©gative ? Que doit-on faire ?
ğŸ’¡ Variante : aprÃ¨s avoir explorÃ© la rÃ©cursion, voyons maintenant comment le mÃªme problÃ¨me peut se rÃ©soudre sans appel rÃ©cursif, avec des boucles uniquement.

-------------------------------------------------
## 0.1.3) ex31: ft_iterative_power
-------------------------------------------------
Le but :
Calculer la puissance d'un nombre par itÃ©ration.

**Prototype :**

```c
int ft_iterative_power(int nb, int power);
```
**Explication :**
Utiliser une boucle pour multiplier successivement.

**Interdictions :**

âŒ Pas de rÃ©cursion

âœ… Utiliser uniquement des boucles

ğŸ’¬ Bulle d'ami :
"Les petits pas rÃ©pÃ©tÃ©s construisent des montagnes."

ğŸ¯ Mini-TDD :
Tester ft_iterative_power(3, 2) â” rÃ©sultat attendu: 9.

-------------------------------------------------
## 0.1.4) ex32: ft_fibonacci
-------------------------------------------------
Le but :
Trouver le n-iÃ¨me nombre de la suite de Fibonacci.

**Prototype :**
```c
int ft_fibonacci(int index);
```
**Explication :**
La suite commence par 0, 1, et chaque nombre est la somme des deux prÃ©cÃ©dents.

**Interdictions :**

âŒ Pas d'itÃ©ration

âœ… RÃ©cursion obligatoire

ğŸ’¬ Bulle d'ami :
"La nature pousse en Fibonacci, doucement mais sÃ»rement."

ğŸ¯ Mini-TDD :
Tester ft_fibonacci(7) â” rÃ©sultat attendu: 13.

ğŸ§  Remarque : Cette version est correcte mais peu efficace pour de grands index. On verra plus tard comment amÃ©liorer cela avec des techniques comme la mÃ©moÃ¯sation.

-------------------------------------------------
## 0.1.5) ex33: ft_sqrt
-------------------------------------------------

Le but :
Calculer la racine carrÃ©e entiÃ¨re d'un nombre.

**Prototype :**

```c
int ft_sqrt(int nb);
```
**Explication :**
Trouver un entier qui multipliÃ© par lui-mÃªme donne nb.

**Interdictions :**

âŒ Pas d'utilisation de sqrt de math.h

âœ… Boucle ou approche progressive obligatoire

ğŸ’¬ Bulle d'ami :
"Trouver la racine, c'est creuser jusqu'Ã  tomber juste."

ğŸ§  Remarque : Pense Ã  tester pour nb = 0, 1, 2, et les grands nombres pour bien gÃ©rer les bornes.

ğŸ¯ Mini-TDD :
Tester ft_sqrt(16) â” rÃ©sultat attendu: 4.
Tester ft_sqrt(20) â” rÃ©sultat attendu: 0 (car 20 nâ€™a pas de racine carrÃ©e entiÃ¨re).

-------------------------------------------------
## 0.1.6) ex34: ft_is_prime
-------------------------------------------------

Le but :
DÃ©terminer si un nombre est premier.

**Prototype :**

```c
int ft_is_prime(int nb);
```
**Explication :**
Tester si un nombre n'a pas de diviseur autre que 1 et lui-mÃªme.


**Interdictions :**

âŒ Pas de bibliothÃ¨que mathÃ©matique

âœ… Boucles autorisÃ©es

ğŸ’¬ Bulle d'ami :
"Un nombre premier est un solitaire, il ne se laisse diviser par personne."

ğŸ§  Pense Ã  tester aussi les cas limites comme 0, 1, 2, ou les grands nombres.

ğŸ¯ Mini-TDD :
Tester ft_is_prime(13) â” attendu: 1 (vrai).
Tester ft_is_prime(12) â” attendu: 0 (faux).

-------------------------------------------------
## 0.1.7) ex35: ft_find_next_prime
-------------------------------------------------
Le but :
Trouver le nombre premier suivant ou Ã©gal Ã  un nombre donnÃ©.

**Prototype :**

```c
int ft_find_next_prime(int nb);
```
**Explication :**
Avancer jusqu'Ã  trouver un nombre premier supÃ©rieur ou Ã©gal.

**Interdictions :**

âŒ Utiliser seulement ce que tu sais

âœ… Boucle + appel de ft_is_prime possible

ğŸ’¬ Bulle d'ami :
"Si ton chemin est barrÃ©, avance jusqu'Ã  trouver la voie royale."

ğŸ§  Astuce :
Nâ€™oublie pas de gÃ©rer les cas < 2 (il nâ€™y a pas de nombre premier < 2).

ğŸ¯ Mini-TDD :
Tester ft_find_next_prime(14) â” attendu : 17  
Pense aussi Ã  vÃ©rifier ft_find_next_prime(17) â” attendu : 17

-------------------------------------------------
# Piscine BoostÃ©e - Bloc 1 (Partie 5/5) â€” Nouveau Format [ğŸŸ¢ Facile]
-------------------------------------------------

ğŸ“š Explications gÃ©nÃ©rales de fin de Piscine BoostÃ©e

-------------------------------------------------
## ğŸ“‹ Ce que tu as appris dans la Piscine
-------------------------------------------------
MaÃ®triser les boucles (while, for),

Utiliser les pointeurs,

Manipuler la mÃ©moire,

CrÃ©er des chaÃ®nes de caractÃ¨res manuellement,

Commencer Ã  penser en rÃ©cursion,

Tester ton code (TDD minimal),

Respecter une structure de projet claire.

ğŸš€ Introduction au TDD (Test Driven Development)
Ã€ partir de maintenant, tu dois appliquer TDD dÃ¨s que possible !

ğŸ“¢ Comment faire ton TDD minimal ?

Voici une mÃ©thode simple, efficace et rÃ©utilisable :

| Ã‰tape | Action Ã  effectuer                                      |
|-------|---------------------------------------------------------|
| 1ï¸âƒ£     | Avant de coder ta fonction, Ã©cris une fonction de test. |
| 2ï¸âƒ£     | VÃ©rifie que ta fonction retourne bien le bon rÃ©sultat.  |
| 3ï¸âƒ£     | Si ton test Ã©choue â” tu corriges ta fonction.          |
| 4ï¸âƒ£     | Si ton test passe â” tu peux passer Ã  l'Ã©tape suivante. |

-------------------------------------------------
ğŸ“‹ Exemples de TDD minimal pour Piscine

-------------------------------------------------
Tester ft_putchar :

```c
// Test minimal
void test_ft_putchar(void)
{
 ft_putchar('A');
}
(VÃ©rifier que 'A' s'affiche.)

```
Tester ft_strlen :

```c
void test_ft_strlen(void)
{

 int len = ft_strlen("hello");
 // Ã€ vÃ©rifier en lisant la valeur (dans de vrais tests, tu pourrais afficher avec printf temporairement)
}
```

ğŸ“Œ Conseil final :

N'oublie pas : ce que tu testes te protÃ¨ge.
Un bon test, mÃªme petit, tâ€™Ã©vitera des erreurs plus tard.

-------------------------------------------------
ğŸ“‹ Petit guide pour ton projet Piscine

-------------------------------------------------
ğŸ“š Structure obligatoire dÃ¨s maintenant

-------------------------------------------------
>Ã€ partir des prochains exercices (et dÃ¨s Libft++), tu devrass structurer chaque projet ainsi :

```sh

projet/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c
â”‚ â”œâ”€â”€ fonctions.c
â”‚ â”œâ”€â”€ ...
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ projet.h
â”œâ”€â”€ tests/
â”‚ â”œâ”€â”€ tests_main.c
â”‚ â”œâ”€â”€ tests_fonctions.c
â”‚ â”œâ”€â”€ ...
â”œâ”€â”€ bonus/ (facultatif pour exercices bonus)
```
>src/ â” tout ton code principal .c
>include/ â” tous tes headers .h
>tests/ â” tes fichiers de tests pour TDD
>bonus/ â” uniquement pour des extensions si demandÃ©

ğŸ“‹ Attention sur la norme 42

**Rappel obligatoire :**

| RÃ¨gle                        | DÃ©tail                               |
|------------------------------|--------------------------------------|
| Longueur max d'une fonction  | 25 lignes maximum                    |
| Indentation                  | 1 tabulation = 4 espaces             |
| Nom des fichiers             | `ft_nom.c`, `ft_nom.h`, etc.         |
| Structures de boucle         | Pas de `for`, pas de `do...while`    |
| Style des variables          | minuscules uniquement (`int ok;`)    |

ğŸ“¦ Exemple de projet structurÃ©

```sh
ft_strlen/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strlen.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ ft_strlen.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_ft_strlen.c
```

ğŸ“š Glossaire rapide pour t'aider

Mot DÃ©finition
Pointeur     = Une variable qui contient une adresse mÃ©moire
RÃ©cursion    = Une fonction qui s'appelle elle-mÃªme
TDD          = Test Driven Development: tester ton code avant de le terminer
ModularitÃ©   = Organiser ton code proprement par modules/fichiers
Arborescence = La structure des dossiers de ton projet
Norme        =Ensemble de rÃ¨gles strictes de codage (indentation, lignes max, etc.)

ğŸ¯ RÃ©sumÃ© de la Piscine BoostÃ©e

Tu sais faire maintenant RÃ©sultat
Manipuler des caractÃ¨res, chiffres, chaÃ®nes âœ… Oui
Utiliser write, pointeurs, boucles, rÃ©cursion âœ… Oui
Commencer Ã  tester ton code sÃ©rieusement âœ… Oui
Suivre une structure de projet propre âœ… Oui
ğŸ“¢ Et maintenant ?
âœ… Bloc 1 (Piscine BoostÃ©e complÃ¨te) terminÃ©, [ğŸŸ¢ Facile]
âœ… Tu es prÃªt Ã  attaquer Bloc 2 â” Libft++ et projets plus sÃ©rieux, [ğŸŸ¢ Facile]
âœ… Avec TDD qui va devenir progressivement plus costaud.

ğŸ“¢ğŸ›¡ï¸ Fin du Bloc 1 BoostÃ© â€” FÃ©licitations ! [ğŸŸ¢ Facile]

ğŸ§  Tu viens de franchir une premiÃ¨re montagne.
La suite sera plus exigeante, mais tu as dÃ©jÃ  les outils pour crÃ©er, tester, et structurer comme un(e) vrai(e) dÃ©veloppeur(se).

Bienvenue dans le monde des vrais projets.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Bloc 2 â€” Libft++ BoostÃ©e â€” Partie 1/? [ğŸŸ¢ Facile]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“š Introduction â€” Libft++ Partie 1

Dans cette nouvelle Ã©tape, tu vas commencer Ã  recrÃ©er toi-mÃªme **les fonctions essentielles du langage C**, sans utiliser aucune fonction de la librairie standard.

ğŸ¯ Objectifs :

- Comprendre prÃ©cisÃ©ment le comportement bas niveau de chaque fonction.
- GÃ©rer correctement la mÃ©moire, les pointeurs et les chaÃ®nes.
- Structurer ton code comme une vÃ©ritable **librairie rÃ©utilisable**.
- Appliquer le **TDD (Test Driven Development)** pour fiabiliser ton code.

ğŸš€ Arborescence obligatoire pour Libft++
```sh
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ ft_strlen.c
â”‚ â”œâ”€â”€ ft_strcpy.c
â”‚ â”œâ”€â”€ ...
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚ â”œâ”€â”€ tests_ft_strlen.c
â”‚ â”œâ”€â”€ tests_ft_strcpy.c
â”‚ â”œâ”€â”€ ...
```

ğŸ§ª RÃ¨gle :
- Chaque fonction .c doit avoir son fichier de test correspondant dans le dossier tests/.
  Exemple :

  - ft_strlen.c â†’ tests/tests_ft_strlen.c
  - ft_strcpy.c â†’ tests/tests_ft_strcpy.c

ğŸ’¡ Compilation type :

```bash
make && ./tests/tests_ft_strlen
```
ğŸ“¢ Astuce :

- Tu peux commencer avec des tests simples (affichage ou retour de valeur), puis les enrichir au fur et Ã  mesure avec
  des cas limites, des valeurs incorrectes, et des scÃ©narios plus exigeants.

âœ¨ â€œCrÃ©er ta propre libft, câ€™est poser les fondations de ton propre standard de code.â€

-------------------------------------------------
## 1.0) ft_strlen
-------------------------------------------------
**ğŸ§  Le but :**
- Calculer la longueur d'une chaÃ®ne de caractÃ¨res.

**ğŸ“Œ Prototype :**

```c
size_t ft_strlen(const char *str);
```
**ğŸ§ª Explication :**
Parcourir la chaÃ®ne caractÃ¨re par caractÃ¨re jusqu'Ã  trouver \0 (fin de chaÃ®ne).
- Ta fonction doit :
  - Lire chaque caractÃ¨re de la chaÃ®ne str.
  - Compter chaque caractÃ¨re tant que ce nâ€™est pas \0.
  - Retourner le nombre total.

**ğŸ›‘ Interdictions :**
- âŒ strlen
- âŒ Toute fonction de <string.h>

**âœ… Tu dois :**
- Utiliser une boucle simple (while)
- Manipuler les pointeurs ou indices Ã  la main

ğŸ’¬ Bulle d'ami :
"Une chaÃ®ne prend fin dans le silence (\0), le souffle final que personne nâ€™entend."

ğŸ¯ Mini-TDD :
Testez "hello" (devrait retourner 5) et "" (devrait retourner 0).
CrÃ©e un fichier de test simple :

```c
#include <unistd.h>
#include "libft.h" // si tu es dans un vrai projet

int main(void)
{
  ...
}
```

ğŸ§ª Comment tester automatiquement ?
Par exemple, un fichier test.sh pour chaque fonction :

```sh
#!/bin/bash
gcc -g -Iinclude -o test_ft_strdup tests/tests_ft_strdup.c src/ft_strdup.c src/ft_strcpy.c src/ft_strlen.c
./test_ft_strdup
```

ğŸ§± Structure recommandÃ©e :

```sh
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strlen.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_strlen.c
```
ğŸ’¡ Conseils :

- Utilise un compteur (size_t i = 0) et incrÃ©mente-le dans la boucle.
- Ne pas oublier le #include <stddef.h> pour size_t.

ğŸ§ª Bonus pour TDD plus poussÃ© :

- Ajoute un test sur une chaÃ®ne trÃ¨s longue.
- Ajoute un test sur une chaÃ®ne avec des caractÃ¨res spÃ©ciaux.

ğŸ“¦ [Nouveau] Ton Arsenal de DÃ©veloppeur Commence ici ğŸ§ 

ğŸ› ï¸ Premiers outils de DÃ©veloppeur Pro : Git, GDB, RE
ğŸ§¬ Git â€” Suivre ton travail
ğŸ’¡ CrÃ©e un dÃ©pÃ´t Git pour ta libft++ :

```bash
cd libft
git init
git add .
git add test.sh
git commit -m "[test] Script de test automatique pour ft_strdup"
git commit -m "Ajout de ft_strlen avec TDD"
```
But : apprendre Ã  faire des commits propres Ã  chaque Ã©tape importante.

â¡ï¸ Utilise un commit pour chaque fonction terminÃ©e (et testÃ©e).

ğŸ GDB â€” Premier pas vers le dÃ©bogage
ğŸ’¡ Compile ton test avec les symboles de debug :

```bash
gcc -g -Iinclude -o test_strlen tests/tests_ft_strlen.c src/ft_strlen.c
```
ğŸ’¡ Lance GDB :

```bash
gdb ./test_strlen
```
Puis tape :

```gdb
break ft_strlen
run
step
print str
```
ğŸ“š Ce que tu apprends : comprendre ce que fait rÃ©ellement ta fonction ligne par ligne, et voir ce que contient chaque variable.

ğŸ” Reverse Engineering (RE) â€” Lecture du code machine
ğŸ’¡ Pour observer le code assembleur de ta fonction :

```bash
objdump -d ./test_strlen | less
```
â¡ï¸ Cherche la partie correspondant Ã  ft_strlen pour voir comment elle est compilÃ©e.

ğŸ’¡ Ou bien utilise :

```bash
nm ./test_strlen | grep ft_strlen
```
â¡ï¸ Cela te donne lâ€™adresse de ta fonction. Tu peux la croiser avec objdump.

ğŸ“ RÃ©sumÃ©
- Outil Ã€ quoi il sert ?
- git Sauvegarder et suivre l'Ã©volution de ton code
- gdb DÃ©boguer pas Ã  pas, inspecter les variables
- objdump, nm Voir ce que ton code devient aprÃ¨s compilation (niveau systÃ¨me)

-------------------------------------------------
## 1.1) ft_strcpy
-------------------------------------------------
**ğŸ§  Le but :**
- Copier une chaÃ®ne de caractÃ¨res (`src`) dans une autre (`dest`), y compris le `\0` final.

**ğŸ“Œ Prototype :**
```c
char *ft_strcpy(char *dest, const char *src);
```
ğŸ§ª Explication :

Lire chaque caractÃ¨re de src.

Le copier dans dest, un par un.

Terminer la copie par le caractÃ¨re nul \0.

Retourner le pointeur dest.

ğŸ›‘ Interdictions :
- âŒ strcpy
- âŒ Toute fonction de <string.h>

âœ… Tu dois :
- Utiliser une boucle while.
- Travailler sur chaque caractÃ¨re.
- GÃ©rer le \0 correctement.

ğŸ’¬ Bulle d'ami :

"Copier, c'est comme suivre fidÃ¨lement une partition de musique, sans se tromper de note."

ğŸ¯ Mini-TDD : tests minimalistes

CrÃ©e un fichier tests/tests_ft_strcpy.c :

ğŸ’¡ CrÃ©e toi-mÃªme un test pour vÃ©rifier que ft_strcpy("Hello") fonctionne. N'oublie pas le test avec une chaÃ®ne vide.
2. Ajout dâ€™un tableau de cas limites Ã  complÃ©ter par lâ€™Ã©lÃ¨ve :
Cas de test                     RÃ©sultat attendu                       Ã€ faire ?
ChaÃ®ne normale"Test"                "Test"                               ğŸ”²
ChaÃ®ne vide                         ""  ""                               ğŸ”²
ChaÃ®ne trÃ¨s longue                    ???                                ğŸ”²
src et dest sont Ã©gaux ?              ???                                ğŸ”²
src contient des caractÃ¨res spÃ©ciaux  ???                                ğŸ”²

ğŸ’¡ Bonus pÃ©dagogique : demande Ã  l'Ã©lÃ¨ve de remplir ce tableau avant de coder la fonction, pour lui apprendre Ã  penser comme un testeur.

ğŸ§± Structure recommandÃ©e :

```sh
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strcpy.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_strcpy.c
```
ğŸ’¡ Conseils :
- Utilise une variable int i = 0 pour parcourir src.
- Copie src[i] dans dest[i] jusquâ€™Ã  \0.
- Nâ€™oublie pas de copier le \0 final.

ğŸ“¦ Ajout Git obligatoire :

```bash
git add src/ft_strcpy.c tests/tests_ft_strcpy.c include/libft.h
git commit -m "Ajout de ft_strcpy avec tests TDD"
git commit -m "[feat] ft_strcpy: copie manuelle de chaÃ®ne avec TDD minimal"
```

ğŸ§© Convention Git pro : [feat], [fix], [refactor], [test], [doc], [chore]

ğŸ” DÃ©tail des balises :
Balise  Signification Exemple de message de commit
- [feat]  Nouvelle fonctionnalitÃ© [feat] ft_strcpy: copie manuelle de chaÃ®ne
- [fix] Correction de bug [fix] ft_strlen: corrige le comptage avec NULL
- [test]  Ajout ou modification de tests  [test] Ajoute des cas limites pour ft_strdup
- [refactor]  Refactorisation sans changer le comportement  [refactor] simplifie la boucle dans ft_strcmp
- [doc] Documentation, commentaires, README [doc] Ajoute explication dans README pour ft_strcpy
- [chore] TÃ¢che annexe (Makefile, structure, config)  [chore] Init projet + structure dossiers

ğŸ“˜ Exemple rÃ©el dans ton projet
````bash
git commit -m "[feat] ft_strdup: duplication dynamique avec malloc"
git commit -m "[test] ft_strdup: ajoute tests avec chaÃ®nes longues"
git commit -m "[doc] ft_strdup: ajoute explication dans README.md"
git commit -m "[refactor] ft_strcpy: simplifie copie caractÃ¨re par caractÃ¨re"
```
âœ¨ Bonus : format complet recommandÃ©
```bash
[type] nom_fichier: action courte au prÃ©sent
```
Tu peux ajouter une description plus longue avec git commit sans -m, dans un Ã©diteur.

ğŸ“Œ Ã€ retenir :
ğŸ”§ [feat] = nouvelle capacitÃ©
ğŸ›  [fix] = rÃ©paration
ğŸ”¬ [test] = ajout de tests
ğŸ§¹ [refactor] = nettoyage sans effet externe
ğŸ“– [doc] = changement de documentation
ğŸ§± [chore] = tout le reste (infra, config, etc.)

ğŸ GDB â€“ DÃ©bogage :
Compile ton test avec symboles debug :

```bash
gcc -g -Iinclude -o test_strcpy tests/tests_ft_strcpy.c src/ft_strcpy.c
```
Lance GDB :

```bash
gdb ./test_strcpy
```
Dans GDB :

```gdb
break ft_strcpy
run
step
print i
print dest
print src
continue
```
ğŸ” Reverse Engineering â€“ objdump + nm :
Afficher le code assembleur de ft_strcpy :

```bash
nm ./test_strcpy | grep ft_strcpy
# Exemple de sortie : 0000000000001139 T ft_strcpy

objdump -d ./test_strcpy | less
# Va Ã  l'adresse 0x1139 pour lire le code machine de ta fonction
```
ou via GDB :

âœ… Lire le code machine dans GDB (dÃ©sassemblage)
Lance ton programme dans GDB :

```bash
gdb ./test_strcpy
```
Trouve l'adresse de la fonction ft_strcpy :

```gdb
info functions ft_strcpy
```
ou directement :

```gdb
disassemble ft_strcpy
```
ğŸ’¡ Cela te montre le code assembleur gÃ©nÃ©rÃ© par le compilateur pour la fonction ft_strcpy.

ğŸ“Œ Exemple d'utilisation :
```bash
(gdb) break ft_strcpy
(gdb) run
(gdb) disassemble ft_strcpy
```
Tu verras une sortie comme :

```perl

Dump of assembler code for function ft_strcpy:
   0x0000000000001139 <+0>:   push   %rbp
   0x000000000000113a <+1>:   mov    %rsp,%rbp
   ...
End of assembler dump.
```
ğŸ” Bonus : Voir ligne par ligne l'exÃ©cution
AprÃ¨s le break et run :

```bash
(gdb) layout asm
````
Cela te donne une vue interactive du code assembleur dans certains GDB (notamment gdb-tui).

ğŸ“˜ README (optionnel mais pro) :
Ajoute un bloc dans README.md :

```md
### ft_strcpy

- But : Copier une chaÃ®ne dans une autre (char * -> char *).
- Cas limites testÃ©s :
  - ChaÃ®ne vide
  - ChaÃ®ne longue
- Commandes utilisÃ©es :
  - `gdb`, `objdump`, `nm`, `git`
- ComplexitÃ© : O(n)
```
ğŸ“Œ Ã€ retenir de cet exercice

- Chaque caractÃ¨re est une donnÃ©e Ã  part entiÃ¨re.
- Ne jamais oublier le \0 dans une chaÃ®ne C.
- GDB peut te montrer **exactement** ce que ta boucle fait.
- Le code machine rÃ©vÃ¨le comment ton code est traduit.
- Un bon test = un dÃ©veloppeur serein.

**ğŸ§  Le but :**
- Allouer une nouvelle chaÃ®ne de caractÃ¨res en mÃ©moire dynamique et y copier le contenu de `src`.

**ğŸ“Œ Prototype :**
```c
char *ft_strdup(const char *src);
```
ğŸ§ª Explication :

Calculer la longueur de src avec ft_strlen.
Allouer dynamiquement assez de mÃ©moire (malloc) pour y copier src (n caractÃ¨res + 1 pour \0).
Copier src dans le nouvel espace mÃ©moire avec ft_strcpy.
Retourner le pointeur vers la nouvelle chaÃ®ne.

ğŸ›‘ Interdictions :

âŒ strdup
âŒ Toute fonction de <string.h>
âŒ strlen, strcpy (sauf ft_ versions maison)

âœ… Tu dois :

Utiliser malloc
Appeler ft_strlen et ft_strcpy
VÃ©rifier que malloc ne retourne pas NULL
LibÃ©rer la mÃ©moire dans tes tests aprÃ¨s usage

ğŸ’¬ Bulle d'ami :

"Dupliquer, c'est offrir un clone fidÃ¨le, pas juste une imitation."

ğŸ¯ Mini-TDD â€“ Test de base :

CrÃ©e un fichier tests/tests_ft_strdup.c :

```c
#include <unistd.h>
#include "libft.h"

int main(void)
{
  ...
}
```
ğŸ§ª Tableau de Cas Limites â€“ Ã€ complÃ©ter par toi-mÃªme :

Cas de test RÃ©sultat attendu  Ã€ faire ?
src = "Hello" "Hello", nouvelle adresse ğŸ”²
src = ""  "", nouvelle adresse  ğŸ”²
src avec caractÃ¨res spÃ©ciaux  identique ğŸ”²
src trÃ¨s long identique, pas de segfault  ğŸ”²
malloc Ã©choue (cas thÃ©orique) NULL  ğŸ”²

ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_strdup.c tests/tests_ft_strdup.c include/libft.h
git commit -m "[feat] ft_strdup: duplication dynamique de chaÃ®ne"
```

ğŸ GDB â€“ Debug pas Ã  pas :

```bash
gcc -g -Iinclude -o test_strdup tests/tests_ft_strdup.c src/ft_strdup.c src/ft_strlen.c src/ft_strcpy.c
gdb ./test_strdup
```

```gdb
break ft_strdup
run
step
print src
print dest
continue
````
ğŸ” Reverse Engineering â€“ objdump + nm :

```bash
nm ./test_strdup | grep ft_strdup
objdump -d ./test_strdup | less
```
Ou directement dans GDB :

```gdb
disassemble ft_strdup
```
ğŸ“˜ README.md (optionnel mais pro) :

```md
### ft_strdup

- But : Dupliquer une chaÃ®ne en mÃ©moire dynamique.
- Cas limites testÃ©s :
  - ChaÃ®ne vide
  - ChaÃ®ne longue
  - Contenu binaire ou caractÃ¨res spÃ©ciaux
- Commandes utilisÃ©es :
  - `gdb`, `objdump`, `nm`, `git`
- ComplexitÃ© : O(n)
- MÃ©moire : Utilise `malloc`, penser Ã  `free`
```
ğŸ“Œ Ã€ retenir de cet exercice :

Une copie dynamique signifie un nouvel emplacement mÃ©moire.
Il est essentiel de libÃ©rer ce que malloc rÃ©serve.
ft_strdup tâ€™oblige Ã  penser gestion mÃ©moire + modularitÃ© (ft_strlen, ft_strcpy).
Observer lâ€™assembleur de ft_strdup te montre le chemin du malloc â†’ boucle de copie â†’ retour.

-------------------------------------------------
## 1.3) ft_strcmp
-------------------------------------------------

**ğŸ§  Le but :**
- Comparer deux chaÃ®nes de caractÃ¨res (`s1` et `s2`) caractÃ¨re par caractÃ¨re.
- Retourner :
  - `0` si elles sont Ã©gales,
  - Un **entier positif** si `s1 > s2`,
  - Un **entier nÃ©gatif** si `s1 < s2`.

**ğŸ“Œ Prototype :**
```c
int ft_strcmp(const char *s1, const char *s2);
```
ğŸ§ª Explication pÃ©dagogique :

On compare les caractÃ¨res Ã  la mÃªme position dans chaque chaÃ®ne :

Si les caractÃ¨res sont identiques, on continue.

Si un caractÃ¨re diffÃ¨re, on retourne la diffÃ©rence s1[i] - s2[i].

Si on atteint \0 sans diffÃ©rence : les chaÃ®nes sont Ã©gales â†’ on retourne 0.

ğŸ›‘ Interdictions :

âŒ strcmp (stdlib)

âŒ Toute fonction de <string.h>

âœ… Tu dois :

Utiliser une boucle while.

Comparer caractÃ¨re par caractÃ¨re.

Ne pas oublier le \0.

ğŸ’¬ Bulle d'ami :

"Comparer, c'est lire attentivement jusqu'Ã  voir une diffÃ©rence."

ğŸ¯ Mini-TDD â€” tests de base :

CrÃ©e ce fichier :

```bash
tests/tests_ft_strcmp.c
```
ğŸ§ª TDD Ã‰tendu â€” Ã  complÃ©ter toi-mÃªme :

Cas de test RÃ©sultat attendu  Ã€ faire ?
- "abc", "abc"  0 ğŸ”²
- "abc", "abd"  nÃ©gatif ğŸ”²
- "abc", "ab" positif ğŸ”²
- "", ""  0 ğŸ”²
- "Hello", "Hellp"  nÃ©gatif ğŸ”²
- "test", ""  positif ğŸ”²
- "AB", "ab"  nÃ©gatif (ASCII) ğŸ”²

ğŸ§± Structure recommandÃ©e :

```bash
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strcmp.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_strcmp.c
â”‚   â””â”€â”€ test_ft_strcmp.sh
```
ğŸ§ª Script de test automatisÃ© â€“ test_ft_strcmp.sh

```bash
#!/bin/bash
echo "ğŸ” Compilation de ft_strcmp..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strcmp tests/tests_ft_strcmp.c src/ft_strcmp.c
if [ $? -ne 0 ]; then
    echo "âŒ Compilation Ã©chouÃ©e."
    exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_strcmp
```
ğŸ’¡ Rends-le exÃ©cutable :

```bash
chmod +x tests/test_ft_strcmp.sh
./tests/test_ft_strcmp.sh
```
ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_strcmp.c tests/tests_ft_strcmp.c tests/test_ft_strcmp.sh include/libft.h
git commit -m "[feat] ft_strcmp: comparaison caractÃ¨re par caractÃ¨re avec TDD"
```
ğŸ§© Convention Git pro utilisÃ©e :

Balise  Signification
[feat]  Nouvelle fonctionnalitÃ©
[test]  Ajout de tests
[doc] Documentation (README, commentaires, etc.)
[chore] Fichiers annexes (Makefile, scripts, configs)

ğŸ Debug via GDB :

```bash
gcc -g -Iinclude -o test_cmp tests/tests_ft_strcmp.c src/ft_strcmp.c
gdb ./test_cmp
```
Dans GDB :

```gdb
break ft_strcmp
run
step
print s1[i]
print s2[i]
```
ğŸ” Reverse Engineering â€“ objdump + nm :

```bash

nm ./test_cmp | grep ft_strcmp
objdump -d ./test_cmp | less
```
Dans GDB :

```gdb
disassemble ft_strcmp
````
ğŸ“˜ README.md (optionnel mais pro) :

```md
### ft_strcmp

- But : Comparer deux chaÃ®nes et retourner la diffÃ©rence du premier caractÃ¨re distinct.
- Cas limites testÃ©s :
  - ChaÃ®nes identiques
  - ChaÃ®ne vide vs non vide
  - DiffÃ©rence Ã  la fin
- Outils : gdb, objdump, nm, test .sh
- ComplexitÃ© : O(n)
```

ğŸ“Œ Ã€ retenir de cet exercice :

Le retour peut Ãªtre nÃ©gatif, nul ou positif, comme dans strcmp.
L'ordre ASCII est important : 'A' < 'a'.
Le \0 compte aussi dans la comparaison.
Tu compares des unsigned char, donc attention aux signes nÃ©gatifs inattendus (bonus).

-------------------------------------------------
## 1.4) ft_strncpy
-------------------------------------------------
**ğŸ§  Le but :**
- Copier jusquâ€™Ã  `n` caractÃ¨res depuis `src` vers `dest`.
- Si `src` est plus courte que `n`, remplir les caractÃ¨res restants avec `\0`.

**ğŸ“Œ Prototype :**
```c
char *ft_strncpy(char *dest, const char *src, size_t n);
```
ğŸ§ª Explication pÃ©dagogique :

Tu parcours la chaÃ®ne src et copies chaque caractÃ¨re dans dest, jusquâ€™Ã  n caractÃ¨res maximum.
Si src fait moins de n, tu dois complÃ©ter dest avec des \0.
La fonction retourne dest.

ğŸ›‘ Interdictions :

âŒ strncpy (stdlib)
âŒ Toute fonction de <string.h>

âœ… Tu dois :

Utiliser une boucle while ou for.
GÃ©rer les cas oÃ¹ src < n.
Ajouter les \0 restants toi-mÃªme.

ğŸ’¬ Bulle d'ami :

"ÃŠtre prÃ©cis, câ€™est aussi savoir sâ€™arrÃªter au bon moment, et ne rien laisser au hasard."

ğŸ¯ Mini-TDD â€“ tests de base :

CrÃ©e ce fichier de test :

```bash
tests/tests_ft_strncpy.c
```
ğŸ’¡ Contenu minimaliste :

```c
#include <unistd.h>
#include "libft.h"

int main(void)
{
  ...
}
```
ğŸ§ª TDD Ã‰tendu â€” Ã  complÃ©ter :

Cas de test RÃ©sultat attendu  Ã€ faire ?
- "abc", n = 5  "abc\0\0"                   ğŸ”²
- "abc", n = 3  "abc"                       ğŸ”²
- "abc", n = 1  "a"                         ğŸ”²
- "", n = 3 "\0\0\0"                        ğŸ”²
- ChaÃ®ne longue, n petit  dÃ©but seulement   ğŸ”²

ğŸ§± Structure recommandÃ©e :

```css
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strncpy.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_strncpy.c
â”‚   â””â”€â”€ test_ft_strncpy.sh
```
ğŸ§ª Script de test automatisÃ© â€” test_ft_strncpy.sh :

```bash
#!/bin/bash
echo "ğŸ” Compilation de ft_strncpy..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strncpy tests/tests_ft_strncpy.c src/ft_strncpy.c
if [ $? -ne 0 ]; then
    echo "âŒ Compilation Ã©chouÃ©e."
    exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_strncpy
```
ğŸ’¡ Rends-le exÃ©cutable :

```bash
chmod +x tests/test_ft_strncpy.sh
./tests/test_ft_strncpy.sh
```
ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_strncpy.c tests/tests_ft_strncpy.c tests/test_ft_strncpy.sh include/libft.h
git commit -m "[feat] ft_strncpy: copie limitÃ©e Ã  n caractÃ¨res avec complÃ©tion \\0"
```
ğŸ§© Rappel Convention Git pro :

Balise  Signification
- [feat]  Nouvelle fonctionnalitÃ©
- [test]  Ajout de tests
- [refactor]  Refactorisation du code sans changer le rÃ©sultat
- [doc] Documentation (README, commentaires, etc.)
- [chore] TÃ¢che annexe (scripts, Makefile, arborescence)

ğŸ GDB â€“ Debug pas Ã  pas :

```bash
gcc -g -Iinclude -o test_ncpy tests/tests_ft_strncpy.c src/ft_strncpy.c
gdb ./test_ncpy
```
Dans GDB :

```gdb
break ft_strncpy
run
step
print src[i]
print dest[i]
```
ğŸ” Reverse Engineering â€” objdump + nm :

```bash
nm ./test_ncpy | grep ft_strncpy
objdump -d ./test_ncpy | less
```
ou dans GDB :

```gdb
disassemble ft_strncpy
```
ğŸ“˜ README.md (optionnel mais pro) :

```md

### ft_strncpy

- But : Copier n caractÃ¨res depuis une chaÃ®ne source.
- ParticularitÃ© : ComplÃ¨te par \0 si la source est plus courte.
- Cas limites testÃ©s :
  - n > taille source
  - n < taille source
  - chaÃ®ne vide
- Commandes utilisÃ©es :
  - `gdb`, `objdump`, `nm`, `git`, test .sh
- ComplexitÃ© : O(n)
```

ğŸ“Œ Ã€ retenir :

Tu dois remplir avec des \0 si la chaÃ®ne source est plus courte.

Ta fonction doit toujours copier n caractÃ¨res exactement.

Attention aux zones non remplies si tu oublies les \0.

-------------------------------------------------
# Bloc 2 â€” Libft++ BoostÃ©e â€” Partie 2/? [ğŸŸ¢ Facile]
-------------------------------------------------
ğŸ“š Introduction rapide Partie 2
Ici, on entre dans un univers encore plus bas niveau :
â” Manipuler directement la mÃ©moire (memset, bzero, memcpy, etc.)

Ton cerveau doit maintenant penser comme la mÃ©moire :
octet par octet, sans erreur.

ğŸ“š Fonctions de cette Partie 2

-------------------------------------------------
## 2.0) ft_memset
-------------------------------------------------
ğŸ§  Le but :
Remplir un bloc mÃ©moire avec une valeur donnÃ©e, octet par octet.

ğŸ“Œ Prototype :

```c
void *ft_memset(void *b, int c, size_t len);
```
ğŸ§ª Explication pÃ©dagogique :
Tu dois parcourir len octets Ã  partir de b, et Ã©crire la valeur c castÃ©e en unsigned char dans chacun.
Cette fonction est trÃ¨s utilisÃ©e pour initialiser un buffer, effacer une structure, ou prÃ©parer un tableau.
Elle retourne b, ce qui permet de chaÃ®ner les appels (ex: if (ft_memset(...)) {...}).

ğŸ›‘ Interdictions :

âŒ memset()
âŒ bzero()
âŒ Toute fonction de <string.h>

âœ… Tu dois :

Utiliser une boucle while ou for
Caster correctement le pointeur void * en unsigned char *
Ã‰crire sur chaque octet exactement une fois

ğŸ’¬ Bulle d'ami :

â€œPeindre toute une piÃ¨ce dâ€™une seule couleurâ€¦ sans dÃ©border, sans oublier un coin.â€

ğŸ¯ Mini-TDD â€“ Test de base

Remplir un tableau de 10 caractÃ¨res avec 'A' et afficher chaque caractÃ¨re entre crochets :

```c
#include <unistd.h>
#include "libft.h"

int main(void)
{
  ...
}
```
ğŸ§ª TDD Ã‰tendu â€” Cas Ã  tester

Cas RÃ©sultat attendu  Ã€ faire
ft_memset(buffer, 'A', 10)  [A][A][A][A][A][A][A][A][A][A]  ğŸ”²
ft_memset(buffer, 0, 5) [\\0][\\0][\\0][\\0][\\0]...        ğŸ”²
ft_memset(buffer, 'Z', 0) Rien ne change                    ğŸ”²
ft_memset(NULL, 'X', 0) AutorisÃ© (comportement dÃ©fini en C) ğŸ”²
ft_memset(buffer, 257, 3) InterprÃ©tÃ© comme (unsigned char)1 ğŸ”²

ğŸ§± Structure recommandÃ©e :

```css
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_memset.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_memset.c
â”‚   â””â”€â”€ test_ft_memset.sh
```
ğŸ§ª Script de test automatisÃ© â€” test_ft_memset.sh

```bash
#!/bin/bash
echo "ğŸ”§ Compilation de ft_memset..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memset tests/tests_ft_memset.c src/ft_memset.c
if [ $? -ne 0 ]; then
    echo "âŒ Compilation Ã©chouÃ©e."
    exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_memset
```
ğŸ’¡ Rends-le exÃ©cutable :

```bash

chmod +x tests/test_ft_memset.sh
./tests/test_ft_memset.sh
````

ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_memset.c tests/tests_ft_memset.c tests/test_ft_memset.sh include/libft.h
git commit -m "[feat] ft_memset: remplissage mÃ©moire octet par octet"
```
ğŸ Debug pas Ã  pas avec GDB :

```bash
gcc -g -Iinclude -o test_memset tests/tests_ft_memset.c src/ft_memset.c
gdb ./test_memset
```
Dans GDB :

```gdb
break ft_memset
run
step
print i
print ((unsigned char *)b)[i]
```
ğŸ” Reverse Engineering (analyse mÃ©moire et binaire).

```bash
nm ./test_memset | grep ft_memset
objdump -d ./test_memset | less
````

ou dans GDB :.

```gdb
disassemble ft_memset
```
ğŸ“˜ README.md (pro)

```md
### ft_memset

- But : Remplir un bloc mÃ©moire de `len` octets avec l'octet `c`.
- UtilitÃ© : Initialisation, nettoyage, patterns mÃ©moire.
- Retour : Le pointeur original (`b`), pour permettre le chaÃ®nage.
- Cas gÃ©rÃ©s :
  - `len = 0` â†’ aucun changement
  - `c > 255` â†’ conversion automatique en `unsigned char`
- Outils : `GDB`, `nm`, `objdump`, `test.sh`, Git
- ComplexitÃ© : O(n)
```
ğŸ“Œ Ã€ retenir :

Le pointeur `void *` doit Ãªtre converti en `unsigned char *` pour Ã©crire des octets.
La fonction doit Ã©crire exactement len octets.
Toujours retourner b pour respecter la norme POSIX.
Ne jamais utiliser la fonction `memset()` native.

ğŸ”¬ Bonus Reverse Engineering â€” DÃ©crypter lâ€™ASM

ğŸ’¡ Astuce : dans `objdump` ou `gdb`, cherche les instructions suivantes :
- `mov` : transfert de la valeur c dans une case mÃ©moire
- `cmp`, `dec`, `jnz` `loop`: gestion de la boucle (souvent dans `for`)
- `rep stosb` (optimisation sur x86) : instruction spÃ©ciale pour memset natif
- le cast implicite vers unsigned char (visible dans les registres comme `al`, `rdi`, `rsi`)

ğŸ“Œ Exemple typique Ã  reconnaÃ®tre :
```asm
mov    BYTE PTR [rdi],al   ; copie de l'octet 'c' dans la mÃ©moire pointÃ©e
inc    rdi                 ; passage Ã  lâ€™octet suivant
dec    rdx                 ; dÃ©crÃ©mentation du compteur
jnz    ...                 ; saut si compteur != 0
```
ğŸ“ GDB TUI (Terminal User Interface) :

```bash
(gdb) layout asm
```
âœ Cela ouvre un affichage interactif du code assembleur ligne par ligne.

Lien conceptuel entre C et assembleur :
âœ Rajoute un encart pÃ©dagogique :

ğŸ“š â€œQuand tu Ã©cris une boucle en C, le compilateur gÃ©nÃ¨re des instructions machines pour cette boucle : typiquement une comparaison (cmp), une dÃ©crÃ©mentation (dec) et un saut conditionnel (jnz).â€

-------------------------------------------------
## 2.1) ft_bzero
-------------------------------------------------
ğŸ§  Le but :
Mettre Ã  zÃ©ro une zone mÃ©moire, octet par octet, de faÃ§on sÃ©curisÃ©e et explicite.

ğŸ“Œ Prototype :

```c
void ft_bzero(void *s, size_t n);
```
ğŸ§ª Explication pÃ©dagogique :
Tu dois Ã©crire n octets Ã  la valeur 0 dans la mÃ©moire pointÃ©e par s.
Cela correspond Ã  mettre tous les octets Ã  '\0', souvent utilisÃ© pour effacer ou initialiser des buffers.

ğŸ“Œ Cette fonction est trÃ¨s utile :

Avant un malloc non initialisÃ©
Avant d'utiliser une structure
Pour remettre un tableau Ã  zÃ©ro

ğŸ›‘ Interdictions :

âŒ bzero()
âŒ Toute fonction de <string.h> (autre que ta propre ft_memset)

âœ… Tu dois :

Soit utiliser ta propre ft_memset() si elle est codÃ©e
Soit tout rÃ©Ã©crire manuellement, avec une boucle, comme un memset avec c = 0
Toujours respecter les pointeurs et les types

ğŸ’¬ Bulle d'ami :

â€œEffacer sans laisser de traceâ€¦ mÃªme dans les coins sombres.â€

ğŸ¯ Mini-TDD â€“ Test de base

CrÃ©er un tableau de 10 caractÃ¨res, lâ€™effacer avec ft_bzero(), puis afficher chaque caractÃ¨re pour vÃ©rifier quâ€™il vaut bien \0 :

```c
#include <unistd.h>
#include "libft.h"

int main(void)
{
  ...
}
```
ğŸ§ª TDD Ã‰tendu â€” Cas Ã  tester

Cas RÃ©sultat attendu  Ã€ faire
ft_bzero(buffer, 10)  [0][0][0][0][0][0][0][0][0][0]  âœ…
ft_bzero(buffer, 0) Rien ne change  âœ…
ft_bzero(NULL, 0) Comportement dÃ©fini : OK  âœ…
ft_bzero(buffer + 3, 2) Seuls indices 3 et 4 remis Ã  zÃ©ro âœ…
Utilisation dans une structure  Tous les champs initialisÃ©s Ã  0 âœ…

ğŸ§± Structure recommandÃ©e :

```css
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_bzero.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_bzero.c
â”‚   â””â”€â”€ test_ft_bzero.sh
```
ğŸ§ª Script de test automatisÃ© â€” test_ft_bzero.sh

```bash
#!/bin/bash
echo "ğŸ”§ Compilation de ft_bzero..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_bzero tests/tests_ft_bzero.c src/ft_bzero.c src/ft_memset.c
if [ $? -ne 0 ]; then
    echo "âŒ Compilation Ã©chouÃ©e."
    exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_bzero
```
ğŸ’¡ Rends-le exÃ©cutable :

```bash
chmod +x tests/test_ft_bzero.sh
./tests/test_ft_bzero.sh
```
ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_bzero.c tests/tests_ft_bzero.c tests/test_ft_bzero.sh include/libft.h
git commit -m "[feat] ft_bzero: mise Ã  zÃ©ro dâ€™une zone mÃ©moire"
```
ğŸ Debug pas Ã  pas avec GDB :

```bash
gcc -g -Iinclude -o test_bzero tests/tests_ft_bzero.c src/ft_bzero.c src/ft_memset.c
gdb ./test_bzero
```
Dans GDB :

```gdb
break ft_bzero
run
step
print i
print ((unsigned char *)s)[i]
```
ğŸ” Reverse Engineering (analyse assembleur)

```bash
nm ./test_bzero | grep ft_bzero
objdump -d ./test_bzero | less
```
ou dans GDB :

```gdb
disassemble ft_bzero
```
ğŸ“˜ README.md (bonus pro)

```md
### ft_bzero

- But : Mettre Ã  zÃ©ro une zone mÃ©moire (remplir avec `\0`)
- UtilitÃ© : Initialiser des tableaux, structures ou buffers
- Comportement : Ne fait rien si `n == 0`
- ImplÃ©mentation : Soit avec `ft_memset(s, 0, n)` si dispo, soit manuelle
- Outils : `GDB`, `objdump`, `nm`, `test.sh`, Git
- ComplexitÃ© : O(n)
```
ğŸ“Œ Ã€ retenir :

ft_bzero() est Ã©quivalent Ã  ft_memset(s, 0, n)
Elle ne retourne rien (void), contrairement Ã  memset
Elle est utile pour remettre Ã  zÃ©ro sans rÃ©allocation
n == 0 âœ ne fait rien
Tu peux l'utiliser dans des struct, tableaux, etc.

ğŸ”¬ Bonus Reverse Engineering â€” DÃ©crypter lâ€™ASM

ğŸ’¡ Astuce : dans objdump ou gdb, tu peux retrouver ces instructions :

mov BYTE PTR [rdi], 0x0 âœ Ã©criture explicite du zÃ©ro
loop / jnz / dec âœ gestion de la boucle
rep stosb âœ optimisÃ© si memset est appelÃ© (selon l'implÃ©mentation)

ğŸ“š Exemple typique :

```asm
mov    BYTE PTR [rdi], 0x0   ; mise Ã  zÃ©ro dâ€™un octet
inc    rdi                   ; avance dâ€™un octet
dec    rdx                   ; dÃ©crÃ©mente le compteur
jnz    ...                   ; boucle jusquâ€™Ã  0
```
ğŸ“ GDB TUI :

```bash
(gdb) layout asm
```
âœ Affichage interactif ligne par ligne du code assembleur gÃ©nÃ©rÃ© par ft_bzero

ğŸ“š Lien conceptuel C â†’ Assembleur :

â€œQuand tu Ã©cris une boucle for ou while en C, le compilateur gÃ©nÃ¨re des instructions bas niveau : cmp, dec, jnz, et des
opÃ©rations mov sur la mÃ©moire. Comprendre Ã§a tâ€™aide Ã  visualiser ce que fait rÃ©ellement ton code, octet par octet.â€

-------------------------------------------------
## 2.2) ft_memcpy
-------------------------------------------------
ğŸ§  Le but :
Copier exactement n octets depuis une zone mÃ©moire src vers une zone mÃ©moire dst.
Contrairement Ã  memmove, ft_memcpy ne doit PAS gÃ©rer le chevauchement.

ğŸ“Œ Prototype :

```c
void *ft_memcpy(void *dst, const void *src, size_t n);
```
ğŸ§ª Explication pÃ©dagogique :

Tu dois parcourir chaque octet un par un.
Copier n octets de src vers dst Ã  l'identique.
Ne gÃ¨re aucun chevauchement (src et dst ne doivent pas se superposer).
Tu dois caster void * en unsigned char * pour manipuler les octets.
Retourne dst.

ğŸ›‘ Interdictions :

âŒ memcpy()
âŒ Toute fonction de <string.h>

âœ… Tu dois :

Travailler octet par octet
Bien caster les pointeurs
Ne pas utiliser de fonction standard
Retourner dst Ã  la fin

ğŸ’¬ Bulle d'ami :
"Copier, câ€™est comme transvaser de lâ€™eau entre deux verresâ€¦ sans mÃ©langer, sans dÃ©passer, sans chevauchement."

ğŸ¯ Mini-TDD â€” Test simple

CrÃ©e tests/tests_ft_memcpy.c :

```c
#include <unistd .h>
#include "libft.h"

void  ft_putchar(char c)
{
  write(1, &c, 1);
}

void  ft_putstr(char *s)
{
  int i = 0;
  while (s[i])
    ft_putchar(s[i++]);
}

int main(void)
{
  ...
}
```
ğŸ§ª TDD Ã‰tendu â€” Cas Ã  tester

Cas RÃ©sultat attendu  Ã€ faire
ft_memcpy(dest, src, 5) "Hello"                       ğŸ”²
ft_memcpy(dest, src, 0) Rien ne change                ğŸ”²
ft_memcpy(dest, NULL, 5)  âš ï¸ comportement indÃ©fini   ğŸ”²
ft_memcpy(NULL, src, 5) âš ï¸ comportement indÃ©fini     ğŸ”²
ft_memcpy(NULL, NULL, 0)  DÃ©fini : OK                 ğŸ”²

â¡ï¸ Bonus : Ajoute un fichier expected_memcpy.txt contenant :

```txt
RÃ©sultat : [Hello]
```

ğŸ§± Structure recommandÃ©e :

```css
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_memcpy.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_memcpy.c
â”‚   â””â”€â”€ test_ft_memcpy.sh
â”‚   â””â”€â”€ expected_memcpy.txt
```
ğŸ§ª Script de test automatisÃ© â€” test_ft_memcpy.sh

```bash
#!/bin/bash
echo "ğŸ”§ Compilation de ft_memcpy..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memcpy tests/tests_ft_memcpy.c src/ft_memcpy.c

if [ $? -ne 0 ]; then
    echo "âŒ Compilation Ã©chouÃ©e."
    exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_memcpy > result.txt
diff result.txt tests/expected_memcpy.txt && echo "âœ… OK" || echo "âŒ DiffÃ©rence dÃ©tectÃ©e"

```
diff -u result.txt tests/expected_memcpy.txt || echo "âŒ DiffÃ©rences dÃ©tectÃ©es dans la sortie"

Rends-le exÃ©cutable :

```bash
chmod +x tests/test_ft_memcpy.sh
./tests/test_ft_memcpy.sh
```
ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_memcpy.c tests/tests_ft_memcpy.c tests/test_ft_memcpy.sh tests/expected_memcpy.txt include/libft.h
git commit -m "[feat] ft_memcpy: copie mÃ©moire byte par byte avec TDD"
```
Conventions recommandÃ©es :

Tag Git Signification
- [feat]  Ajout dâ€™une nouvelle fonction
- [test]  Ajout ou correction de test
- [fix] Correction de bug
- [doc] Commentaire ou documentation
- [chore] TÃ¢che annexe (script, nettoyage, etc)

ğŸ Debug pas Ã  pas avec GDB :

```bash
gcc -g -Iinclude -o test_memcpy tests/tests_ft_memcpy.c src/ft_memcpy.c
gdb ./test_memcpy
```
Dans GDB :

```gdb
break ft_memcpy
run
step
print i
print ((unsigned char *)dst)[i]
```
ğŸ§  Astuce :
Tu peux voir la mÃ©moire directement :

```gdb
x/10cb dst
```
Affiche 10 octets consÃ©cutifs Ã  partir de dst.

ğŸ” Reverse Engineering â€” Analyse assembleur :

```bash
nm ./test_memcpy | grep ft_memcpy
objdump -d ./test_memcpy | less
```
Ou dans GDB :

```gdb
disassemble ft_memcpy
```
ğŸ” Recherche dans le code assembleur :

- mov BYTE PTR [rdi], al : copie dâ€™un octet
- inc rdi / rsi : dÃ©placement pointeurs source/destination
- cmp / dec / jnz : boucle de copie
- Pas de rep movsb ici car ce serait une optimisation interne Ã  memcpy du compilateur

ğŸ’¡ Tu verras typiquement :

```asm
mov    al,BYTE PTR [rsi]   ; lecture source
mov    BYTE PTR [rdi],al   ; Ã©criture destination
inc    rdi                 ; avance
inc    rsi
dec    rdx
jnz    ...
````

ğŸ“˜ README.md (bonus pro)

```md
### ft_memcpy

- But : Copier `n` octets dâ€™une source vers une destination, sans chevauchement.
- UtilitÃ© : Transfert mÃ©moire rapide et contrÃ´lÃ©.
- Cas gÃ©rÃ©s :
  - `n == 0` â†’ ne fait rien
  - `src == NULL` ou `dst == NULL` â†’ comportement indÃ©fini sauf si `n == 0`
- Outils : `GDB`, `objdump`, `nm`, `test.sh`, Git
- ComplexitÃ© : O(n)
````
ğŸ“Œ Ã€ retenir :
Toujours caster `void *` en `(unsigned char *)` pour copier octet par octet.

Ne pas gÃ©rer de chevauchement (ce sera pour memmove).
memcpy nâ€™est pas sÃ»r si src et dst se recoupent.
Retourne dst pour permettre le chaÃ®nage.
Lire les instructions mov, rep movsb en ASM peut rÃ©vÃ©ler des optimisations natives.

ğŸ“š Lien C â†’ ASM :
"Le compilateur convertit ta boucle C en une suite dâ€™instructions bas niveau : souvent un mov pour copier, et une boucle avec dec, cmp, jnz. Comprendre Ã§a, câ€™est toucher la mÃ©canique rÃ©elle de la mÃ©moire."

-------------------------------------------------
## 2.3) ft_memmove
-------------------------------------------------
ğŸ§  Le but :
Copier `len` octets dâ€™une zone mÃ©moire `src` vers `dst`, **mÃªme en cas de chevauchement**.

ğŸ“Œ Prototype :
```c
void *ft_memmove(void *dst, const void *src, size_t len);
```
ğŸ§ª Explication pÃ©dagogique :

Contrairement Ã  ft_memcpy, cette fonction doit gÃ©rer les cas oÃ¹ les zones mÃ©moire se recoupent.
Tu dois tester si dst > src, et si câ€™est le cas, copier en partant de la fin.
Sinon, tu copies en partant du dÃ©but, comme memcpy.
Tu dois caster les `void *` en `unsigned char *`.
La fonction retourne toujours dst.

ğŸ›‘ Interdictions :

âŒ memmove()
âŒ Toute fonction de <string.h>

âœ… Copie manuelle, logique de chevauchement incluse
âœ… Pas de #include <stdio.h> (respect norme 42)

ğŸ’¬ Bulle dâ€™ami :
"DÃ©placer sans Ã©craser, câ€™est savoir dans quel sens danser avec les octets."

ğŸ¯ Mini-TDD â€” Cas de test simple

CrÃ©e tests/tests_ft_memmove.c :

```c

#include <unistd.h>
#include "libft.h"

void ft_putchar(char c) 
{
  write(1, &c, 1);
}
void ft_putstr(char *s)
{
  int i = 0;
  while (s[i])
    ft_putchar(s[i++]);
}

int main(void)
{
  ...
}
```

ğŸ§ª TDD Ã‰tendu â€” Cas recommandÃ©s

Test  RÃ©sultat attendu
memmove(dst, src, 0)  Rien ne change
memmove(dst, src, 5)  Copie normale
memmove(dst, dst, 5)  Ne fait rien
memmove(dst+2, dst, 5)  Copie vers lâ€™avant avec chevauchement
memmove(dst, dst+2, 5)  Copie vers lâ€™arriÃ¨re avec chevauchement
memmove(NULL, NULL, 0)  OK

â¡ï¸ Bonus : Ajoute tests/expected_memmove.txt :

```txt
RÃ©sultat : [ababcdehij]
```
ğŸ§± Structure recommandÃ©e :

```css
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_memmove.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_memmove.c
â”‚   â””â”€â”€ test_ft_memmove.sh
â”‚   â””â”€â”€ expected_memmove.txt
```

ğŸ§ª Script de test automatisÃ© â€” test_ft_memmove.sh :

```bash
#!/bin/bash
echo "ğŸ”§ Compilation de ft_memmove..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memmove tests/tests_ft_memmove.c src/ft_memmove.c

if [ $? -ne 0 ]; then
    echo "âŒ Compilation Ã©chouÃ©e."
    exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_memmove > result.txt
diff -u result.txt tests/expected_memmove.txt && echo "âœ… OK" || echo "âŒ DiffÃ©rences dÃ©tectÃ©es"
```
ğŸ’¡ Rends-le exÃ©cutable :

```bash
chmod +x tests/test_ft_memmove.sh
./tests/test_ft_memmove.sh
```
ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_memmove.c tests/tests_ft_memmove.c tests/test_ft_memmove.sh tests/expected_memmove.txt include/libft.h
git commit -m "[feat] ft_memmove: gestion des copies avec chevauchement + TDD"
```
ğŸ§© Convention Git Pro :

Tag RÃ´le
- [feat]  Ajout de ft_memmove
- [test]  Ajout des tests automatisÃ©s
- [fix] Correction dâ€™un bug
- [doc] Documentation / README
- [chore] Script ou maintenance annexe

ğŸ GDB â€” Debug pas Ã  pas :

```bash
gcc -g -Iinclude -o test_memmove tests/tests_ft_memmove.c src/ft_memmove.c
gdb ./test_memmove
```

Dans GDB :

```gdb
break ft_memmove
run
step
print i
print ((unsigned char *)dst)[i]
x/10cb dst
```
ğŸ” Reverse Engineering â€” Analyse ASM :

```bash
nm ./test_memmove | grep ft_memmove
objdump -d ./test_memmove | less
```
Ou dans GDB :

```gdb
disassemble ft_memmove
```
ğŸ’¡ Ce que tu verras :
Si copie avant â†’ boucle normale
Si copie arriÃ¨re â†’ boucle dÃ©crÃ©mentÃ©e, mov en arriÃ¨re
Pas de rep movsb ici : câ€™est notre version manuelle.

ğŸ“˜ README.md (bonus pro) :

```md
### ft_memmove

- But : Copier `n` octets entre deux zones mÃ©moire, mÃªme si elles se chevauchent.
- Cas gÃ©rÃ©s :
  - `n == 0` â†’ ne fait rien
  - `dst == src` â†’ pas dâ€™opÃ©ration
  - `src < dst` â†’ copie de droite Ã  gauche
  - `src > dst` â†’ copie de gauche Ã  droite
- Outils utilisÃ©s : `GDB`, `objdump`, `nm`, `test.sh`
- ComplexitÃ© : O(n)
```
ğŸ“Œ Ã€ retenir :

Ne pas Ã©craser la source lors du recouvrement.
Bien tester les 2 sens de recouvrement.
Toujours caster les `void *` en `unsigned char *`.
Retourner dst Ã  la fin.

ğŸ“š Lien C â†’ Assembleur :
"Le sens de la copie se traduit dans le code machine : selon que tu parcours Ã  lâ€™endroit ou Ã  lâ€™envers, le compilateur
produit deux boucles diffÃ©rentes. Observer cela dans objdump te rÃ©vÃ¨le les optimisations cachÃ©es du langage C."

-------------------------------------------------
## 2.4) ft_memchr
-------------------------------------------------
ğŸ§  Le but :
Chercher un octet `c` dans les `n` premiers octets de la zone mÃ©moire `s`.

ğŸ“Œ Prototype :

```c
void *ft_memchr(const void *s, int c, size_t n);
```
ğŸ§ª Explication pÃ©dagogique :

Tu dois parcourir octet par octet la zone mÃ©moire pointÃ©e par s sur n octets.
Ã€ chaque itÃ©ration, tu compares le contenu avec la valeur de c (castÃ©e en unsigned char).
Si tu trouves une correspondance, tu retournes un pointeur vers cet octet.
Sinon, tu retournes NULL.

âš ï¸ c est un int mais comparÃ© comme un unsigned char.

ğŸ›‘ Interdictions :

âŒ memchr()
âŒ Toute fonction de <string.h>
âŒ #include <stdio.h> (interdit Ã  42)

âœ… Tu dois :

âœ”ï¸ Travailler octet par octet
âœ”ï¸ Retourner un pointeur vers l'octet trouvÃ©
âœ”ï¸ Caster les pointeurs `((unsigned char *))`

ğŸ’¬ Bulle d'ami :
"Explorer octet par octet, comme un chercheur dâ€™or qui sâ€™arrÃªte dÃ¨s quâ€™il voit briller."

ğŸ¯ Mini-TDD â€” Cas de test simple

CrÃ©e tests/tests_ft_memchr.c :

```c
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putstr(char *s);

int main(void)
{
  ...
}
```
ğŸ§ª TDD Ã‰tendu â€” Cas recommandÃ©s

Test  RÃ©sultat attendu
ft_memchr("hello", 'o', 5)  Renvoie un pointeur vers 'o'
ft_memchr("hello", 'l', 5)  Renvoie le premier 'l'
ft_memchr("hello", 'z', 5)  NULL
ft_memchr("abcabc", 'a', 2) Trouve 'a' Ã  la premiÃ¨re position
ft_memchr(NULL, 'a', 0) OK (pas d'accÃ¨s mÃ©moire)
ft_memchr(NULL, 'a', 5) âš ï¸ Comportement indÃ©fini

â¡ï¸ Bonus : CrÃ©e tests/expected_memchr.txt :

```txt
RÃ©sultat : [o]
```
ğŸ§± Structure recommandÃ©e :

```css
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_memchr.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_memchr.c
â”‚   â””â”€â”€ test_ft_memchr.sh
â”‚   â””â”€â”€ expected_memchr.txt
```

ğŸ§ª Script de test automatisÃ© â€” test_ft_memchr.sh

```bash
#!/bin/bash
echo "ğŸ”§ Compilation de ft_memchr..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memchr tests/tests_ft_memchr.c src/ft_memchr.c

if [ $? -ne 0 ]; then
  echo "âŒ Compilation Ã©chouÃ©e."
  exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_memchr > result.txt
diff -u result.txt tests/expected_memchr.txt && echo "âœ… OK" || echo "âŒ DiffÃ©rences dÃ©tectÃ©es"
```
```bash
chmod +x tests/test_ft_memchr.sh
./tests/test_ft_memchr.sh
```
ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_memchr.c tests/tests_ft_memchr.c tests/test_ft_memchr.sh tests/expected_memchr.txt include/libft.h
git commit -m "[feat] ft_memchr: recherche octet en mÃ©moire + TDD"
```
ğŸ§© Convention Git Pro :

Tag Description
- [feat]  Nouvelle fonction ajoutÃ©e
- [test]  Script ou fichier de test
- [fix] Correction d'un bug
- [doc] Documentation ou README
- [chore] Maintenance, Makefile, etc

ğŸ GDB â€” Debug pas Ã  pas :

```bash
gcc -g -Iinclude -o test_memchr tests/tests_ft_memchr.c src/ft_memchr.c
gdb ./test_memchr
```
Dans GDB :

```gdb
break ft_memchr
run
step
print i
print ((unsigned char *)s)[i]
x/10cb s
```

ğŸ” Reverse Engineering â€” Analyse ASM :

```bash
nm ./test_memchr | grep ft_memchr
objdump -d ./test_memchr | less
```

Ou directement dans GDB :

```gdb
disassemble ft_memchr
```

ğŸ’¡ Regarde si le compilateur utilise cmp, mov, loop, ret.

ğŸ“˜ README.md (bonus pro) :

```md
### ft_memchr

- But : Chercher un octet `c` dans les `n` premiers octets de `s`
- Cas gÃ©rÃ©s :
  - Octet trouvÃ© â†’ pointeur retournÃ©
  - Octet absent â†’ NULL
  - `n == 0` â†’ retourne NULL
  - `s == NULL` â†’ comportement indÃ©fini sauf si `n == 0`
- Outils utilisÃ©s : `GDB`, `objdump`, `nm`, `diff`, Git
- ComplexitÃ© : O(n)
```

ğŸ“Œ Ã€ retenir :

Toujours caster `(void *)` en `(unsigned char *)` pour comparaison octet par octet
Retourne un pointeur vers la premiÃ¨re occurrence
int c est comparÃ© comme unsigned char
Si pas trouvÃ©, retourne NULL

ğŸ“š Lien C â†’ ASM :

"Une simple boucle avec cmp, mov, inc, jnz.
Mais cette routine est au cÅ“ur de toutes les recherches mÃ©moire rapides."

-------------------------------------------------
ğŸ“š RÃ©capitulatif rapide Partie 2 :

Fonction Ce que tu dois savoir faire
ft_memset Remplir une zone mÃ©moire
ft_bzero Mettre Ã  zÃ©ro une zone mÃ©moire
ft_memcpy Copier une zone mÃ©moire sans collision
ft_memmove Copier une zone mÃ©moire en gÃ©rant la collision
ft_memchr Chercher un octet prÃ©cis en mÃ©moire

-------------------------------------------------
# Bloc 2 â€” Libft++ BoostÃ©e â€” Partie 3/? [ğŸŸ¢ Facile]
-------------------------------------------------

ğŸ“š Introduction rapide Partie 3
Ici, tu vas apprendre Ã  :
Comparer correctement de la mÃ©moire ou des chaÃ®nes,
Trouver des caractÃ¨res dans des chaÃ®nes,
GÃ©rer le bas niveau avec de la prÃ©cision absolue.
Ta mÃ©moire et ta logique doivent devenir chirurgicales.

ğŸ“š Fonctions de cette Partie 3 :

| Fonction        | Ce que tu dois apprendre Ã  faire                     |
|-----------------|------------------------------------------------------|
| ft_memcmp       | Comparer deux zones mÃ©moire octet par octet          |
| ft_strchr       | Trouver un caractÃ¨re dans une chaÃ®ne (vers lâ€™avant)  |
| ft_strrchr      | Trouver un caractÃ¨re dans une chaÃ®ne (vers lâ€™arriÃ¨re)|
| ft_strncmp      | Comparer deux chaÃ®nes jusquâ€™Ã  n caractÃ¨res           |
| ft_strnstr      | Chercher une sous-chaÃ®ne dans une chaÃ®ne             |
| ft_atoi         | Convertir une chaÃ®ne en entier                       |
| ft_isalpha      | VÃ©rifier si un caractÃ¨re est alphabÃ©tique            |
| ft_isdigit      | VÃ©rifier si un caractÃ¨re est un chiffre              |
| ft_isalnum      | VÃ©rifier si un caractÃ¨re est alphanumÃ©rique          |

-------------------------------------------------
## 3.0) ft_memcmp
-------------------------------------------------
ğŸ§  Le but :
Comparer deux zones mÃ©moire octet par octet sur `n` octets.
Renvoyer une valeur **nÃ©gative**, **zÃ©ro** ou **positive** selon la premiÃ¨re diffÃ©rence rencontrÃ©e.

ğŸ“Œ Prototype :
```c
int ft_memcmp(const void *s1, const void *s2, size_t n);
```
ğŸ§ª Explication pÃ©dagogique :

Tu dois parcourir les deux zones mÃ©moire s1 et s2, sur n octets.

Chaque octet est castÃ© en unsigned char pour Ã©viter les piÃ¨ges liÃ©s aux valeurs nÃ©gatives.

DÃ¨s que tu dÃ©tectes une diffÃ©rence, tu retournes :
â” (s1[i] - s2[i]) (en int)

Sinon, si tous les octets sont identiques :
â” retourne 0

âš ï¸ Attention :
â” On ne s'arrÃªte pas Ã  \0 !
â” On traite toute la mÃ©moire, mÃªme les octets nuls.

ğŸ›‘ Interdictions 42 :

âŒ memcmp()
âŒ Toute fonction de <string.h>
âŒ #include <stdio.h> (interdit Ã  42)

âœ… Tu dois :

âœ”ï¸ Caster les void * en (unsigned char *)
âœ”ï¸ Comparer manuellement chaque octet
âœ”ï¸ Retourner dÃ¨s la premiÃ¨re diffÃ©rence
âœ”ï¸ Retourner 0 si toutes les valeurs sont Ã©gales

ğŸ’¬ Bulle dâ€™ami :

"Comparer byte Ã  byte, câ€™est comme lire deux lettres ligne par ligne pour dÃ©tecter la moindre faute de frappe."

ğŸ¯ Mini-TDD â€” Test simple

CrÃ©e tests/tests_ft_memcmp.c :

```c
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putnbr(int n);

int main(void)
{
    ft_putnbr(ft_memcmp("abc", "abd", 3));
    return (0);
}
```
ğŸ§ª TDD Ã‰tendu â€” Cas recommandÃ©s :

Test  RÃ©sultat attendu
memcmp("abc", "abc", 3) 0
memcmp("abc", "abd", 3) 'c' - 'd' = -1
memcmp("aaa", "AAA", 3) 'a' - 'A' = 32
memcmp("abc", "abc", 0) 0
memcmp(NULL, NULL, 0) 0 (valide)
memcmp(NULL, s2, 3) âŒ comportement indÃ©fini
memcmp(s1, NULL, 3) âŒ comportement indÃ©fini

â¡ï¸ Bonus : CrÃ©e tests/expected_memcmp.txt :

```txt
RÃ©sultat : [-1]
```
ğŸ§± Structure recommandÃ©e :

```css
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_memcmp.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_memcmp.c
â”‚   â””â”€â”€ test_ft_memcmp.sh
â”‚   â””â”€â”€ expected_memcmp.txt
```
ğŸ§ª Script test automatisÃ© : test_ft_memcmp.sh

```bash
#!/bin/bash
echo "ğŸ”§ Compilation de ft_memcmp..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memcmp tests/tests_ft_memcmp.c src/ft_memcmp.c

if [ $? -ne 0 ]; then
  echo "âŒ Compilation Ã©chouÃ©e."
  exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_memcmp > result.txt
diff -u result.txt tests/expected_memcmp.txt && echo "âœ… OK" || echo "âŒ DiffÃ©rences dÃ©tectÃ©es"
```
```bash
chmod +x tests/test_ft_memcmp.sh
./tests/test_ft_memcmp.sh
```

ğŸ“¦ Ajout Git recommandÃ© :

```bash
git add src/ft_memcmp.c tests/tests_ft_memcmp.c tests/test_ft_memcmp.sh tests/expected_memcmp.txt include/libft.h
git commit -m "[feat] ft_memcmp: comparaison mÃ©moire octet par octet + TDD complet"
```
ğŸ§© Convention Git Pro :

Tag Signification
- [feat]  Nouvelle fonction
- [test]  Tests ou validations automatisÃ©es
- [fix] Correction dâ€™erreur
- [doc] Documentation ou README
- [chore] Scripts ou maintenance

ğŸ GDB â€” DÃ©bogage pas Ã  pas :

```bash
gcc -g -Iinclude -o test_memcmp tests/tests_ft_memcmp.c src/ft_memcmp.c
gdb ./test_memcmp
```
```gdb
break ft_memcmp
run
step
print i
print ((unsigned char *)s1)[i]
print ((unsigned char *)s2)[i]
x/10cb s1
x/10cb s2
```
ğŸ” Reverse Engineering â€” Analyse assembleur :

```bash
nm ./test_memcmp | grep ft_memcmp
objdump -d ./test_memcmp | less
```
Ou depuis GDB :

```gdb
disassemble ft_memcmp
```
ğŸ’¡ Ã€ observer dans le dÃ©sassemblage :

```asm
movzx  eax, BYTE PTR [rdi]   ; charger s1[i]
movzx  edx, BYTE PTR [rsi]   ; charger s2[i]
cmp    al, dl                ; comparaison
jne    .Ldiff                ; saut si diffÃ©rent
ret                          ; sinon continue ou retourne 0
```
ğŸ“˜ README.md (bonus) :

```md
### ft_memcmp

- Objectif : comparer deux zones mÃ©moire.
- RÃ©sultat :
  - `0` si identique
  - `< 0` si `s1 < s2`
  - `> 0` si `s1 > s2`
- Ne sâ€™arrÃªte pas Ã  `\0`
- Comporte des cas limites (`NULL`, `n == 0`)
- Outils : GDB, objdump, nm, TDD, Git
```
ğŸ“Œ Ã€ retenir :

Ne tâ€™arrÃªte jamais Ã  \0
Toujours caster `(void *)` en `(unsigned char *)`
Retourne la diffÃ©rence des octets, pas 1 ou -1
TrÃ¨s utile pour comprendre comment le C manipule la mÃ©moire brute

ğŸ“š C â†’ Assembleur â†’ Reverse Engineering :

Dans objdump, cmp est le cÅ“ur de la dÃ©tection de diffÃ©rence.
jne gÃ¨re les sauts conditionnels.
Ces instructions te montrent comment ta logique en C se transforme en exÃ©cution CPU.

ğŸ”¬ Pourquoi on apprend Ã§a (ASM + Reverse Engineering) :

Tu vas bientÃ´t faire des fonctions plus complexes â†’ voir comment le CPU compare, saute, et retourne est fondamental.
Lâ€™assembleur te montre comment ton code se transforme rÃ©ellement.
Le reverse engineering te servira Ã  :
Analyser des binaires inconnus
Comprendre le comportement mÃ©moire
DÃ©bugger mÃªme sans les sources
CrÃ©er des outils maison (type memwatcher, disassembler, etc.)
Câ€™est aussi le cÅ“ur des outils comme Valgrind, GDB, ou les dÃ©bogueurs systÃ¨me.

ğŸ“š Bonus Ã©tude :
Lis les premiÃ¨res pages du PDF â€œReverse Engineering pour DÃ©butantsâ€ que tu as fourni (notamment le chap. sur cmp, jne, ret) pour voir les Ã©quivalents machine des blocs if et return de ton code .

-------------------------------------------------
## 3.1) ft_strchr
-------------------------------------------------
ğŸ§  Le but :
Trouver la premiÃ¨re occurrence du caractÃ¨re `c` dans la chaÃ®ne de caractÃ¨res `s`.  
Retourner un pointeur vers ce caractÃ¨re si trouvÃ©, ou `NULL` sinon.

ğŸ“Œ Prototype :

```c
char *ft_strchr(const char *s, int c);
```
ğŸ§ª Explication pÃ©dagogique :

Tu parcours s caractÃ¨re par caractÃ¨re.
Tu compares s[i] avec (char)c (attention au cast).
Tu dois inclure le caractÃ¨re nul \0 dans la recherche (ex: si c == 0, retourne un pointeur vers la fin de la chaÃ®ne).
Si une correspondance est trouvÃ©e â†’ retourne `(char *)&s[i]`
Sinon â†’ retourne NULL

ğŸ›‘ Interdictions 42 :

âŒ strchr()
âŒ Toute fonction de <string.h>
âŒ #include <stdio.h>

âœ… Tu dois :

âœ”ï¸ Boucle manuelle
âœ”ï¸ Comparaison caractÃ¨re par caractÃ¨re
âœ”ï¸ Retourner un char * vers la premiÃ¨re occurrence trouvÃ©e

ğŸ’¬ Bulle dâ€™ami :

"Trouver la premiÃ¨re Ã©toile dans un ciel plein de lettres, et sâ€™y accrocher."

ğŸ¯ Mini-TDD â€” Test simple

Fichier tests/tests_ft_strchr.c :

```c
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putstr(char *s);

int main(void)
{
    char *s = ft_strchr("bonjour", 'o');
    if (s)
        ft_putchar(*s);
    else
        ft_putstr("NULL");
    return (0);
}
```

ğŸ§ª TDD Ã‰tendu â€” Cas recommandÃ©s :

Test  RÃ©sultat attendu
ft_strchr("bonjour", 'o') pointeur vers premier 'o'
ft_strchr("bonjour", 'z') NULL
ft_strchr("bonjour", '\0')  pointeur vers \0
ft_strchr("bonjour", 'b') pointeur vers 'b'
ft_strchr("", 'a')  NULL
ft_strchr(NULL, 'a')  âš ï¸ comportement indÃ©fini

â¡ï¸ CrÃ©e tests/expected_strchr.txt :

```txt
RÃ©sultat : [o]
```
ğŸ§± Arborescence recommandÃ©e :

```css
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strchr.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ tests_ft_strchr.c
â”‚   â””â”€â”€ test_ft_strchr.sh
â”‚   â””â”€â”€ expected_strchr.txt
```
ğŸ§ª Script de test automatisÃ© â€” test_ft_strchr.sh

```bash
#!/bin/bash
echo "ğŸ”§ Compilation de ft_strchr..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strchr tests/tests_ft_strchr.c src/ft_strchr.c

if [ $? -ne 0 ]; then
  echo "âŒ Compilation Ã©chouÃ©e."
  exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_strchr > result.txt
diff -u result.txt tests/expected_strchr.txt && echo "âœ… OK" || echo "âŒ DiffÃ©rences dÃ©tectÃ©es"
```
ğŸ“¦ Ajout Git recommandÃ© :

bash
Copier
Modifier
git add src/ft_strchr.c tests/tests_ft_strchr.c tests/test_ft_strchr.sh tests/expected_strchr.txt include/libft.h
git commit -m "[feat] ft_strchr: recherche du premier caractÃ¨re dans chaÃ®ne + TDD complet"
ğŸ§© Convention Git Pro :

Tag Signification
[feat]  Nouvelle fonction
[test]  Tests ou validation
[fix] Correction
[doc] Ajout de documentation
[chore] Maintenance ou scripts auxiliaires

ğŸ GDB â€” DÃ©bogage pas Ã  pas :

bash
Copier
Modifier
gcc -g -Iinclude -o test_strchr tests/tests_ft_strchr.c src/ft_strchr.c
gdb ./test_strchr
gdb
Copier
Modifier
break ft_strchr
run
step
print s[i]
print (char)c
x/s s
info registers rdi rsi rax
ğŸ” Reverse Engineering â€” Analyse assembleur :

bash
Copier
Modifier
nm ./test_strchr | grep ft_strchr
objdump -d ./test_strchr | less
Ou depuis GDB :

gdb
Copier
Modifier
disassemble ft_strchr
ğŸ’¡ Tu devrais observer des instructions comme :

asm
Copier
Modifier
movzx eax, BYTE PTR [rdi]   ; charge s[i]
cmp    al, sil              ; compare Ã  c (castÃ©)
je     match                ; saut si Ã©gal
test   al, al               ; fin de chaÃ®ne ?
jne    loop                 ; boucle si pas fini
ret
ğŸ§  Comprendre les registres :

rdi : premier paramÃ¨tre (s)

esi/sil : second paramÃ¨tre (c)

al/eax : comparaison active

cmp, je, jne : cÅ“ur de ta logique

ğŸ“˜ README.md (bonus pro) :

md
Copier
Modifier
### ft_strchr

- Objectif : Trouver la premiÃ¨re occurrence du caractÃ¨re `c` dans la chaÃ®ne `s`.
- Retour : pointeur vers `c`, ou `NULL` si absent.
- Cas particuliers :
  - `c == '\0'` â retour vers fin de chaÃ®ne
  - `s == NULL` â comportement indÃ©fini
- Outils utilisÃ©s : GDB, objdump, nm, test shell, Git
- ComplexitÃ© : O(n)
ğŸ“Œ Ã€ retenir :

Cast obligatoire de c en (char)

Ne tâ€™arrÃªte pas avant dâ€™avoir comparÃ© le \0

Retourne un pointeur, pas un index

Utiliser const char *s mais retourner (char *) car câ€™est OK si on ne modifie pas

ğŸ“š C â†” ASM â†” Reverse Engineering :

MÃªme dans une fonction aussi simple, tu manipules directement la mÃ©moire : le compilateur gÃ©nÃ¨re un code de boucle avec cmp, je, ret, trÃ¨s lisible dans GDB ou objdump.
Câ€™est ta porte dâ€™entrÃ©e vers le bas niveau, et un excellent exercice pour lire des instructions machine simples.


-------------------------------------------------
## 3.2) ft_strrchr
-------------------------------------------------
ğŸ§  Le but :
Trouver la **derniÃ¨re occurrence** du caractÃ¨re `c` dans la chaÃ®ne de caractÃ¨res `s`.  
Retourner un pointeur vers cette occurrence si elle existe, ou `NULL` sinon.

ğŸ“Œ Prototype :

```c
char *ft_strrchr(const char *s, int c);
```
ğŸ§ª Explication pÃ©dagogique :

Tu parcours la chaÃ®ne s jusquâ€™au caractÃ¨re nul \0.

Ã€ chaque fois que tu rencontres (char)c, tu gardes lâ€™adresse.

Tu continues la lecture jusquâ€™au bout pour ne pas rater une occurrence ultÃ©rieure.

Ã€ la fin, tu retournes :

le dernier pointeur mÃ©morisÃ© si trouvÃ©

NULL sinon

âš ï¸ Attention :

c est un int, mais doit Ãªtre comparÃ© en (char)

Le \0 doit Ãªtre inclus dans la recherche (cas possible)

ğŸ›‘ Interdictions 42 :

âŒ strrchr()
âŒ <string.h>
âŒ #include <stdio.h>

âœ… Tu dois :

âœ”ï¸ Faire une boucle complÃ¨te
âœ”ï¸ MÃ©moriser la derniÃ¨re position trouvÃ©e
âœ”ï¸ Caster les types si besoin
âœ”ï¸ Retourner un char *, mÃªme si s est const char *

ğŸ’¬ Bulle dâ€™ami :

"La derniÃ¨re Ã©toile est souvent la plus brillante, mais il faut regarder tout le ciel avant de la voir."

ğŸ¯ Mini-TDD â€” Test simple

Fichier tests/tests_ft_strrchr.c :

c
Copier
Modifier
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putstr(char *s);

int main(void)
{
    char *res = ft_strrchr("bonjour", 'o');
    if (res)
    {
        ft_putchar('[');
        ft_putchar(*res);
        ft_putchar(']');
    }
    else
        ft_putstr("[NULL]");
    return 0;
}
ğŸ§ª TDD Ã‰tendu â€” Cas recommandÃ©s :

Test  RÃ©sultat attendu
ft_strrchr("bonjour", 'o')  pointeur vers le 2e 'o'
ft_strrchr("bonjour", 'b')  pointeur vers 'b'
ft_strrchr("bonjour", '\0') pointeur vers \0
ft_strrchr("bonjour", 'z')  NULL
ft_strrchr("", 'a') NULL
ft_strrchr(NULL, 'a') âš ï¸ comportement indÃ©fini

â¡ï¸ CrÃ©e tests/expected_strrchr.txt :

less
Copier
Modifier
RÃ©sultat : [o]
ğŸ§± Structure recommandÃ©e :

css
Copier
Modifier
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strrchr.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ tests_ft_strrchr.c
â”‚   â”œâ”€â”€ test_ft_strrchr.sh
â”‚   â””â”€â”€ expected_strrchr.txt
ğŸ§ª Script de test automatisÃ© â€” test_ft_strrchr.sh

bash
Copier
Modifier
#!/bin/bash
echo "ğŸ”§ Compilation de ft_strrchr..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strrchr tests/tests_ft_strrchr.c src/ft_strrchr.c

if [ $? -ne 0 ]; then
  echo "âŒ Compilation Ã©chouÃ©e."
  exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_strrchr > result.txt
diff -u result.txt tests/expected_strrchr.txt && echo "âœ… OK" || echo "âŒ DiffÃ©rences dÃ©tectÃ©es"
bash
Copier
Modifier
chmod +x tests/test_ft_strrchr.sh
./tests/test_ft_strrchr.sh
ğŸ“¦ Ajout Git recommandÃ© :

bash
Copier
Modifier
git add src/ft_strrchr.c tests/tests_ft_strrchr.c tests/test_ft_strrchr.sh tests/expected_strrchr.txt include/libft.h
git commit -m "[feat] ft_strrchr: recherche derniÃ¨re occurrence dans chaÃ®ne + TDD"
ğŸ§© Convention Git Pro :

Tag Signification
[feat]  Nouvelle fonction
[test]  Ajout ou amÃ©lioration des tests
[fix] Correction de bug
[doc] Documentation ou README
[chore] Maintenance, script, Makefile, etc

ğŸ GDB â€” DÃ©bogage pas Ã  pas :

bash
Copier
Modifier
gcc -g -Iinclude -o test_strrchr tests/tests_ft_strrchr.c src/ft_strrchr.c
gdb ./test_strrchr
gdb
Copier
Modifier
break ft_strrchr
run
step
print i
print s[i]
print (char)c
x/s s
ğŸ” Reverse Engineering â€” Analyse assembleur :

bash
Copier
Modifier
nm ./test_strrchr | grep ft_strrchr
objdump -d ./test_strrchr | less
Ou dans GDB :

gdb
Copier
Modifier
disassemble ft_strrchr
ğŸ’¡ Tu peux observer un schÃ©ma comme :

asm
Copier
Modifier
movzx eax, BYTE PTR [rdi]   ; lit s[i]
cmp    al, sil              ; compare Ã  (char)c
je     store_addr           ; mÃ©morise si Ã©gal
test   al, al               ; fin de chaÃ®ne ?
jne    loop                 ; sinon continue
ret
store_addr est une adresse mÃ©morisÃ©e temporairement

le ret retourne ce dernier pointeur ou NULL

ğŸ“˜ README.md (bonus pro) :

md
Copier
Modifier
### ft_strrchr

- But : Trouver la **derniÃ¨re** occurrence du caractÃ¨re `c` dans la chaÃ®ne `s`.
- Retour :
  - Un `char *` vers le dernier `c` trouvÃ©
  - `NULL` si non trouvÃ©
- Cas particuliers :
  - `c == '\0'` â retourne pointeur vers `\0`
  - `s == NULL` â comportement indÃ©fini
- Outils : GDB, objdump, nm, test shell, Git
- ComplexitÃ© : O(n)
ğŸ“Œ Ã€ retenir :

Tu parcours tout s, mÃªme aprÃ¨s la premiÃ¨re correspondance

Tu compares (char)c, pas int brut

Tu peux mÃ©moriser la position avec char *last = NULL;

Retourne toujours la derniÃ¨re correspondance

\0 fait partie de la recherche

ğŸ“š Lien C â†’ Assembleur :

strrchr est un bon exercice pour apprendre Ã  mÃ©moriser une adresse conditionnellement.
En assembleur, cela donne une boucle avec : cmp, je, test, et stockage conditionnel.
Câ€™est ta premiÃ¨re boucle avec effet mÃ©moire dans une routine dâ€™analyse bas niveau.

-------------------------------------------------
## 3.3) ft_strncmp
-------------------------------------------------
ğŸ§  Le but :
Comparer deux chaÃ®nes de caractÃ¨res **sur au plus `n` caractÃ¨res**, et retourner :
- `0` si les `n` premiers caractÃ¨res sont identiques
- Un entier < 0 ou > 0 selon la diffÃ©rence dÃ¨s le premier caractÃ¨re diffÃ©rent

ğŸ“Œ Prototype :

```c
int ft_strncmp(const char *s1, const char *s2, size_t n);
```
ğŸ§ª Explication pÃ©dagogique :

Tu compares chaque caractÃ¨re de s1[i] et s2[i], jusqu'Ã  n fois maximum.

DÃ¨s qu'une diffÃ©rence est dÃ©tectÃ©e, tu retournes :

c
Copier
Modifier
(unsigned char)s1[i] - (unsigned char)s2[i]
Si n == 0 â retourne immÃ©diatement 0.

Si aucun caractÃ¨re ne diffÃ¨re sur les n premiers, retourne 0.

âš ï¸ Attention :

Tu dois caster en unsigned char pour Ã©viter des surprises avec les valeurs > 127.

Tu t'arrÃªtes soit Ã  n, soit au premier caractÃ¨re diffÃ©rent, soit aux \0.

ğŸ›‘ Interdictions 42 :

âŒ strncmp()
âŒ <string.h>
âŒ #include <stdio.h>

âœ… Tu dois :

âœ”ï¸ Comparer chaque caractÃ¨re un par un
âœ”ï¸ Limiter la comparaison Ã  n caractÃ¨res
âœ”ï¸ Retourner une soustraction sur les unsigned char
âœ”ï¸ GÃ©rer n == 0 sans erreur

ğŸ’¬ Bulle dâ€™ami :

"Comparer vite mais bien : pas besoin dâ€™aller jusquâ€™au bout pour voir une diffÃ©rence."

ğŸ¯ Mini-TDD â€” Test simple

Fichier tests/tests_ft_strncmp.c :

c
Copier
Modifier
#include <unistd.h>
#include "libft.h"

void ft_putnbr(int n);
void ft_putchar(char c);

int main(void)
{
    int result = ft_strncmp("hello", "helix", 3);
    ft_putchar('[');
    ft_putnbr(result);
    ft_putchar(']');
    return 0;
}
ğŸ§ª TDD Ã‰tendu â€” Cas recommandÃ©s :

Test  RÃ©sultat attendu
ft_strncmp("abc", "abc", 3) 0
ft_strncmp("abc", "abd", 3) 'c' - 'd' = -1
ft_strncmp("abc", "ab", 3)  'c' - '\0' = +99
ft_strncmp("abc", "abd", 2) 0 (car seuls les 2 premiers sont comparÃ©s)
ft_strncmp("abc", "abc", 0) 0
ft_strncmp("", "", 5) 0
ft_strncmp(NULL, s2, n) / s1 == NULL  âŒ Comportement indÃ©fini sauf si n == 0

â¡ï¸ CrÃ©e tests/expected_strncmp.txt :

less
Copier
Modifier
RÃ©sultat : [0]
ğŸ§± Structure recommandÃ©e :

css
Copier
Modifier
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strncmp.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ tests_ft_strncmp.c
â”‚   â”œâ”€â”€ test_ft_strncmp.sh
â”‚   â””â”€â”€ expected_strncmp.txt
ğŸ§ª Script de test automatisÃ© â€” test_ft_strncmp.sh

bash
Copier
Modifier
#!/bin/bash
echo "ğŸ”§ Compilation de ft_strncmp..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strncmp tests/tests_ft_strncmp.c src/ft_strncmp.c

if [ $? -ne 0 ]; then
  echo "âŒ Compilation Ã©chouÃ©e."
  exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_strncmp > result.txt
diff -u result.txt tests/expected_strncmp.txt && echo "âœ… OK" || echo "âŒ DiffÃ©rences dÃ©tectÃ©es"
bash
Copier
Modifier
chmod +x tests/test_ft_strncmp.sh
./tests/test_ft_strncmp.sh
ğŸ“¦ Ajout Git recommandÃ© :

bash
Copier
Modifier
git add src/ft_strncmp.c tests/tests_ft_strncmp.c tests/test_ft_strncmp.sh tests/expected_strncmp.txt include/libft.h
git commit -m "[feat] ft_strncmp: comparaison limitÃ©e entre chaÃ®nes + TDD"
ğŸ§© Convention Git Pro :

Tag Signification
[feat]  Nouvelle fonction
[test]  Ajout ou amÃ©lioration des tests
[fix] Correction de bug
[doc] Documentation ou README
[chore] Maintenance, script, Makefile, etc

ğŸ GDB â€” Debug pas Ã  pas :

bash
Copier
Modifier
gcc -g -Iinclude -o test_strncmp tests/tests_ft_strncmp.c src/ft_strncmp.c
gdb ./test_strncmp
gdb
Copier
Modifier
break ft_strncmp
run
step
print i
print s1[i]
print s2[i]
print (unsigned char)s1[i] - (unsigned char)s2[i]
ğŸ” Reverse Engineering â€” Analyse assembleur :

bash
Copier
Modifier
nm ./test_strncmp | grep ft_strncmp
objdump -d ./test_strncmp | less
Ou dans GDB :

gdb
Copier
Modifier
disassemble ft_strncmp
ğŸ’¡ Tu pourrais observer :

asm
Copier
Modifier
movzx eax, BYTE PTR [rdi + rcx]   ; charge s1[i]
movzx edx, BYTE PTR [rsi + rcx]   ; charge s2[i]
cmp eax, edx
jne diff_found
inc rcx
cmp rcx, rdx                      ; rdx = n
jl loop
rcx : index i

rdi / rsi : pointeurs s1 / s2

movzx : conversion sÃ©curisÃ©e

cmp + jne : cÅ“ur de la comparaison

ret : retourne la diffÃ©rence

ğŸ“˜ README.md (bonus pro) :

md
Copier
Modifier
### ft_strncmp

- But : Comparer `n` caractÃ¨res entre `s1` et `s2`
- Retour :
  - `0` si Ã©galitÃ© sur `n` caractÃ¨res
  - `< 0` si `s1[i] < s2[i]`
  - `> 0` si `s1[i] > s2[i]`
- Cas particuliers :
  - `n == 0` â retourne `0`
  - ArrÃªt anticipÃ© Ã  la premiÃ¨re diffÃ©rence
- Outils utilisÃ©s : GDB, objdump, nm, test shell, Git
- ComplexitÃ© : O(n)
ğŸ“Œ Ã€ retenir :

Tu compares des unsigned char, pas des char

Tu tâ€™arrÃªtes dÃ¨s quâ€™un caractÃ¨re diffÃ¨re OU que n est atteint

Tu ne vas pas jusquâ€™au \0 si n < longueur

Tu ne dois pas retourner 1 ou -1 mais bien la soustraction entre octets

ğŸ“š Lien C â†’ Assembleur :

strncmp est comme memcmp, mais limitÃ© par \0 : câ€™est un compromis entre sÃ©curitÃ© et efficacitÃ©.
En assembleur, tu retrouves un cmp, une boucle avec je, et un compteur n dÃ©croissant.

Comprendre strncmp tâ€™initie Ã  la gestion sÃ©curisÃ©e de tampons, utile pour lâ€™analyse mÃ©moire, les protocoles rÃ©seau et les audits bas niveau.

-------------------------------------------------
## 3.4) ft_strnstr
-------------------------------------------------
ğŸ§  Le but :
Trouver une sous-chaÃ®ne `needle` dans la chaÃ®ne `haystack`, **mais sans dÃ©passer `len` caractÃ¨res**.

Si `needle` est vide, retourne `haystack`.  
Sinon, cherche `needle` dans les `len` premiers caractÃ¨res de `haystack`.  
Retourne un `char *` vers le dÃ©but de lâ€™occurrence si trouvÃ©e, ou `NULL` sinon.

ğŸ“Œ Prototype :

```c
char *ft_strnstr(const char *haystack, const char *needle, size_t len);
```
ğŸ§ª Explication pÃ©dagogique :

Si needle est vide (needle[0] == '\0'), retourne haystack.

Sinon, parcours haystack caractÃ¨re par caractÃ¨re (jusqu'Ã  len).

Ã€ chaque position i, vÃ©rifie sâ€™il reste assez de place (len - i >= ft_strlen(needle)).

Compare needle avec haystack + i sur ft_strlen(needle) caractÃ¨res.

Si match â retourne un pointeur vers haystack + i.

Sinon â continue jusquâ€™Ã  la limite len.

Si aucun match trouvÃ© â retourne NULL.

ğŸ›‘ Interdictions 42 :

âŒ strstr()
âŒ Toute fonction <string.h>
âŒ #include <stdio.h>

âœ… Tu dois :

âœ”ï¸ ImplÃ©menter une recherche manuelle
âœ”ï¸ Comparer les chaÃ®nes avec ta propre fonction ou une boucle
âœ”ï¸ Bien gÃ©rer la limite len
âœ”ï¸ GÃ©rer needle == "" et len == 0

ğŸ’¬ Bulle dâ€™ami :

"Trouver une Ã®le dans un ocÃ©anâ€¦ avant de manquer de carburant."

ğŸ¯ Mini-TDD â€” Test simple

Fichier tests/tests_ft_strnstr.c :

c
Copier
Modifier
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putstr(char *s);

int main(void)
{
    char *res = ft_strnstr("bonjour tout le monde", "to", 10);
    if (res)
    {
        ft_putchar('[');
        ft_putchar(*res);
        ft_putchar(']');
    }
    else
        ft_putstr("[NULL]");
    return 0;
}
ğŸ§ª TDD Ã‰tendu â€” Cas recommandÃ©s :

Test  RÃ©sultat attendu
ft_strnstr("bonjour tout le monde", "to", 10) [NULL]
ft_strnstr("bonjour tout le monde", "to", 15) pointeur vers 't'
ft_strnstr("hello world", "", 5)  pointeur vers "hello"
ft_strnstr("abc", "abcd", 3)  NULL
ft_strnstr("abc", "bc", 2)  NULL
ft_strnstr("abc", "bc", 3)  pointeur vers 'b'
ft_strnstr(NULL, "a", 3)  comportement indÃ©fini âš ï¸
ft_strnstr("abc", NULL, 3)  comportement indÃ©fini âš ï¸

â¡ï¸ Bonus : CrÃ©e tests/expected_strnstr.txt :

txt
Copier
Modifier
RÃ©sultat : [NULL]
ğŸ§± Structure recommandÃ©e :

css
Copier
Modifier
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ft_strnstr.c
â”œâ”€â”€ include/
â”‚   â””â”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ tests_ft_strnstr.c
â”‚   â”œâ”€â”€ test_ft_strnstr.sh
â”‚   â””â”€â”€ expected_strnstr.txt
ğŸ§ª Script de test automatisÃ© â€” test_ft_strnstr.sh :

bash
Copier
Modifier
#!/bin/bash
echo "ğŸ”§ Compilation de ft_strnstr..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strnstr tests/tests_ft_strnstr.c src/ft_strnstr.c

if [ $? -ne 0 ]; then
  echo "âŒ Compilation Ã©chouÃ©e."
  exit 1
fi

echo "âœ… ExÃ©cution des tests :"
./tests/tests_ft_strnstr > result.txt
diff -u result.txt tests/expected_strnstr.txt && echo "âœ… OK" || echo "âŒ DiffÃ©rences dÃ©tectÃ©es"
bash
Copier
Modifier
chmod +x tests/test_ft_strnstr.sh
./tests/test_ft_strnstr.sh
ğŸ“¦ Ajout Git recommandÃ© :

bash
Copier
Modifier
git add src/ft_strnstr.c tests/tests_ft_strnstr.c tests/test_ft_strnstr.sh tests/expected_strnstr.txt include/libft.h
git commit -m "[feat] ft_strnstr: recherche sous-chaÃ®ne limitÃ©e + TDD"
ğŸ§© Convention Git Pro :

Tag Signification
[feat]  Nouvelle fonction
[test]  Ajout ou amÃ©lioration des tests
[fix] Correction de bug
[doc] Documentation ou README
[chore] Maintenance, script, Makefile, etc

ğŸ GDB â€” Debug pas Ã  pas :

bash
Copier
Modifier
gcc -g -Iinclude -o test_strnstr tests/tests_ft_strnstr.c src/ft_strnstr.c
gdb ./test_strnstr
gdb
Copier
Modifier
break ft_strnstr
run
step
print haystack[i]
print needle[j]
print len
ğŸ” Reverse Engineering â€” Analyse assembleur :

bash
Copier
Modifier
nm ./test_strnstr | grep ft_strnstr
objdump -d ./test_strnstr | less
Ou depuis GDB :

gdb
Copier
Modifier
disassemble ft_strnstr
ğŸ’¡ Tu pourrais observer :

asm
Copier
Modifier
movzx eax, BYTE PTR [rdi + rcx]   ; haystack[i]
cmp eax, BYTE PTR [rsi]           ; needle[0]
je match_loop
cmp rcx, rdx                      ; comparaison avec len
jl search_loop
rdi : haystack

rsi : needle

rdx : len

rcx : i

boucles de comparaison internes imbriquÃ©es

ğŸ“˜ README.md (bonus pro) :

md
Copier
Modifier
### ft_strnstr

- But : Trouver une sous-chaÃ®ne dans `haystack` sans dÃ©passer `len` caractÃ¨res.
- Retour :
  - `char *` vers le dÃ©but de lâ€™occurrence trouvÃ©e
  - `NULL` si non trouvÃ©e
- Cas particuliers :
  - `needle == ""` â retourne `haystack`
  - `len == 0` â retourne `NULL`, sauf si `needle == ""`
- Outils utilisÃ©s : GDB, objdump, nm, tests.sh, Git
- ComplexitÃ© : O(n * m) dans le pire des cas
ğŸ“Œ Ã€ retenir :

ft_strnstr â‰  strstr car limitÃ© en taille !

âš ï¸ Attention aux dÃ©passements de len

Ne fais pas de comparaison si len < strlen(needle)

âš ï¸ Ne jamais lire au-delÃ  de len

ğŸ“š Lien C â†’ Assembleur :

Cette fonction tâ€™apprend Ã  gÃ©rer les limites de buffer, une compÃ©tence essentielle pour la sÃ©curitÃ©.
Tu dois penser aux bornes, Ã  la comparaison double, Ã  la terminaison correcte.

-------------------------------------------------
ğŸ“š RÃ©capitulatif rapide Partie 3 :
-------------------------------------------------

Fonction Ce que tu dois savoir faire
ft_memcmp Comparer mÃ©moire brute
ft_strchr Trouver la premiÃ¨re occurrence
ft_strrchr Trouver la derniÃ¨re occurrence
ft_strncmp Comparer jusqu Ã  un certain nombre de caractÃ¨res
ft_strnstr Chercher une sous-chaÃ®ne dans une limite

-------------------------------------------------
# Bloc 2 â€” Libft++ BoostÃ©e â€” Partie 4/? [ğŸŸ¢ Facile]
-------------------------------------------------

ğŸ“š Introduction rapide Partie 4

Bienvenue dans la **partie dynamique** de la Libft++ : ici, on joue avec **la mÃ©moire**, **les conversions**, et **lâ€™allocation**.

Tu vas apprendre Ã  :

- Allouer dynamiquement de la mÃ©moire (`malloc`, `calloc`)
- LibÃ©rer proprement cette mÃ©moire
- Convertir des chaÃ®nes en entiers (`ft_atoi`)
- Convertir des entiers en chaÃ®nes (`ft_itoa`)
- GÃ©rer les pointeurs avec une extrÃªme prÃ©cision

ğŸ§  Ce que ton cerveau doit intÃ©grer maintenant :

- âœ… Calculer combien dâ€™octets il faut pour un tableau de `int`, `char`, etc.
- âœ… GÃ©rer le caractÃ¨re `\0` Ã  la fin de chaque chaÃ®ne
- âœ… Bien vÃ©rifier si `malloc` a Ã©chouÃ©
- âœ… Ne jamais oublier de libÃ©rer ce que tu alloues (free)

---

ğŸ“š Fonctions de cette Partie 4 :

| Fonction        | Objectif                                                    |
|----------------|-------------------------------------------------------------|
| `ft_calloc`     | Allouer `count * size` octets, initialisÃ©s Ã  0             |
| `ft_strdup`     | Dupliquer une chaÃ®ne de caractÃ¨res                         |
| `ft_substr`     | Extraire une sous-chaÃ®ne                                   |
| `ft_strjoin`    | Joindre deux chaÃ®nes                                       |
| `ft_strtrim`    | Supprimer des caractÃ¨res spÃ©cifiques au dÃ©but/fin dâ€™une chaÃ®ne |
| `ft_split`      | DÃ©couper une chaÃ®ne en tableau de mots                     |
| `ft_itoa`       | Convertir un entier en chaÃ®ne                              |
| `ft_atoi`       | Convertir une chaÃ®ne en entier                             |

âš ï¸ Ces fonctions sont **les bases de toute manipulation dynamique de texte en C**.  
Tu vas devoir les utiliser dans 90% de tes projets futurs (libft, minishell, pipexâ€¦).

---

ğŸ“¦ Organisation des fichiers recommandÃ©e :

libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ include/
â”‚ â””â”€â”€ libft.h
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ ft_calloc.c
â”‚ â”œâ”€â”€ ft_strdup.c
â”‚ â”œâ”€â”€ ft_substr.c
â”‚ â”œâ”€â”€ ft_strjoin.c
â”‚ â”œâ”€â”€ ft_strtrim.c
â”‚ â”œâ”€â”€ ft_split.c
â”‚ â”œâ”€â”€ ft_itoa.c
â”‚ â”œâ”€â”€ ft_atoi.c
â”œâ”€â”€ tests/
â”‚ â”œâ”€â”€ tests_ft_calloc.c
â”‚ â”œâ”€â”€ test_ft_calloc.sh
â”‚ â””â”€â”€ expected_calloc.txt
â”‚ (... les autres Ã  suivre)

yaml
Copier
Modifier

---

ğŸ” Outils Ã  maÃ®triser dans cette partie :

| Outil      | RÃ´le                                                   |
|------------|--------------------------------------------------------|
| `malloc`   | Allouer dynamiquement de la mÃ©moire                    |
| `free`     | LibÃ©rer cette mÃ©moire                                  |
| `gdb`      | VÃ©rifier les pointeurs, les fuites, les allocations    |
| `valgrind` | (âš ï¸ interdit Ã  42, mais Ã  connaÃ®tre plus tard)         |
| `objdump`  | Observer la gÃ©nÃ©ration ASM dâ€™allocations               |
| `nm`       | Voir si `malloc`, `free` sont appelÃ©s dans ton code    |

---

ğŸ’¬ Bulle dâ€™ami :

> "LÃ  oÃ¹ la mÃ©moire vit et meurt, ton code doit Ãªtre prÃ©cis comme un chirurgien."

-------------------------------------------------
## 4.0) ft_calloc
-------------------------------------------------
Le but :
Allouer de la mÃ©moire et l'initialiser Ã  zÃ©ro.

Prototype :

c
Copier
Modifier
```c
void *ft_calloc(size_t count, size_t size);
Explication :
RÃ©server count * size octets et tout mettre Ã  zÃ©ro (\0).

```
Interdictions :

âŒ Pas de calloc

âœ… Utiliser malloc + ft_bzero (dÃ©jÃ  codÃ©)

ğŸ’¬ Bulle d'ami :
"CrÃ©er une maison vide, propre et prÃªte Ã  accueillir."

ğŸ¯ Mini-TDD :
Allouer 5 int et vÃ©rifier qu'ils valent 0.

## 4.1) ft_strdup (Rappel amÃ©liorÃ©)
Le but :
Copier une chaÃ®ne en crÃ©ant une nouvelle zone mÃ©moire.

Prototype :

c
Copier
Modifier
```c
char *ft_strdup(const char *s1);
Explication :
Allouer, puis copier, caractÃ¨re par caractÃ¨re.

```
Interdictions :

âŒ Pas d'appel Ã  strdup

âœ… malloc obligatoire

ğŸ’¬ Bulle d'ami :
"Un clone parfait doit vivre dans sa propre maison."

ğŸ¯ Mini-TDD :
Dupliquer "Bonjour" et vÃ©rifier contenu ET adresses diffÃ©rentes.

## 4.2) ft_atoi
Le but :
Convertir une chaÃ®ne de caractÃ¨res en entier.

Prototype :

c
Copier
Modifier
```c
int ft_atoi(const char *str);
Explication :
Lire les chiffres d'une chaÃ®ne jusqu'Ã  pouvoir former un int.

```
Interdictions :

âŒ Pas de atoi

âœ… Parsing manuel obligatoire

ğŸ’¬ Bulle d'ami :
"Chaque chiffre raconte une histoire, mais il faut bien Ã©couter."

ğŸ¯ Mini-TDD :
Convertir " -123" et vÃ©rifier que tu obtiens -123.

## 4.3) ft_itoa
Le but :
Convertir un entier en chaÃ®ne de caractÃ¨res.

Prototype :

c
Copier
Modifier
```c
char *ft_itoa(int n);
Explication :
DÃ©couper un nombre en chiffres et les assembler en une chaÃ®ne.

```
Interdictions :

âŒ Pas d'utilisation de sprintf

âœ… Allocation dynamique (malloc) obligatoire

ğŸ’¬ Bulle d'ami :
"Transformer un nombre en mot: la magie du code."

ğŸ¯ Mini-TDD :
Transformer 42 â” "42", -2147483648 â” "-2147483648".

## 4.4) ft_substr
Le but :
Extraire une sous-chaÃ®ne d'une chaÃ®ne.

Prototype :

c
Copier
Modifier
```c
char *ft_substr(char const *s, unsigned int start, size_t len);
Explication :
CrÃ©er une nouvelle chaÃ®ne commenÃ§ant Ã  start, avec len caractÃ¨res maximum.

```
Interdictions :

âŒ Pas de substr toute faite

âœ… Allocation + copie manuelles

ğŸ’¬ Bulle d'ami :
"Parfois, la meilleure histoire est juste un chapitre extrait."

ğŸ¯ Mini-TDD :
Extraire "am" de "Programme" en partant du 5áµ‰ caractÃ¨re.

ğŸ“š RÃ©capitulatif rapide Partie 4 :

Fonction Ce que tu dois savoir faire
ft_calloc Allouer mÃ©moire initialisÃ©e Ã  zÃ©ro
ft_strdup Dupliquer une chaÃ®ne manuellement
ft_atoi Lire un nombre dans une chaÃ®ne
ft_itoa Transformer un int en chaÃ®ne
ft_substr Extraire un morceau de chaÃ®ne

# Bloc 2 â€” Libft++ BoostÃ©e â€” Partie 5/? [ğŸŸ¢ Facile]
ğŸ“š Introduction rapide Partie 5
Ici, tu vas :

Assembler (strjoin) des chaÃ®nes,

DÃ©couper (split) intelligemment une chaÃ®ne,

Nettoyer (strtrim) les chaÃ®nes de caractÃ¨res.

Ton objectif :
MaÃ®triser la manipulation propre des chaÃ®nes en mÃ©moire dynamique.

ğŸ“š Fonctions de cette Partie 5
## 5.0) ft_strjoin
Le but :
Assembler deux chaÃ®nes de caractÃ¨res en une seule.

Prototype :

c
Copier
Modifier
```c
char *ft_strjoin(char const *s1, char const *s2);
Explication :
Allouer une nouvelle chaÃ®ne contenant s1 suivi de s2.

```
Interdictions :

âŒ Pas de strcat, sprintf, etc.

âœ… Construction manuelle obligatoire

ğŸ’¬ Bulle d'ami :
"Assembler deux Ã¢mes en un seul voyage."

ğŸ¯ Mini-TDD :
Assembler "Hello" et "World" â” obtenir "HelloWorld".

## 5.1) ft_strtrim
Le but :
Supprimer les caractÃ¨res spÃ©cifiÃ©s au dÃ©but et Ã  la fin d'une chaÃ®ne.

Prototype :

c
Copier
Modifier
```c
char *ft_strtrim(char const *s1, char const *set);
Explication :
Supprimer tous les caractÃ¨res de set prÃ©sents au dÃ©but et Ã  la fin de s1.

```
Interdictions :

âŒ Pas d'utilisation de fonction externe

âœ… Parsing et allocation manuels

ğŸ’¬ Bulle d'ami :
"Ã‰laguer les branches mortes pour faire respirer l'arbre."

ğŸ¯ Mini-TDD :
Trimer " Hello " avec " " â” obtenir "Hello".

## 5.2) ft_split
Le but :
Diviser une chaÃ®ne en plusieurs sous-chaÃ®nes, selon un sÃ©parateur.

Prototype :

c
Copier
Modifier
```c
char **ft_split(char const *s, char c);
Explication :
Ã€ chaque fois que tu rencontres le caractÃ¨re c, tu dÃ©coupes et crÃ©es un nouveau mot.

```
Interdictions :

âŒ Pas de strtok, strsep

âœ… Allocation manuelle obligatoire

ğŸ’¬ Bulle d'ami :
"DÃ©couper un long chemin en plusieurs Ã©tapes claires."

ğŸ¯ Mini-TDD :
Diviser "Hello World 42" par ' ' â” obtenir ["Hello", "World", "42"].

## 5.3) ft_strmapi
Le but :
Appliquer une fonction Ã  chaque caractÃ¨re d'une chaÃ®ne (retourne une nouvelle chaÃ®ne).

Prototype :

c
Copier
Modifier
```c
char *ft_strmapi(char const *s, char (*f)(unsigned int, char));
Explication :
Pour chaque caractÃ¨re, appeler une fonction qui le transforme.

```
Interdictions :

âŒ Pas de map automatique

âœ… Construire la chaÃ®ne toi-mÃªme

ğŸ’¬ Bulle d'ami :
"Transformer lettre aprÃ¨s lettre, comme un alchimiste."

ğŸ¯ Mini-TDD :
Appliquer une fonction qui transforme "abc" en "BCD" (ajouter 1 Ã  chaque caractÃ¨re).

## 5.4) ft_striteri
Le but :
Appliquer une fonction Ã  chaque caractÃ¨re d'une chaÃ®ne directement (sans crÃ©er une nouvelle chaÃ®ne).

Prototype :

c
Copier
Modifier
```c
void ft_striteri(char *s, void (*f)(unsigned int, char*));
Explication :
Modifier directement la chaÃ®ne existante en passant l'index et un pointeur sur chaque caractÃ¨re.

```
Interdictions :

âŒ Pas de double allocation

âœ… Modifications en place

ğŸ’¬ Bulle d'ami :
"Parfois, il faut polir la pierre sans l'Ã©changer."

ğŸ¯ Mini-TDD :
Appliquer une fonction qui met tout en majuscule directement sur "hello" â” devient "HELLO".

ğŸ“š RÃ©capitulatif rapide Partie 5 :

Fonction Ce que tu dois savoir faire
ft_strjoin Coller deux chaÃ®nes ensemble
ft_strtrim Enlever un ensemble de caractÃ¨res autour d'une chaÃ®ne
ft_split Couper une chaÃ®ne en plusieurs sous-chaÃ®nes
ft_strmapi CrÃ©er une nouvelle chaÃ®ne transformÃ©e caractÃ¨re par caractÃ¨re
ft_striteri Modifier une chaÃ®ne existante caractÃ¨re par caractÃ¨re

# Bloc 2 â€” Libft++ BoostÃ©e â€” Partie 6/? [ğŸŸ¢ Facile]
ğŸ“š Introduction rapide Partie 6
Ici, tu vas :

Afficher dans un fichier donnÃ© (et plus seulement sur l'Ã©cran),

Apprendre Ã  penser en terme de "file descriptor" (fd),

MaÃ®triser l'affichage contrÃ´lÃ© en C.

ğŸ“š Fonctions de cette Partie 6
## 6.0) ft_putchar_fd
Le but :
Ã‰crire un caractÃ¨re dans un fichier donnÃ© (file descriptor).

Prototype :

c
Copier
Modifier
```c
void ft_putchar_fd(char c, int fd);
Explication :
Utiliser write pour envoyer c vers le fd spÃ©cifiÃ©.

```
Interdictions :

âŒ Pas de fprintf

âœ… Utiliser write directement

ğŸ’¬ Bulle d'ami :
"Parler exactement Ã  celui que tu veux atteindre."

ğŸ¯ Mini-TDD :
Afficher 'A' dans un fichier ouvert en Ã©criture.

## 6.1) ft_putstr_fd
Le but :
Ã‰crire une chaÃ®ne de caractÃ¨res dans un fichier donnÃ©.

Prototype :

c
Copier
Modifier
```c
void ft_putstr_fd(char *s, int fd);
Explication :
Ã‰crire toute la chaÃ®ne caractÃ¨re par caractÃ¨re (ou d'un coup) vers fd.

```
Interdictions :

âŒ Pas de fprintf

âœ… write obligatoire

ğŸ’¬ Bulle d'ami :
"Exprimer un mot entier, mais Ã  la bonne personne."

ğŸ¯ Mini-TDD :
Afficher "Hello World" dans un fichier temporaire.

## 6.2) ft_putendl_fd
Le but :
Ã‰crire une chaÃ®ne de caractÃ¨res suivie d'un retour Ã  la ligne (\n), dans un fichier donnÃ©.

Prototype :

c
Copier
Modifier
```c
void ft_putendl_fd(char *s, int fd);
Explication :
Ã‰crire la chaÃ®ne puis Ã©crire un \n derriÃ¨re.

```
Interdictions :

âŒ Pas de puts

âœ… Construction manuelle avec write

ğŸ’¬ Bulle d'ami :
"Parler et toujours bien finir sa phrase."

ğŸ¯ Mini-TDD :
Afficher "Hello" + retour Ã  la ligne dans un fichier.

## 6.3) ft_putnbr_fd
Le but :
Afficher un nombre entier dans un fichier donnÃ©.

Prototype :

c
Copier
Modifier
```c
void ft_putnbr_fd(int n, int fd);
Explication :
Transformer un nombre en caractÃ¨res et l'Ã©crire, chiffre par chiffre.

```
Interdictions :

âŒ Pas de fprintf

âœ… Ã‰criture manuelle obligatoire

ğŸ’¬ Bulle d'ami :
"Parler en chiffres, avec clartÃ© et prÃ©cision."

ğŸ¯ Mini-TDD :
Afficher 42 puis -12345 dans un fichier.

ğŸ“š RÃ©capitulatif rapide Partie 6 :

Fonction Ce que tu dois savoir faire
ft_putchar_fd Ã‰crire un caractÃ¨re dans un fichier
ft_putstr_fd Ã‰crire une chaÃ®ne dans un fichier
ft_putendl_fd Ã‰crire une chaÃ®ne avec saut de ligne
ft_putnbr_fd Ã‰crire un nombre entier

# Bloc 2 â€” Libft++ BoostÃ©e â€” Partie 7/? [ğŸŸ¢ Facile]
ğŸ“š Introduction rapide Partie 7
Ici, tu passes au niveau supÃ©rieur :
â” CrÃ©er et manipuler des listes chaÃ®nÃ©es en C.

Objectif :

Comprendre la mÃ©moire dynamique complexe,

CrÃ©er, ajouter, supprimer, parcourir des Ã©lÃ©ments reliÃ©s par des pointeurs,

ÃŠtre sÃ»r de la stabilitÃ© de ton code sans fuites mÃ©moire.

ğŸ“š Fonctions de cette Partie 7
## 7.0) ft_lstnew
Le but :
CrÃ©er un nouvel Ã©lÃ©ment de liste.

Prototype :

c
Copier
Modifier
```c
t_list *ft_lstnew(void *content);
Explication :
Allouer un Ã©lÃ©ment, lui donner son contenu, initialiser next Ã  NULL.

```
Interdictions :

âŒ Pas d'allocation automatique

âœ… malloc obligatoire

ğŸ’¬ Bulle d'ami :
"Chaque histoire commence par un premier chapitre."

ğŸ¯ Mini-TDD :
CrÃ©er un nouvel Ã©lÃ©ment contenant "hello".

## 7.1) ft_lstadd_front
Le but :
Ajouter un Ã©lÃ©ment au dÃ©but d'une liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstadd_front(t_list **lst, t_list *new);
Explication :
Modifier le next du nouvel Ã©lÃ©ment pour qu'il pointe sur l'ancienne tÃªte de liste.

```
Interdictions :

âŒ Pas de recrÃ©ation complÃ¨te

âœ… Simple manipulation des pointeurs

ğŸ’¬ Bulle d'ami :
"Parfois, le dernier arrivÃ© doit Ãªtre le premier servi."

ğŸ¯ Mini-TDD :
CrÃ©er une liste, ajouter un Ã©lÃ©ment devant, vÃ©rifier l'ordre.

## 7.2) ft_lstsize
Le but :
Compter le nombre d'Ã©lÃ©ments dans une liste.

Prototype :

c
Copier
Modifier
```c
int ft_lstsize(t_list *lst);
Explication :
Parcourir la liste en comptant les Ã©lÃ©ments jusqu'Ã  NULL.

```
Interdictions :

âŒ Pas de compter avec une fonction externe

âœ… Boucle manuelle obligatoire

ğŸ’¬ Bulle d'ami :
"Compter pour mieux comprendre la longueur du chemin."

ğŸ¯ Mini-TDD :
CrÃ©er 3 Ã©lÃ©ments liÃ©s et vÃ©rifier que ft_lstsize retourne 3.

## 7.3) ft_lstlast
Le but :
Trouver le dernier Ã©lÃ©ment d'une liste.

Prototype :

c
Copier
Modifier
t_list *ft_lstlast(t_list *lst);
Explication :
Avancer jusqu'Ã  l'Ã©lÃ©ment dont next est NULL.

Interdictions :

âŒ Pas de raccourcis

âœ… Traverser proprement

ğŸ’¬ Bulle d'ami :
"La fin d'une liste est toujours un point d'arrÃªt."

ğŸ¯ Mini-TDD :
VÃ©rifier que tu arrives sur le dernier Ã©lÃ©ment de ta liste.

## 7.4) ft_lstadd_back
Le but :
Ajouter un Ã©lÃ©ment Ã  la fin d'une liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstadd_back(t_list **lst, t_list *new);
Explication :
Trouver la fin et ajouter l'Ã©lÃ©ment.

```
Interdictions :

âŒ Pas de recrÃ©ation de liste

âœ… Manipuler les pointeurs

ğŸ’¬ Bulle d'ami :
"Ajoute ton histoire Ã  la fin du livre."

ğŸ¯ Mini-TDD :
CrÃ©er une liste, ajouter Ã  la fin, vÃ©rifier.

## 7.5) ft_lstdelone
Le but :
Supprimer un Ã©lÃ©ment de la liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstdelone(t_list *lst, void (*del)(void *));
Explication :
LibÃ©rer l'Ã©lÃ©ment et son contenu avec la fonction del.

```
Interdictions :

âŒ Pas de free seul

âœ… Utiliser del

ğŸ’¬ Bulle d'ami :
"Effacer proprement sans laisser de trace."

ğŸ¯ Mini-TDD :
Supprimer un Ã©lÃ©ment, vÃ©rifier pas de fuite mÃ©moire.

## 7.6) ft_lstclear
Le but :
Supprimer toute une liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstclear(t_list **lst, void (*del)(void *));
Explication :
Parcourir tous les Ã©lÃ©ments et les supprimer.

```
Interdictions :

âŒ Pas de fuite mÃ©moire

âœ… Suppression manuelle obligatoire

ğŸ’¬ Bulle d'ami :
"Un vrai nettoyage ne laisse rien derriÃ¨re."

ğŸ¯ Mini-TDD :
CrÃ©er 3 Ã©lÃ©ments, les clear et vÃ©rifier avec Valgrind.

## 7.7) ft_lstiter
Le but :
Appliquer une fonction Ã  chaque Ã©lÃ©ment de la liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstiter(t_list *lst, void (*f)(void *));
Explication :
Passer chaque Ã©lÃ©ment Ã  la fonction f.

```
Interdictions :

âŒ Pas de crÃ©ation de nouvelle liste

âœ… Agir en place

ğŸ’¬ Bulle d'ami :
"Chaque pierre tournÃ©e rÃ©vÃ¨le une nouvelle face."

ğŸ¯ Mini-TDD :
Modifier toutes les donnÃ©es d'une liste avec f.

## 7.8) ft_lstmap
Le but :
CrÃ©er une nouvelle liste en appliquant une fonction Ã  chaque Ã©lÃ©ment.

Prototype :

c
Copier
Modifier
```c
t_list *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));
Explication :
Appliquer f Ã  chaque contenu et crÃ©er une nouvelle liste.

```
Interdictions :

âŒ Pas de rÃ©utilisation d'anciennes donnÃ©es

âœ… Nouvelle allocation pour chaque Ã©lÃ©ment

ğŸ’¬ Bulle d'ami :
"Refaire un monde neuf Ã  partir des ruines."

ğŸ¯ Mini-TDD :
CrÃ©er une liste transformÃ©e Ã  partir d'une liste existante.

ğŸ“š RÃ©capitulatif rapide Partie 7 :

Fonction Ce que tu dois savoir faire
ft_lstnew CrÃ©er un Ã©lÃ©ment de liste
ft_lstadd_front Ajouter au dÃ©but
ft_lstsize Compter
ft_lstlast Trouver la fin
ft_lstadd_back Ajouter Ã  la fin
ft_lstdelone Supprimer un Ã©lÃ©ment
ft_lstclear Supprimer toute une liste
ft_lstiter Modifier chaque Ã©lÃ©ment existant
ft_lstmap CrÃ©er une nouvelle liste transformÃ©e

# Bloc 2 â€” Libft++ BoostÃ©e â€” Partie 8/8 [ğŸŸ¢ Facile]
ğŸ“š Introduction rapide Partie 8
Ici, tu vas :

Apprendre Ã  Ã©crire un Makefile propre,

Apprendre Ã  compiler ton projet automatiquement,

Mettre en place un vrai TDD complet,

Automatiser tes tests pour devenir solide et rigoureux.

Objectif :
â” Transformer ta Libft++ en un projet prÃªt Ã  Ãªtre livrÃ© en entreprise.

ğŸ“š Ce que tu vas faire
## 8.0) CrÃ©er un Makefile Pro
Ton Makefile devra :

Compiler tous les .c du dossier src/,

Placer les .o dans un dossier build/ (ou directement Ã  la racine si simple),

GÃ©nÃ©rer une librairie statique appelÃ©e libft.a,

Nettoyer (make clean), nettoyer complÃ¨tement (make fclean), recompiler (make re),

GÃ©rer correctement les dÃ©pendances (make all, make bonus si besoin).

ğŸ“‹ Plan minimal de ton Makefile

Cible Action
all Compile la libft.a
clean Supprime les fichiers .o
fclean Supprime .o + .a
re Relance clean + all
ğŸ“‹ Rappels trÃ¨s importants :

RÃ¨gle DÃ©tail
Nom du fichier Makefile (majuscule obligatoire)
Variables autorisÃ©es âœ… CC, CFLAGS, SRCS, OBJS, NAME
Commandes invisibles âœ… Utiliser @ pour cacher la commande
Interdictions âŒ Pas d'appels Ã  gcc sauvages en dehors des rÃ¨gles
## 8.1) Mettre en place un TDD Complet
Tu dois :

CrÃ©er un dossier tests/,

Dans tests/, avoir un fichier de test par fonction (tests_ft_strlen.c, etc.),

Chaque fichier doit :

Tester ta fonction avec des entrÃ©es valides,

Tester avec des cas limites (chaÃ®nes vides, NULL, etc.),

VÃ©rifier les erreurs possibles.

## 8.2) Automatiser l'exÃ©cution des tests
Ton objectif :

CrÃ©er une rÃ¨gle make tests,

Cette rÃ¨gle compile les tests,

Puis exÃ©cute les tests automatiquement,

Affiche clairement si les tests passent ou Ã©chouent.

(Tu pourras faire simple au dÃ©but, puis amÃ©liorer avec du vert/rouge plus tard.)

ğŸ“š Exemples simples de TDD attendu
Exemple Test - ft_strlen
c
Copier
Modifier
```c
# include "../include/libft.h"
# include <stdio.h>

```
void test_ft_strlen(void)
{
 if (ft_strlen("hello") != 5)
```c
 printf("âŒ Test ft_strlen(\"hello\") Ã©chouÃ©\n");
 else
 printf("âœ… Test ft_strlen(\"hello\") rÃ©ussi\n");

```
 if (ft_strlen("") != 0)
```c
 printf("âŒ Test ft_strlen(\"\") Ã©chouÃ©\n");
 else
 printf("âœ… Test ft_strlen(\"\") rÃ©ussi\n");
}
(Puis tu auras un main spÃ©cial pour tout exÃ©cuter dans tests/.)

```
ğŸ“š Arborescence finale attendue
plaintext
Copier
Modifier
libft/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ ft_strlen.c
â”‚ â”œâ”€â”€ ft_strcpy.c
â”‚ â””â”€â”€ (toutes tes fonctions)
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ libft.h
â”œâ”€â”€ tests/
â”‚ â”œâ”€â”€ tests_ft_strlen.c
â”‚ â”œâ”€â”€ tests_ft_strcpy.c
â”‚ â”œâ”€â”€ tests_main.c
â”œâ”€â”€ build/
â”‚ â”œâ”€â”€ (tous les fichiers .o)
â”œâ”€â”€ libft.a
ğŸ“‹ Checklist pour finaliser ta Libft++

Etape Fait ?
Toutes les fonctions codÃ©es ğŸŸ°
Header libft.h propre ğŸŸ°
Makefile propre ğŸŸ°
Tests TDD prÃ©sents ğŸŸ°
Tests automatiques ğŸŸ°
Nettoyage correct ğŸŸ°
Respect norme 42 (aucune faute norme) ğŸŸ°
Aucun warning Ã  la compilation ğŸŸ°
Structure propre ğŸŸ°

âœ… Bloc 2 Partie 8 â€” Libft++ BoostÃ©e terminÃ© proprement ! [ğŸŸ¢ Facile]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Bloc 3 â€” GNL++ BoostÃ© [ğŸŸ¡ IntermÃ©diaire]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“š Introduction Bloc 3 - Get Next Line [ğŸŸ¡ IntermÃ©diaire]
ğŸ¯ Objectif
Lire un fichier ligne par ligne, dynamiquement,

GÃ©rer correctement la mÃ©moire, les erreurs, les EOF (End Of File),

Savoir manipuler les buffers et les retours incomplets,

Respecter la norme 42 strictement.

ğŸ“š Ce que tu vas apprendre

Sujet CompÃ©tence
Buffers Lire par blocs (read)
Pointeurs complexes ConcatÃ©nation dynamique de mÃ©moire
Gestion de la mÃ©moire malloc, free, strjoin, strdup, etc.
Gestion d'erreur EOF, erreurs de lecture
Fonction robuste Fonction unique et rÃ©utilisable
ğŸš€ Prototype officiel de Get Next Line
c
Copier
Modifier
```c
char *get_next_line(int fd);
fd â” file descriptor du fichier Ã  lire.
Retour â” une ligne complÃ¨te terminÃ©e par \n ou la fin du fichier.

```
ğŸ“š Contraintes imposÃ©es

Interdits AutorisÃ©s
âŒ Pas d'utilisation de fopen, fgets, getline, etc. âœ… Seulement read, malloc, free
âŒ Pas de lib externe (sauf ta libft++) âœ… Tu peux utiliser tes propres fonctions (libft++)
âŒ Pas de fuite mÃ©moire âœ… Chaque appel de get_next_line gÃ¨re mÃ©moire proprement
ğŸ“‹ DÃ©tail de fonctionnement GNL++
ğŸ’¬ Comment Ã§a marche ?

Ã‰tape Action
1 Lire dans un buffer de taille fixe (ex: BUFFER_SIZE = 42)
2 Chercher un \n dans ce buffer
3 Extraire tout jusqu'au \n et garder le reste
4 Renvoyer une ligne complÃ¨te Ã  chaque appel
5 LibÃ©rer correctement tout Ã  la fin
ğŸ“š Fonctions que tu devrass recrÃ©er/utiliser

Fonction UtilitÃ©
ft_strlen Calculer longueur d'une chaÃ®ne
ft_strchr Chercher caractÃ¨re \n
ft_strdup Dupliquer une chaÃ®ne
ft_strjoin Joindre deux chaÃ®nes
ft_substr Extraire sous-chaÃ®ne
ğŸ“‹ Plan de ton code GNL++
Fichier principal :
get_next_line.c

get_next_line_utils.c

get_next_line.h

ğŸ“‹ Contenu minimal de get_next_line.h
c
Copier
Modifier
# ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

# include <unistd.h>
# include <stdlib.h>

```c
char *get_next_line(int fd);
char *ft_strjoin_gnl(char *s1, char *s2);
char *ft_strdup_gnl(const char *s);
char *ft_strchr_gnl(const char *s, int c);
size_t ft_strlen_gnl(const char *s);

```
# endif
ğŸ“š Mini explication stratÃ©gique
Exemple basique d'utilisation dans main.c :

c
Copier
Modifier
```c
# include "get_next_line.h"
# include <fcntl.h>
# include <stdio.h>

```
int main(void)
{
```c
 int fd = open("mon_fichier.txt", O_RDONLY);
 char *line;

```
 while ((line = get_next_line(fd)) != NULL)
 {
```c
 printf("%s", line);
 free(line);
 }
 close(fd);
 return (0);
}
ğŸ¯ TDD minimal attendu pour GNL++
Lire plusieurs fichiers simultanÃ©ment,

```
Tester fichier vide,

Tester fichier contenant seulement des sauts de lignes,

Tester fichiers gigantesques,

Tester gestion d'erreurs (fd invalide, etc.).

ğŸ“‹ Ã€ construire pour ton projet GNL++

Dossier Contenu
gnl/ ton code GNL (get_next_line.c, .h, etc.)
tests/ tests_get_next_line.c
Makefile pour compiler sÃ©parÃ©ment GNL

# Bloc 3 â€” GNL++ BoostÃ© â€” Partie 1/? [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Introduction rapide de Partie 1
Ici, on ne code pas tout d'un coup.
On construit GNL Ã©tape par Ã©tape, proprement, sans tricher :

Ã‰crire seulement les outils (utils) nÃ©cessaires,

Ensuite, construire la logique de lecture progressivement,

Enfin, assembler tout dans get_next_line.c.

ğŸ“‹ Premier objectif de Partie 1

Objectif immÃ©diat DÃ©tail
CrÃ©er uniquement les outils (utils) ft_strlen, ft_strchr, ft_strdup, ft_strjoin
On ne touche pas encore Ã  read() !
On construit juste ta "boÃ®te Ã  outils".

ğŸ“š Fonctions de cette Partie 1
## 3.1.0) ft_strlen_gnl
Le but :
Calculer la taille d'une chaÃ®ne (strlen) pour Get Next Line.

Prototype :

c
Copier
Modifier
```c
size_t ft_strlen_gnl(const char *s);
Explication :
Retourner combien de caractÃ¨res il y a avant \0.

```
Interdictions :

âŒ Pas d'appel Ã  strlen

âœ… Tout parcourir manuellement

ğŸ’¬ Bulle d'ami :
"Le silence (\0) marque toujours la fin du voyage."

ğŸ¯ Mini-TDD :
Tester "hello" â” 5, "" â” 0.

## 3.1.1) ft_strchr_gnl
Le but :
Trouver la premiÃ¨re occurrence d'un caractÃ¨re dans une chaÃ®ne.

Prototype :

c
Copier
Modifier
```c
char *ft_strchr_gnl(const char *s, int c);
Explication :
Chercher c dans s et retourner un pointeur dessus.

```
Interdictions :

âŒ Pas de strchr

âœ… Parcours manuel obligatoire

ğŸ’¬ Bulle d'ami :
"Trouver la premiÃ¨re Ã©toile sur ta carte."

ğŸ¯ Mini-TDD :
Chercher 'o' dans "bonjour" â” tomber sur le 2áµ‰ caractÃ¨re o.

## 3.1.2) ft_strdup_gnl
Le but :
Dupliquer une chaÃ®ne de caractÃ¨res.

Prototype :

c
Copier
Modifier
```c
char *ft_strdup_gnl(const char *s1);
Explication :
Allouer la mÃ©moire et copier la chaÃ®ne.

```
Interdictions :

âŒ Pas de strdup

âœ… Utiliser malloc + copie manuelle

ğŸ’¬ Bulle d'ami :
"CrÃ©er un double parfait sans vol d'identitÃ©."

ğŸ¯ Mini-TDD :
Dupliquer "Test" â” nouvelle adresse mÃ©moire, mÃªme contenu.

## 3.1.3) ft_strjoin_gnl
Le but :
Joindre deux chaÃ®nes ensemble.

Prototype :

c
Copier
Modifier
```c
char *ft_strjoin_gnl(char *s1, char *s2);
Explication :
Allouer une nouvelle chaÃ®ne contenant s1 puis s2.

```
Interdictions :

âŒ Pas de strcat

âœ… Construction manuelle obligatoire

ğŸ’¬ Bulle d'ami :
"Fusionner deux riviÃ¨res pour crÃ©er un fleuve."

ğŸ¯ Mini-TDD :
Joindre "abc" et "def" â” "abcdef".

ğŸ“š RÃ©sumÃ© de Partie 1 :

Fonction Ce que tu sais faire
ft_strlen_gnl Mesurer une chaÃ®ne
ft_strchr_gnl Chercher un caractÃ¨re
ft_strdup_gnl Dupliquer une chaÃ®ne
ft_strjoin_gnl Fusionner deux chaÃ®nes

# Bloc 3 â€” GNL++ BoostÃ©e â€” Partie 2/? [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Introduction rapide Partie 2
Maintenant que tu as ta boÃ®te Ã  outils (utils),
tu vas apprendre Ã  utiliser read() correctement.

On va construire la premiÃ¨re lecture et accumuler dynamiquement la mÃ©moire.

ğŸ“‹ Objectif immÃ©diat Partie 2

Objectif immÃ©diat DÃ©tail
ImplÃ©menter la lecture de BUFFER_SIZE octets âœ…
Accumuler dans une "stash" âœ…
DÃ©tecter quand une ligne complÃ¨te (\n) est prÃªte âœ…
ğŸ“š Ce que tu dois construire
## 3.2.0) GÃ©rer la lecture en blocs (BUFFER_SIZE)
Le but :

Lire par petits morceaux,

ConcatÃ©ner ce qui est lu au fur et Ã  mesure.

ğŸ“‹ Exemple logique interne simplifiÃ©e
c
Copier
Modifier
```c
// Lire BUFFER_SIZE octets
ret = read(fd, buffer, BUFFER_SIZE);

```
c
// Ajouter buffer lu Ã  la stash
stash = ft_strjoin_gnl(stash, buffer);
## 3.2.1) Comprendre la "stash" ğŸ“¦
DÃ©finition de stash :

```
ğŸ“¦ stash = contenu partiellement lu et mÃ©morisÃ©,

Chaque appel de get_next_line doit reprendre Ã  partir de lÃ  oÃ¹ il s'Ã©tait arrÃªtÃ©.

Situation Action
Pas de \n trouvÃ© Continuer Ã  lire et concatÃ©ner
\n trouvÃ© Couper et retourner une ligne
## 3.2.2) Lire en boucle jusqu'Ã  trouver une ligne complÃ¨te
Logique en pseudo-code :

c
Copier
Modifier
while (pas de '\n' trouvÃ© ET pas d'erreur)
{
 ret = read(fd, buffer, BUFFER_SIZE);
 si (erreur de read ou ret == 0)
 break;
 stash = ft_strjoin_gnl(stash, buffer);
}
ğŸ“š Petits dÃ©tails techniques

DÃ©tail Important
read() retourne le nombre d'octets lus (0 si fin de fichier, -1 si erreur)
Bien \0-terminer ton buffer aprÃ¨s chaque read 
Ne jamais oublier de free le buffer quand terminÃ© 
ğŸ¯ Mini plan d'action Partie 2
Lire BUFFER_SIZE octets,

Ajouter Ã  la stash,

Si \n est trouvÃ© â” STOP et prÃ©pare la ligne,

Sinon â” continue de lire.

ğŸ“‹ TDD minimal de Partie 2

Test Attendu
Fichier contenant plusieurs lignes longues Lire et retourner chaque ligne correctement
Fichier contenant peu de \n Accumuler le contenu correctement sans erreur
Fichier vide Retourner NULL sans crash

# Bloc 3 â€” GNL++ BoostÃ©e â€” Partie 3/? [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Introduction rapide Partie 3
Maintenant que tu sais lire et accumuler dans une stash,
il faut sÃ©parer la bonne ligne de tout ce qui reste dans la mÃ©moire.

C'est l'Ã©tape clÃ© qui transforme ton buffer en vraie ligne utilisable.

ğŸ“‹ Objectif immÃ©diat Partie 3

Objectif immÃ©diat DÃ©tail
Extraire la ligne jusqu'au premier \n âœ…
Garder le reste dans la stash pour plus tard âœ…
ğŸ“š Ce que tu dois construire
## 3.3.0) Extraire la ligne prÃªte
Le but :

Parcourir la stash,

Copier tout jusqu'Ã  et y compris le \n,

Retourner cette ligne.

ğŸ“‹ Exemple de logique
c
Copier
Modifier
trouver la position du premier '\n'
copier de 0 jusqu'Ã  cette position dans un nouveau malloc
ğŸ“‹ Petit rappel important :
Si pas de \n, et stash non vide, retourner tout ce qu'il reste,

Si stash vide, retourner NULL.

## 3.3.1) Garder le reste pour plus tard
Le but :

AprÃ¨s avoir extrait la ligne,

Ne pas oublier de :

Garder ce qu'il reste aprÃ¨s \n,

RÃ©initialiser proprement la stash.

ğŸ“‹ Exemple de logique
c
Copier
Modifier
stash = tout ce qui est aprÃ¨s '\n'
(Il faudra free l'ancienne stash avant de crÃ©er la nouvelle.)

ğŸ“š Astuces pour rÃ©ussir

Conseil Pourquoi
Utiliser ft_strchr_gnl Trouver facilement oÃ¹ couper
Utiliser ft_substr Extraire proprement une partie
Free ce qui est inutile Pour Ã©viter les fuites mÃ©moire
ğŸ¯ Mini plan d'action Partie 3
Chercher la position du premier \n,

Copier tout jusqu'Ã  \n dans la ligne Ã  retourner,

Copier le reste dans une nouvelle stash,

Free l'ancienne stash,

Retourner la ligne trouvÃ©e.

ğŸ“‹ TDD minimal Partie 3

Test Attendu
Lire un fichier de plusieurs lignes Chaque appel retourne exactement une ligne terminÃ©e par \n
DerniÃ¨re ligne sans \n Retourner la ligne restante mÃªme sans \n
Fichier vide Retourner NULL immÃ©diatement

# Bloc 3 â€” GNL++ BoostÃ©e â€” Partie 4/4 [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Objectif final de cette partie

Ã‰tape Description
âœ… Gestion du EOF Retourner NULL proprement Ã  la fin du fichier
âœ… Gestion des erreurs de read() Ne pas crasher, libÃ©rer mÃ©moire
âœ… LibÃ©ration mÃ©moire (free) Ã€ chaque sortie, tout doit Ãªtre propre
âœ… Code compact et clair RÃ©utilisable dans tous tes projets
âœ… RÃ©sumÃ© du comportement attendu de get_next_line

Cas Comportement
Appel normal avec ligne terminÃ©e par \n Retourne la ligne avec \n
Appel sur derniÃ¨re ligne sans \n Retourne le reste de la ligne
Fichier terminÃ© Retourne NULL
Erreur read() Retourne NULL et libÃ¨re tout
Plusieurs appels successifs Continue oÃ¹ Ã§a s'est arrÃªtÃ©
ğŸ“š Ã‰tapes internes Ã  vÃ©rifier dans ton code
ğŸ“¦ 1. Initialiser le buffer de lecture
Allouer BUFFER_SIZE + 1

VÃ©rifier le fd

Retourner NULL en cas de problÃ¨me

ğŸ” 2. Lire et accumuler (Partie 2)
Lire dans buffer

ConcatÃ©ner dans la stash

Continuer jusqu'Ã  trouver un \n ou EOF

âœ‚ï¸ 3. Extraire la ligne (Partie 3)
CrÃ©er une ligne allant jusqu'au premier \n

Retourner la ligne Ã  l'utilisateur

ğŸ“¦ 4. Nettoyer la stash
Garder ce qu'il reste aprÃ¨s le \n

Si plus rien â” stash = NULL

âŒ 5. GÃ©rer les erreurs
Si read retourne -1 â” free stash, buffer, retourner NULL

Ne jamais laisser de malloc sans free derriÃ¨re

ğŸ“‹ TDD Final pour valider ton GNL++

Test Ce que tu dois valider
Fichier normal Lecture ligne par ligne avec \n
Fichier sans retour Ã  la ligne final DerniÃ¨re ligne retournÃ©e proprement
Fichier vide Retourne NULL sans erreur
Fichier avec beaucoup de lignes Aucune fuite mÃ©moire (Valgrind âœ…)
Fichier non ouvert (fd = -1) Retourne NULL proprement
Appel multiple sur diffÃ©rents fd Chaque fd garde son Ã©tat (bonus)
âœ… Et maintenant ? Tu as un vrai GNL pro ğŸ¯
ğŸ“š Arborescence finale de ton projet GNL++
plaintext
Copier
Modifier
gnl/
â”œâ”€â”€ get_next_line.c
â”œâ”€â”€ get_next_line_utils.c
â”œâ”€â”€ get_next_line.h
â”œâ”€â”€ main.c
â”œâ”€â”€ Makefile

# Bloc 4 â€” Pipex++ BoostÃ© [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Objectif de Pipex++
Reproduire ce que fait un shell Linux quand on tape :

bash
Copier
Modifier
$ < infile cmd1 | cmd2 > outfile
Autrement dit :

Lire l'entrÃ©e depuis un fichier (infile),

Passer la sortie de cmd1 dans l'entrÃ©e de cmd2,

Envoyer la sortie finale dans outfile.

Tu dois :

Utiliser les pipes, forks, dup2, execve, etc.

GÃ©rer les erreurs systÃ¨me avec propretÃ©,

Devenir Ã  l'aise avec les processus Unix et les redirections.

ğŸ” RÃ©sultat attendu de ton programme
bash
Copier
Modifier
$ ./pipex infile "ls -l" "grep .c" outfile
Doit Ã©quivaloir Ã  :

bash
Copier
Modifier
$ < infile ls -l | grep .c > outfile
ğŸ“¦ Ã‰tapes gÃ©nÃ©rales

Ã‰tape Explication
1. Ouvrir infile open() en lecture
2. CrÃ©er un pipe() pour la communication entre les deux cmd
3. fork() le processus une fois pour chaque commande
4. Rediriger les entrÃ©es/sorties avec dup2() pour relier les commandes au pipe
5. ExÃ©cuter les commandes avec execve() passage des arguments et PATH
6. Fermer les fichiers et gÃ©rer les erreurs avec attention et rigueur
ğŸ“š Ã€ utiliser obligatoirement

Fonction UtilitÃ©
pipe() CrÃ©er un canal de communication
fork() CrÃ©er un nouveau processus
dup2() Dupliquer une stdin/stdout vers un pipe
execve() ExÃ©cuter une commande binaire
waitpid() Attendre que les enfants se terminent
access() VÃ©rifier qu'un fichier est accessible
ğŸ“š Ce que tu vas devoir implÃ©menter

Partie FonctionnalitÃ©
pipex.c Le point d'entrÃ©e principal
pipex_utils.c Fonctions outils: parsing, erreurs
pipex.h En-tÃªte de fonctions
parse_cmd.c SÃ©parer les arguments et prÃ©parer execve
error_handling.c Affichage et nettoyage des erreurs
ğŸ§ª TDD minimal Ã  mettre en place

Test Ce que tu vÃ©rifies
Fichier infile inexistant Message d'erreur clair, pas de segfault
Commande invalide Ne plante pas, affiche une erreur
Permissions refusÃ©es GÃ¨re correctement l'erreur
Plusieurs arguments dans les commandes Bien traitÃ©s
Redirection correcte de stdin et stdout RÃ©sultat final Ã©crit dans outfile
ğŸ“š Exemple de structure finale attendue
plaintext
Copier
Modifier
pipex/
â”œâ”€â”€ pipex.c
â”œâ”€â”€ pipex_utils.c
â”œâ”€â”€ parse_cmd.c
â”œâ”€â”€ error_handling.c
â”œâ”€â”€ pipex.h
â”œâ”€â”€ Makefile
â”œâ”€â”€ tests/
â”‚ â””â”€â”€ tests_pipex.sh

# Bloc 4 â€” Pipex++ BoostÃ© â€” Partie 1/? [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Introduction rapide Partie 1
Objectif immÃ©diat :
â” Lire les arguments passÃ©s Ã  ton programme
â” Ouvrir correctement infile et outfile

Sans entrer encore dans les pipes ou forks.

ğŸ“‹ Ce que tu vas faire maintenant

Ã‰tape Objectif
1 VÃ©rifier que tu reÃ§ois les bons arguments
2 Ouvrir infile en lecture
3 Ouvrir (ou crÃ©er) outfile en Ã©criture
ğŸ“š Plan prÃ©cis Bloc 4 Partie 1 [ğŸŸ¡ IntermÃ©diaire]
## 4.1.0) VÃ©rifier les arguments
Ton programme doit Ãªtre appelÃ© comme ceci :

bash
Copier
Modifier
./pipex infile "cmd1" "cmd2" outfile
Donc :

argv[0] = ./pipex

argv[1] = infile

argv[2] = cmd1

argv[3] = cmd2

argv[4] = outfile

ğŸ“‹ Mini-code (pas encore complet) pour vÃ©rifier
c
Copier
Modifier
if (argc != 5)
{
 write(2, "Error: wrong number of arguments\n", 33);
```c
 return (1);
}
## 4.1.1) Ouvrir infile
Utilise open() en lecture seule :

```
c
Copier
Modifier
```c
int infile_fd = open(argv[1], O_RDONLY);
if (infile_fd < 0)
{
 perror("Error opening infile");
 return (1);
}
## 4.1.2) Ouvrir (ou crÃ©er) outfile
Utilise open() avec ces flags :

```
O_CREAT: crÃ©er si n'existe pas,

O_WRONLY: Ã©criture uniquement,

O_TRUNC: Ã©craser le contenu si le fichier existe.

c
Copier
Modifier
```c
int outfile_fd = open(argv[4], O_CREAT | O_WRONLY | O_TRUNC, 0644);
if (outfile_fd < 0)
{
 perror("Error opening outfile");
 return (1);
}
(0644 = droits classiques lecture/Ã©criture pour l'utilisateur)

```
ğŸ¯ Mini rÃ©sumÃ© Ã©tape Partie 1

Action Ã€ vÃ©rifier
VÃ©rifier argc == 5 sinon erreur
Ouvrir infile en lecture avec gestion d'erreur
Ouvrir outfile en Ã©criture avec gestion d'erreur
ğŸ“‹ TDD minimal Bloc 4 Partie 1 [ğŸŸ¡ IntermÃ©diaire]

Test Attendu
Lancement sans 5 arguments Message d'erreur propre
Fichier infile inexistant Message d'erreur clair
Impossible d'ouvrir outfile Message d'erreur clair

# Bloc 4 â€” Pipex++ BoostÃ© â€” Partie 2/? [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Introduction rapide Partie 2
Maintenant que :

Tes arguments sont validÃ©s,

Tes fichiers infile et outfile sont ouverts,

Tu vas apprendre Ã  :

CrÃ©er un pipe (pipe()),

Dupliquer les entrÃ©es/sorties avec dup2() pour contrÃ´ler qui Ã©crit/lit.

ğŸ“‹ Objectif immÃ©diat Partie 2

Ã‰tape Objectif
1 CrÃ©er un pipe (pipe())
2 Forker pour exÃ©cuter cmd1
3 Rediriger l'entrÃ©e depuis infile et la sortie vers le pipe
4 PrÃ©parer Ã  exÃ©cuter la commande
ğŸ“š Ce que tu dois construire maintenant
## 4.2.0) CrÃ©er un pipe
Un pipe, c'est simplement un tableau de 2 entiers :

c
Copier
Modifier
```c
int pipefd[2];
if (pipe(pipefd) == -1)
{
 perror("pipe");
 return (1);
}
pipefd[0]: la lecture du pipe,

```
pipefd[1]: l'Ã©criture dans le pipe.

## 4.2.1) Forker
Un fork() crÃ©e deux processus :

Le parent continue normalement,

Le fils est un clone qui peut exÃ©cuter une autre commande.

c
Copier
Modifier
pid_t pid = fork();
if (pid == -1)
{
 perror("fork");
```c
 return (1);
}
## 4.2.2) Dans le fils â€” prÃ©paration pour cmd1
Le fils doit :

```
Rediriger son stdin depuis infile (via dup2(infile_fd, 0)),

Rediriger son stdout vers le pipe (via dup2(pipefd[1], 1)).

c
Copier
Modifier
if (pid == 0)
{
 dup2(infile_fd, 0); // Remplacer l'entrÃ©e standard par infile_fd
 dup2(pipefd[1], 1); // Remplacer la sortie standard par l'Ã©criture du pipe
 close(pipefd[0]); // Important ! Ne pas garder la lecture ouverte
```c
 // Ici: exÃ©cuter cmd1
}
## 4.2.3) Dans le parent â€” prÃ©paration pour cmd2
Le parent :

```
Va attendre plus tard,

Mais surtout prÃ©pare Ã  lire depuis le pipe.

ğŸ“‹ Attention importante

DÃ©tail Pourquoi
Toujours fermer les fd inutiles Sinon ton programme "pend" sur le pipe
AprÃ¨s dup2() tu n'as plus besoin des fd d'origine car les dup2 ont redirigÃ© les flux
ğŸ“š SchÃ©ma de fonctionnement
plaintext
Copier
Modifier
[infile] â†’ [cmd1] â†’ (pipe) â†’ [cmd2] â†’ [outfile]
ğŸ¯ Mini plan d'action Partie 2
CrÃ©er un pipe(),

fork() pour crÃ©er un processus enfant,

Dans le fils :

Rediriger stdin (dup2 infile),

Rediriger stdout (dup2 pipe Ã©criture),

Fermer les fd inutiles,

Dans le parent :

PrÃ©parer Ã  lancer cmd2 dans la prochaine partie.

ğŸ“‹ TDD minimal Bloc 4 Partie 2 [ğŸŸ¡ IntermÃ©diaire]

Test Attendu
Pipe est bien crÃ©Ã© Pas d'erreur
Fork se passe bien Deux processus crÃ©Ã©s
Redirection de stdin/stdout correcte Peut Ã©crire et lire

# Bloc 4 â€” Pipex++ BoostÃ© â€” Partie 3/? [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Introduction rapide Partie 3
Tu as maintenant :

CrÃ©Ã© ton pipe,

ForkÃ© ton premier processus,

RedirigÃ© correctement stdin et stdout.

Maintenant, dans ton fils, tu vas :

ExÃ©cuter vraiment la commande cmd1,

Transformer ton processus en cmd1 grÃ¢ce Ã  execve().

ğŸ“‹ Objectif immÃ©diat Partie 3

Ã‰tape Objectif
1 PrÃ©parer la commande et ses arguments
2 Trouver le chemin absolu de la commande
3 ExÃ©cuter avec execve()
4 GÃ©rer les erreurs d'exÃ©cution
ğŸ“š Ce que tu dois construire
## 4.3.0) PrÃ©parer la commande et ses arguments
RÃ©cupÃ©rer cmd1 (qui est une seule string "ls -l") :

Tu dois split cette string pour rÃ©cupÃ©rer :

"ls"

"-l"

Utilise ta fonction perso ft_split (ou un split Ã©quivalent).

c
Copier
Modifier
```c
char **args = ft_split(argv[2], ' ');
## 4.3.1) Trouver le chemin absolu de la commande
Le binaire "ls" n'est pas directement disponible. Tu dois chercher dans $PATH :

```

Ã‰tape Action
1 RÃ©cupÃ©rer la variable PATH de l'environnement (envp)
2 Split par: pour obtenir toutes les possibilitÃ©s
3 Tester chaque chemin en ajoutant /cmd
4 Utiliser access(path, X_OK) pour vÃ©rifier si c'est exÃ©cutable
(On fera une fonction spÃ©ciale find_path() bientÃ´t si tu veux.)

## 4.3.2) Appeler execve
Une fois que tu as :

Le chemin absolu de cmd1,

Les arguments (args),

tu fais simplement :

c
Copier
Modifier
execve(path, args, envp);
âš¡ Attention :
Si execve fonctionne, il ne revient jamais.
Si execve Ã©choue, tu dois :

free proprement tout,

exit(1).

ğŸ“š SchÃ©ma du processus cmd1
plaintext
Copier
Modifier
[infile] -> [fork fils] -> [redirection stdin, stdout] -> [execve(cmd1)]
ğŸ“‹ Exemple simplifiÃ©
c
Copier
Modifier
if (pid == 0)
{
 dup2(infile_fd, 0);
 dup2(pipefd[1], 1);
 close(pipefd[0]);
 close(pipefd[1]);
 args = ft_split(argv[2], ' ');
 path = find_path(args[0], envp);
 if (!path)
 {
 perror("command not found");
 exit(1);
 }
 execve(path, args, envp);
```c
 // Si execve Ã©choue
 perror("execve");
 exit(1);
}
ğŸ“š Rappels critiques

```
Point Pourquoi
Toujours free avant d'exiter si erreur Sinon fuite mÃ©moire
execve ne retourne jamais si rÃ©ussi Important de comprendre
ğŸ¯ Mini plan d'action Partie 3
Split cmd1,

Trouver le chemin absolu dans $PATH,

Appeler execve(path, args, envp),

En cas d'Ã©chec â” clean + exit(1).

ğŸ“‹ TDD minimal Bloc 4 Partie 3 [ğŸŸ¡ IntermÃ©diaire]

Test Ce que tu dois vÃ©rifier
Commande valide La commande s'exÃ©cute et sort dans le pipe
Commande invalide Message "command not found" propre
Plusieurs arguments dans cmd1 Correctement pris en compte

# Bloc 4 â€” Pipex++ BoostÃ© â€” Partie 4/4 [ğŸŸ¡ IntermÃ©diaire]
ğŸ“š Introduction rapide Partie 4
Maintenant que :

Ton fils exÃ©cute cmd1,

Ton pipe est prÃªt Ã  transfÃ©rer la sortie de cmd1 vers cmd2,

Tu dois :

Faire exÃ©cuter cmd2 dans le parent,

Lire depuis le pipe,

Ã‰crire dans outfile,

Nettoyer correctement.

ğŸ“‹ Objectif immÃ©diat Partie 4

Ã‰tape Objectif
1 Dans le parent, prÃ©parer la lecture du pipe
2 Forker Ã  nouveau pour exÃ©cuter cmd2
3 Rediriger correctement stdin et stdout
4 ExÃ©cuter cmd2 avec execve
ğŸ“š Ce que tu dois construire maintenant
## 4.4.0) Dans le parent aprÃ¨s fork
AprÃ¨s avoir lancÃ© cmd1, dans le processus parent :

Fermer pipefd[1] (on n'Ã©crit plus dedans),

Garder pipefd[0] pour la lecture.

## 4.4.1) Forker pour lancer cmd2
Tu refais un fork() pour un nouveau fils :

c
Copier
Modifier
pid_t pid2 = fork();
if (pid2 == -1)
{
 perror("fork");
```c
 return (1);
}
## 4.4.2) Dans le second fils â€” rediriger et exÃ©cuter cmd2
Dans ce second processus fils :

```
stdin doit venir de pipefd[0] (la sortie de cmd1),

stdout doit aller vers outfile_fd.

c
Copier
Modifier
if (pid2 == 0)
{
 dup2(pipefd[0], 0); // Lire depuis le pipe
 dup2(outfile_fd, 1); // Ã‰crire dans outfile
 close(pipefd[0]);
 close(outfile_fd);
 args = ft_split(argv[3], ' ');
 path = find_path(args[0], envp);
 if (!path)
 {
 perror("command not found");
 exit(1);
 }
 execve(path, args, envp);
 perror("execve");
 exit(1);
}
## 4.4.3) Dans le parent final
AprÃ¨s avoir forkÃ© le second fils :

Fermer tout ce qui reste,

Attendre les deux fils (waitpid()).

c
Copier
Modifier
close(pipefd[0]);
close(infile_fd);
close(outfile_fd);
waitpid(pid, NULL, 0);
waitpid(pid2, NULL, 0);
ğŸ“š RÃ©sumÃ© fonctionnement Pipex
plaintext
Copier
Modifier
[infile] â†’ [cmd1] â†’ (pipe) â†’ [cmd2] â†’ [outfile]
ğŸ“‹ SchÃ©ma global complet du projet Pipex
plaintext
Copier
Modifier
Parent Process
â”‚
â”œâ”€â”€ fork() --> Processus fils 1
â”‚ (stdin = infile, stdout = pipe[1], execve(cmd1))
â”‚
â”œâ”€â”€ Parent ferme pipe[1]
â”‚
â”œâ”€â”€ fork() --> Processus fils 2
â”‚ (stdin = pipe[0], stdout = outfile, execve(cmd2))
â”‚
â””â”€â”€ Parent ferme pipe[0], infile, outfile et attend les deux enfants
ğŸ¯ Mini plan d'action Partie 4
Forker second fils,

Rediriger entrÃ©es/sorties (dup2(pipe, infile) et dup2(outfile)),

ExÃ©cuter cmd2,

Parent nettoie tout et attend.

ğŸ“‹ TDD minimal Bloc 4 Partie 4 [ğŸŸ¡ IntermÃ©diaire]

Test Ce que tu dois vÃ©rifier
Commandes valides Sortie correcte dans outfile
Commandes invalides Erreurs affichÃ©es proprement
Permissions refusÃ©es GÃ©rÃ© sans crash
Plusieurs arguments dans cmd2 Ok

# Bloc 5 â€” Minishell++ BoostÃ© [ğŸŸ  AvancÃ©]
ğŸ“š Objectif de Minishell++
RecrÃ©er un vrai terminal Linux capable de :

Comprendre des commandes,

GÃ©rer des pipes (|),

GÃ©rer des redirections (>, <, >>),

GÃ©rer des variables d'environnement ($VAR),

GÃ©rer des erreurs proprement,

GÃ©rer des signaux (CTRL+C, CTRL+D).

ğŸ“‹ Ã€ terme, ton minishell devra permettre :

Exemple utilisateur Ton Minishell doit savoir faire
ls -l âœ… Affiche liste fichiers
cat < file.txt âœ… Lecture fichier
`grep hello wc -l`
echo hello > output.txt âœ… Redirection sortie
export VAR=value et echo $VAR âœ… Variables d'environnement
CTRL+C pour interrompre une commande âœ… Gestion signaux
ğŸ“š Les Ã©tapes majeures de Minishell++
1. Lire la ligne de commande
Utiliser readline() pour obtenir ce que tape l'utilisateur.

(Ou read et gestion maison si pas de readline au dÃ©but)

2. Parser correctement la commande

Action Objectif
SÃ©parer les mots et options âœ…
DÃ©tecter les pipes ` `
DÃ©tecter les redirections < > >> âœ…
ReconnaÃ®tre les quotes ' " " âœ…
GÃ©rer les variables d'environnement $VAR âœ…
3. ExÃ©cuter la commande

Action Objectif
Forker un processus âœ…
GÃ©rer redirections/fd correctement âœ…
ExÃ©cuter binaire ou built-in âœ…
4. ImplÃ©menter les "built-ins"
Un built-in est une commande interne Ã  ton shell (pas un binaire externe) :

Built-in attendu Fonction
echo Afficher un texte
cd Changer de rÃ©pertoire
pwd Afficher le rÃ©pertoire courant
export Ajouter une variable d'environnement
unset Supprimer une variable d'environnement
env Lister l'environnement
exit Quitter minishell
5. GÃ©rer correctement la mÃ©moire
Ã€ chaque commande :

LibÃ©rer tout ce qui doit l'Ãªtre (pas de fuite mÃ©moire).

SÃ©parer clairement parsing / exÃ©cution / destruction.

6. GÃ©rer les signaux

Signal Action
CTRL+C (SIGINT) Interrompre l'exÃ©cution d'une commande
CTRL+D (EOF) Quitter le shell proprement
ğŸ“¦ Organisation du projet attendue
plaintext
Copier
Modifier
minishell/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c
â”‚ â”œâ”€â”€ parser.c
â”‚ â”œâ”€â”€ executor.c
â”‚ â”œâ”€â”€ builtins.c
â”‚ â”œâ”€â”€ env.c
â”‚ â”œâ”€â”€ signals.c
â”‚ â”œâ”€â”€ utils.c
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ minishell.h
â”œâ”€â”€ tests/
â”‚ â”œâ”€â”€ tests_minishell.sh
â”œâ”€â”€ Makefile
ğŸ¯ Objectifs pÃ©dagogiques rÃ©els de Minishell
MaÃ®triser les processus UNIX (fork, execve, pipe),

MaÃ®triser l'allocation dynamique avancÃ©e,

Comprendre l'architecture d'un programme complexe,

Devenir autonome sur debug, gdb, valgrind.





ğŸ§© Module 3 â€” types/ â€” Types avancÃ©s, bitfields, union, enum [ğŸ“ Niveau Moyen Ã  AvancÃ©]
ğŸ“¦ Module types/ â€” Typologie avancÃ©e en langage C [ğŸ“ Moyen Ã  AvancÃ©]
ğŸ¯ Objectif pÃ©dagogique
Ce module a pour but de tâ€™enseigner des types plus complexes et plus puissants du C, souvent mÃ©connus mais indispensables en bas niveau, dans les protocoles, lâ€™embarquÃ© ou les OS :

typedef, pour amÃ©liorer la lisibilitÃ©

enum, pour dÃ©finir des constantes lisibles

union, pour partager la mÃ©moire entre types

bitfield, pour Ã©conomiser de la place et manipuler des bits

volatile, restrict, pour optimiser ou contrÃ´ler la compilation

ğŸ“š Concepts abordÃ©s
âœ… 1. typedef â€” CrÃ©er des alias
c
Copier
Modifier
typedef unsigned char t_byte;
typedef struct s_point {
    int x;
    int y;
} t_point;
â†’ AmÃ©liore la lisibilitÃ© dans les projets complexes.

âœ… 2. enum â€” Constantes lisibles et logiques
c
Copier
Modifier
enum e_state { OFF, ON, PAUSE };

enum e_state power = ON;
â†’ Remplace des #define, avec typage, debug facile, lisibilitÃ© ++.

âœ… 3. union â€” Partage mÃ©moire
c
Copier
Modifier
union u_data {
    int i;
    float f;
    char c[4];
};

union u_data d;
d.i = 42;
printf("%f\n", d.f); // InterprÃ©tation du mÃªme bloc mÃ©moire en float
â†’ UtilisÃ© dans : parsing binaire, protocoles, reprÃ©sentation polymorphe.

âœ… 4. bitfields â€” Occupation mÃ©moire minimale
c
Copier
Modifier
struct s_flags {
    unsigned a : 1;
    unsigned b : 1;
    unsigned c : 2;
};

struct s_flags f = {1, 0, 3};
â†’ Parfait pour gÃ©rer des flags, des octets binaires, ou des registres.

âœ… 5. Modificateurs spÃ©ciaux
volatile :
EmpÃªche les optimisations â†’ utile en accÃ¨s mÃ©moire directe (hardware, signal, thread)

c
Copier
Modifier
volatile int status; // lu Ã  chaque fois dans la RAM, jamais mis en cache
restrict (C99) :
Indique au compilateur quâ€™un pointeur est seul Ã  accÃ©der Ã  une mÃ©moire

c
Copier
Modifier
void add(int *restrict a, int *restrict b);
â†’ Optimise certaines boucles (prÃ©caution requise).

ğŸ§ª Exercices
ğŸ“‚ types/ex00 â€” Structure et typedef
CrÃ©e une struct t_point { int x, y; } avec un typedef, initialise-la et affiche-la.

ğŸ“‚ types/ex01 â€” Utilisation de enum
DÃ©finir un enum e_direction (NORTH, SOUTH, EAST, WEST). CrÃ©er une fonction print_direction(enum e_direction).

ğŸ“‚ types/ex02 â€” union et interprÃ©tation binaire
Utilise une union pour lire un entier comme tableau de char.

c
Copier
Modifier
union {
    int i;
    char c[4];
} u;

u.i = 0x12345678;
printf("%x %x %x %x\n", u.c[0], u.c[1], u.c[2], u.c[3]);
â†’ Permet dâ€™aborder la notion dâ€™endianess (bonus).

ğŸ“‚ types/ex03 â€” bitfields
CrÃ©er une struct s_flags avec 4 bits : is_active, is_visible, is_dirty, reserved.
Affiche leur Ã©tat.

ğŸ“‚ types/ex04 â€” volatile et optimisation
Comparer deux versions dâ€™un compteur while (!flag);
â†’ Dans l'une, flag est volatile, dans lâ€™autre non. Compiler avec -O2.

ğŸ”¬ Bonus : visualisation mÃ©moire
Comparer la taille de struct, union, bitfield

Afficher les offsets avec offsetof() et sizeof()






# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 1/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Commencer simple mais propre :
â” Lire une ligne de commande tapÃ©e par l'utilisateur.

Sans parsing encore, sans exÃ©cution â€” juste lire et afficher.

ğŸ“‹ Ce que tu dois faire dans cette Partie

Ã‰tape Objectif
1 Afficher un prompt (ex: minishell$ )
2 Lire une ligne tapÃ©e par l'utilisateur
3 Afficher ce qui a Ã©tÃ© tapÃ©
4 RÃ©pÃ©ter indÃ©finiment (boucle infinie)
ğŸ“š Les fonctions utiles pour Ã§a
## Option 1: Avec readline (pro)
readline() permet :

D'avoir un historique de commandes,

Un affichage clean,

Une gestion des touches clavier amÃ©liorÃ©e.

ğŸ› ï¸ Librairie Ã  linker avec -lreadline.

Prototype readline :

c
Copier
Modifier
```c
char *readline(const char *prompt);
## Option 2: Sans readline (manuel)
Si tu ne veux pas utiliser readline tout de suite :

```
Utiliser write(1, "minishell$ ", 11);

Lire avec get_next_line(0); (si tu as codÃ© ton GNL)

Ou avec read(0, buffer, size); (manuel)

ğŸ“‹ Exemple minimal avec readline
c
Copier
Modifier
```c
# include <stdio.h>
# include <readline/readline.h>
# include <readline/history.h>

```
int main(void)
{
```c
 char *input;

```
 while (1)
 {
 input = readline("minishell$ ");
 if (!input) // Gestion de CTRL+D
 {
```c
 printf("exit\n");
 break;
 }
 if (*input) // Ne pas ajouter de vide Ã  l'historique
 add_history(input);
 printf("Vous avez tapÃ©: %s\n", input);
 free(input);
 }
 return (0);
}
ğŸ“‹ Ce qu'on apprend ici

```
Sujet Pourquoi c'est important
Boucle infinie Un shell ne s'arrÃªte jamais (sauf exit)
Lecture propre Pour pouvoir parser/exÃ©cuter aprÃ¨s
LibÃ©ration de mÃ©moire Aucune fuite dÃ¨s maintenant
Gestion de CTRL+D Car c'est standard sur Unix
ğŸ¯ Mini-plan d'action Partie 1
Boucle infinie (while (1)),

Lire la ligne de commande (avec readline),

Afficher la commande,

LibÃ©rer la mÃ©moire,

GÃ©rer CTRL+D (readline retourne NULL).

ğŸ“‹ TDD minimal Bloc 5 Partie 1 [ğŸŸ  AvancÃ©]

Test Attendu
Tapez une commande normale S'affiche correctement
Appuyez sur CTRL+D Affiche "exit" et quitte
Spammez la mÃ©moire Pas de fuite mÃ©moire (valgrind âœ…)

# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 2/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Maintenant que tu sais lire une ligne,
â” Tu vas analyser (parser) cette ligne,
â” DÃ©couper correctement les mots (= commande + options).

Pas encore de pipes ni de redirections ici â€” juste du dÃ©coupage propre.

ğŸ“‹ Ce que tu dois faire dans cette Partie

Ã‰tape Objectif
1 Splitter la ligne tapÃ©e en tokens/mots
2 GÃ©rer correctement les espaces
3 Stocker les mots dans un tableau de chaÃ®nes
4 PrÃ©parer pour exÃ©cuter aprÃ¨s
ğŸ“š Les fonctions utiles pour parser
ğŸ“¦ Avec ta fonction ft_split
Si tu as une fonction type ft_split() :

c
Copier
Modifier
```c
char **ft_split(char const *s, char c);
Alors tu peux dÃ©couper la ligne tapÃ©e par l'utilisateur en mots en utilisant ' ' (espace) comme sÃ©parateur.

```
Exemple :

c
Copier
Modifier
```c
char **tokens = ft_split(input, ' ');
ğŸ“‹ Ce que tu obtiens
Pour une ligne :

```
bash
Copier
Modifier
ls -l /home/user
AprÃ¨s split, tu obtiens :

c
Copier
Modifier
tokens[0] = "ls"
tokens[1] = "-l"
tokens[2] = "/home/user"
tokens[3] = NULL
ğŸ“‹ Gestion spÃ©ciale des espaces multiples
Ton ft_split doit pouvoir :

Ignorer les espaces multiples consÃ©cutifs,

Ne pas crÃ©er de token vide.

ğŸ“‹ Petit exemple pour vÃ©rifier
c
Copier
Modifier
```c
// ligne lue
input = " ls -la /etc ";

```
c
// aprÃ¨s split
tokens[0] = "ls"
tokens[1] = "-la"
tokens[2] = "/etc"
tokens[3] = NULL
âœ… Aucun token vide, mÃªme s'il y avait plein d'espaces au dÃ©but ou entre les mots.

```
ğŸ“‹ Mini-code simplifiÃ©
c
Copier
Modifier
char **parse_line(char *input)
{
```c
 return (ft_split(input, ' '));
}
ğŸ“š Mini-piÃ¨ges Ã  Ã©viter

```
Erreur possible Solution
CrÃ©er un token vide quand plusieurs espaces Corriger ton ft_split
Oublier de NULL-terminer ton tableau Toujours terminer par un NULL
Ne pas free l'ancien input avant de parser une nouvelle ligne Toujours nettoyer
ğŸ“‹ Exemple simplifiÃ© d'utilisation
c
Copier
Modifier
```c
char *input = readline("minishell$ ");
char **tokens = parse_line(input);

```
c
// Afficher tous les tokens
for (int i = 0; tokens[i]; i++)
 printf("token[%d] = %s\n", i, tokens[i]);

```
c
// Free tokens aprÃ¨s utilisation !
free_tokens(tokens);
free(input);
(free_tokens() = fonction qui libÃ¨re chaque string + le tableau.)

```
ğŸ¯ Mini plan d'action Partie 2
Lire la ligne de commande,

Splitter avec ft_split(' '),

Stocker dans char **tokens,

VÃ©rifier et afficher chaque token,

LibÃ©rer tout correctement.

ğŸ“‹ TDD minimal Bloc 5 Partie 2 [ğŸŸ  AvancÃ©]

Test Attendu
Ligne simple (ls -l) Tokens OK
Ligne vide (" ") Aucun token
Ligne avec plusieurs espaces Aucun token vide
Valgrind sur boucle infinie ZÃ©ro fuite mÃ©moire

# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 3/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Maintenant que :

Tu lis une ligne de commande,

Tu parses correctement en tokens,

â” Il est temps d'exÃ©cuter vraiment la commande via un fork/execve.

ğŸ“‹ Ce que tu dois faire dans cette Partie

Ã‰tape Objectif
1 Forker ton shell pour exÃ©cuter la commande
2 Utiliser execve() pour lancer la commande
3 GÃ©rer les erreurs si la commande est introuvable
4 Attendre la fin de l'exÃ©cution (waitpid)
ğŸ“š Les fonctions Ã  utiliser
ğŸ“¦ Forker avec fork()
c
Copier
Modifier
pid_t pid = fork();
pid == 0 â” tu es dans l'enfant â” lance la commande,

pid > 0 â” tu es dans le parent â” attends que l'enfant finisse.

ğŸ“¦ ExÃ©cuter la commande avec execve()
Prototype :

c
Copier
Modifier
```c
int execve(const char *pathname, char *const argv[], char *const envp[]);
pathname: chemin absolu ou relatif vers la commande (/bin/ls par exemple),

```
argv: tableau de chaÃ®nes (tokens que tu as dÃ©jÃ ),

envp: tableau des variables d'environnement (passÃ© au main gÃ©nÃ©ralement).

ğŸ“¦ Attendre l'enfant avec waitpid()
c
Copier
Modifier
waitpid(pid, NULL, 0);
ğŸ“‹ SchÃ©ma global d'exÃ©cution
plaintext
Copier
Modifier
Parent Minishell
â”‚
â”œâ”€â”€ fork() -> Fils
â”‚ â”œâ”€â”€ execve(path, tokens, envp)
â”‚ â””â”€â”€ (ne revient pas si succÃ¨s)
â”‚
â””â”€â”€ Parent attend la fin du fils (waitpid)
ğŸ“š Trouver le chemin absolu (/bin/ls, etc.)
Dans un vrai shell, si l'utilisateur tape juste ls,
tu dois :

Chercher dans $PATH,

Tester chaque dossier jusqu'Ã  trouver ls.

Exemple de PATH :

bash
Copier
Modifier
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
(SÃ©parÃ© par :)

ğŸ“‹ Mini plan rapide
RÃ©cupÃ©rer PATH dans envp,

Split PATH avec :,

Pour chaque dossier :

Joindre / + cmd,

Tester avec access(path, X_OK),

Si trouvÃ©, utiliser execve(path, tokens, envp).

ğŸ“‹ Exemple de code simplifiÃ©
c
Copier
Modifier
pid_t pid = fork();
if (pid == 0)
{
```c
 char *path = find_path(tokens[0], envp); // fonction Ã  Ã©crire
 if (!path)
 {
 printf("Command not found: %s\n", tokens[0]);
 exit(1);
 }
 execve(path, tokens, envp);
 perror("execve"); // Ne devrait jamais arriver si execve rÃ©ussi
 exit(1);
}
else if (pid > 0)
{
 waitpid(pid, NULL, 0);
}
else
{
 perror("fork");
}
ğŸ“š Gestion des erreurs

```
Cas Action
Commande introuvable Message d'erreur
execve Ã©choue Message d'erreur
Fork Ã©choue Message d'erreur et exit
ğŸ“š Bonus: petite fonction find_path
c
Copier
Modifier
char *find_path(char *cmd, char **envp)
{
```c
 // Ã€ coder: rÃ©cupÃ©rer PATH dans envp, split, tester chaque chemin avec access()
}
(Je peux te la dÃ©tailler si tu veux aprÃ¨s.)

```
ğŸ¯ Mini plan d'action Partie 3
Forker,

Dans l'enfant: chercher chemin + execve,

Dans le parent: attendre,

Gestion correcte des erreurs.

ğŸ“‹ TDD minimal Bloc 5 Partie 3 [ğŸŸ  AvancÃ©]

Test Attendu
ls -l fonctionne âœ…
Commande invalide (fakecmd) Affiche "command not found"
Plus de 10 exÃ©cutions Pas de fuite mÃ©moire

# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 4/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Maintenant que tu sais :

Lire une commande,

Parser les mots,

Forker et exÃ©cuter un programme,

Tu vas apprendre Ã  gÃ©rer les pipes (|) :
â” connecter deux (ou plusieurs) commandes ensemble, comme dans un vrai shell.

ğŸ“‹ Ce que tu vas faire dans cette Partie

Ã‰tape Objectif
1 DÃ©tecter les pipes dans la ligne de commande
2 Couper la commande en segments entre les `
3 CrÃ©er un pipe() pour chaque liaison
4 Forker pour chaque commande sÃ©parÃ©e
5 Rediriger les entrÃ©es/sorties avec dup2()
6 Lancer chaque commande avec execve()
ğŸ“š SchÃ©ma d'exemple
Pour :

bash
Copier
Modifier
ls -l | grep .c | wc -l
Ton minishell doit crÃ©er :

plaintext
Copier
Modifier
[Processus 1] ls -l â†’ Ã©crit dans pipe1 â†’ 
[Processus 2] grep .c â†’ Ã©crit dans pipe2 â†’
[Processus 3] wc -l â†’ Ã©crit dans stdout
ğŸ“‹ Comment fonctionnent les pipes
Chaque pipe() te donne deux fd :

pipefd[0] â” lecture,

pipefd[1] â” Ã©criture.

Tu dois :

Relier stdout du processus actuel Ã  pipefd[1],

Relier stdin du prochain processus Ã  pipefd[0].

ğŸ“š Plan d'implÃ©mentation
ğŸ“¦ Ã‰tape 1: Parser sur les |
Quand tu lis la commande complÃ¨te, tu dois split en commandes sÃ©parÃ©es par |.

Exemple :

c
Copier
Modifier
```c
// Ligne: "ls -l | grep .c | wc -l"
commands[0] = "ls -l"
commands[1] = "grep .c"
commands[2] = "wc -l"
commands[3] = NULL
(On peut faire un ft_split_pipe personnalisÃ© si besoin.)

```
ğŸ“¦ Ã‰tape 2: CrÃ©er une boucle sur les commandes
Tu crÃ©es une boucle pour :

CrÃ©er un pipe,

Forker,

Rediriger correctement.

ğŸ“¦ Ã‰tape 3: Dans chaque processus

Si c'est... Tu fais...
Premier processus Lire depuis stdin normal, Ã©crire dans pipe
Processus du milieu Lire depuis le pipe prÃ©cÃ©dent, Ã©crire dans un nouveau pipe
Dernier processus Lire depuis le pipe prÃ©cÃ©dent, Ã©crire vers stdout
ğŸ“‹ Code conceptuel ultra simplifiÃ©
c
Copier
Modifier
```c
int pipefd[2];
int prev_fd = 0; // au dÃ©but stdin

```
for (chaque commande)
{
 pipe(pipefd);
 pid = fork();
 if (pid == 0)
 {
 dup2(prev_fd, 0); // lire depuis prev_fd
 if (il y a une autre commande aprÃ¨s)
 dup2(pipefd[1], 1); // Ã©crire dans le pipe actuel
 close(pipefd[0]);
 close(pipefd[1]);
 execve(cmd);
 }
 else
 {
 close(pipefd[1]); // ne plus Ã©crire ici
 prev_fd = pipefd[0]; // pour la prochaine commande
 }
}
waitpid pour tous les enfants
ğŸ“š RÃ©sumÃ© super clair
plaintext
Copier
Modifier
[stdin] -> [cmd1] -> (pipe) -> [cmd2] -> (pipe) -> [cmd3] -> [stdout]
Chaque pipe connecte deux commandes.

ğŸ“‹ DÃ©tails critiques

Astuce Pourquoi
Toujours fermer ce que tu n'utilises pas Sinon bloquÃ©
GÃ©rer correctement tous les dup2() Sinon la commande ne lit/Ã©crit pas au bon endroit
LibÃ©rer toutes les mÃ©moires inutilisÃ©es Pas de fuite
ğŸ¯ Mini plan d'action Partie 4
Split sur | pour rÃ©cupÃ©rer chaque commande,

Pour chaque commande :

CrÃ©er un pipe,

Forker,

Rediriger fd avec dup2,

ExÃ©cuter commande,

Fermer les pipes inutiles,

Parent attend tous les enfants.

ğŸ“‹ TDD minimal Bloc 5 Partie 4 [ğŸŸ  AvancÃ©]

Test Attendu
`ls wc -l`
`cat file grep hello`
`ls grep .c
Commande fausse au milieu Shell continue correctement

# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 5/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Maintenant que :

Tu sais lire, parser, exÃ©cuter une commande,

Tu sais gÃ©rer plusieurs commandes avec des pipes,

Tu vas apprendre Ã  gÃ©rer les redirections :

> (Ã©criture dans un fichier),

>> (Ã©criture en ajout Ã  un fichier),

< (lecture d'un fichier).

ğŸ“‹ Ce que tu vas faire dans cette Partie

Ã‰tape Objectif
1 DÃ©tecter les opÃ©rateurs de redirection
2 Ouvrir correctement les fichiers
3 Rediriger l'entrÃ©e ou la sortie avec dup2()
4 Nettoyer correctement
ğŸ“š Les types de redirection
1. Sortie standard vers fichier (>)
Exemple :

bash
Copier
Modifier
echo hello > file.txt
Ouvre file.txt en Ã©criture (O_WRONLY | O_CREAT | O_TRUNC),

Remplace stdout (fd 1) par le fd du fichier.

2. Sortie standard vers fichier en ajout (>>)
Exemple :

bash
Copier
Modifier
echo hello >> file.txt
Ouvre file.txt en Ã©criture (O_WRONLY | O_CREAT | O_APPEND),

Remplace stdout (fd 1) par le fd du fichier.

3. EntrÃ©e standard depuis un fichier (<)
Exemple :

bash
Copier
Modifier
cat < file.txt
Ouvre file.txt en lecture (O_RDONLY),

Remplace stdin (fd 0) par le fd du fichier.

ğŸ“š Le cycle de redirection gÃ©nÃ©ral

Ã‰tape Action
Lire la commande et dÃ©tecter les redirections 
Ouvrir le fichier correspondant 
dup2(fd_fichier, 0) ou dup2(fd_fichier, 1) 
Fermer l'ancien fd_fichier 
ExÃ©cuter normalement la commande (execve) 
ğŸ“‹ Exemple de logique pour gÃ©rer > :
c
Copier
Modifier
```c
int fd = open("file.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
if (fd < 0)
{
 perror("open");
 exit(1);
}
dup2(fd, 1);
close(fd);
execve(...);
ğŸ“š Parsing spÃ©cial pour dÃ©tecter redirections
Ton parseur doit :

```
RepÃ©rer > ou >> ou <,

Savoir quel mot est la commande, quel mot est un fichier,

Nettoyer la liste des arguments avant execve (en retirant les >, >>, < et le fichier associÃ©).

ğŸ“‹ Exemples concrets de parsing :
1. Simple redirection
EntrÃ©e utilisateur :

bash
Copier
Modifier
echo hello > file.txt
Parser rÃ©sultat :

plaintext
Copier
Modifier
commande: echo
arguments: hello
redirection: > file.txt
2. Double redirection
EntrÃ©e utilisateur :

bash
Copier
Modifier
cat < input.txt > output.txt
Parser rÃ©sultat :

plaintext
Copier
Modifier
commande: cat
redirection 1: < input.txt
redirection 2: > output.txt
ğŸ“‹ Points techniques essentiels

PiÃ¨ge Solution
Oublier de fermer le fd du fichier ouvert Toujours close aprÃ¨s dup2
Tenter d'exÃ©cuter les arguments > file Nettoyer la liste avant execve
Ne pas traiter les >> diffÃ©remment de > Toujours tester > ET >>
ğŸ¯ Mini plan d'action Partie 5
Modifier le parseur pour dÃ©tecter < > >>,

Ouvrir correctement le ou les fichiers,

Rediriger avec dup2(),

Nettoyer les arguments envoyÃ©s Ã  execve,

ExÃ©cuter normalement la commande.

ğŸ“‹ TDD minimal Bloc 5 Partie 5 [ğŸŸ  AvancÃ©]

Test Attendu
echo hello > file.txt file.txt contient "hello"
cat < file.txt Lit file.txt
echo hello >> file.txt Ajoute "hello" Ã  la fin
Redirection impossible (dossier en Ã©criture) Erreur propre
Pas de fuite mÃ©moire OK Valgrind

# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 6/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Maintenant que :

Tu sais lire, parser, exÃ©cuter,

Tu gÃ¨res les pipes et redirections,

Tu vas ajouter les built-ins â” les commandes que ton shell exÃ©cute lui-mÃªme, sans passer par execve.

ğŸ“‹ Ce que tu dois faire dans cette Partie

Ã‰tape Objectif
1 DÃ©tecter si la commande est un built-in
2 ExÃ©cuter directement le code du built-in
3 Ne pas forker inutilement pour certains built-ins (cd, exit)
4 GÃ©rer correctement l'environnement (export, unset, etc.)
ğŸ“š La liste officielle des built-ins Ã  implÃ©menter
ğŸ“¦ echo
RÃ©pÃ©ter ce qui suit,

GÃ©rer -n (pas de saut de ligne final).

Exemple :

bash
Copier
Modifier
echo hello world
echo -n hello
ğŸ“¦ cd
Changer de rÃ©pertoire courant.

Modifier $PWD et $OLDPWD.

Exemple :

bash
Copier
Modifier
cd /home/user
ğŸ“¦ pwd
Afficher le chemin absolu actuel.

Exemple :

bash
Copier
Modifier
pwd
ğŸ“¦ export
Ajouter ou modifier une variable d'environnement.

Exemple :

bash
Copier
Modifier
export VAR=value
ğŸ“¦ unset
Supprimer une variable d'environnement.

Exemple :

bash
Copier
Modifier
unset VAR
ğŸ“¦ env
Afficher toutes les variables d'environnement existantes.

Exemple :

bash
Copier
Modifier
env
ğŸ“¦ exit
Fermer minishell proprement.

Exemple :

bash
Copier
Modifier
exit
exit 42
ğŸ“š Mini-stratÃ©gie pour gÃ©rer les built-ins
ğŸ“‹ 1. Avant de forker: tester si la commande est un built-in
Si oui â” appeler la fonction correspondante directement.

Si non â” forker et utiliser execve.

ğŸ“‹ 2. ImplÃ©menter une fonction is_builtin()
Exemple :

c
Copier
Modifier
int is_builtin(char *cmd)
{
```c
 if (!strcmp(cmd, "echo")) return (1);
 if (!strcmp(cmd, "cd")) return (1);
 if (!strcmp(cmd, "pwd")) return (1);
 if (!strcmp(cmd, "export")) return (1);
 if (!strcmp(cmd, "unset")) return (1);
 if (!strcmp(cmd, "env")) return (1);
 if (!strcmp(cmd, "exit")) return (1);
 return (0);
}
ğŸ“‹ 3. Dispatcher les commandes
Dans ton exÃ©cution principale :

```
c
Copier
Modifier
if (is_builtin(tokens[0]))
 exec_builtin(tokens, envp);
else
{
 pid = fork();
 if (pid == 0)
 execve(...);
 else
 waitpid(pid, NULL, 0);
}
ğŸ“š DÃ©tails particuliers

Built-in Attention spÃ©ciale
cd Modifier $PWD en interne
exit Quitter immÃ©diatement minishell (pas aprÃ¨s fork)
export / unset Modifier directement ton tableau d'environnement
ğŸ“‹ Exemple de dispatcher de built-ins
c
Copier
Modifier
void exec_builtin(char **tokens, char ***envp)
{
 if (!strcmp(tokens[0], "echo"))
 ft_echo(tokens + 1);
 else if (!strcmp(tokens[0], "cd"))
 ft_cd(tokens[1], envp);
 else if (!strcmp(tokens[0], "pwd"))
 ft_pwd();
 else if (!strcmp(tokens[0], "export"))
 ft_export(tokens + 1, envp);
 else if (!strcmp(tokens[0], "unset"))
 ft_unset(tokens + 1, envp);
 else if (!strcmp(tokens[0], "env"))
 ft_env(*envp);
 else if (!strcmp(tokens[0], "exit"))
 ft_exit(tokens);
}
ğŸ“š Structure recommandÃ©e
plaintext
Copier
Modifier
src/
â”œâ”€â”€ builtins/
â”‚ â”œâ”€â”€ echo.c
â”‚ â”œâ”€â”€ cd.c
â”‚ â”œâ”€â”€ pwd.c
â”‚ â”œâ”€â”€ export.c
â”‚ â”œâ”€â”€ unset.c
â”‚ â”œâ”€â”€ env.c
â”‚ â”œâ”€â”€ exit.c
ğŸ“š Mini-astuces pour rÃ©ussir

Astuce Pourquoi
Ne pas forker pour exit, cd, export, unset Sinon tu modifies un fils inutilement
Penser Ã  errno pour les erreurs cohÃ©rent avec UNIX
Penser Ã  libÃ©rer la mÃ©moire de l'environnement si modifiÃ© Ã©viter fuite mÃ©moire
ğŸ¯ Mini plan d'action Partie 6
DÃ©tecter les built-ins avec is_builtin(),

Appeler la fonction appropriÃ©e directement,

ImplÃ©menter echo, pwd, env (simples),

ImplÃ©menter cd, export, unset, exit (plus costauds).

ğŸ“‹ TDD minimal Bloc 5 Partie 6 [ğŸŸ  AvancÃ©]

Test Attendu
echo hello Affiche hello
cd /tmp + pwd Affiche /tmp
export VAR=hello + echo $VAR Affiche hello
unset VAR + echo $VAR Rien
exit Quitte correctement

# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 7/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Maintenant que :

Tu sais exÃ©cuter des commandes,

Tu sais gÃ©rer les built-ins,

â” Il est temps de bien gÃ©rer l'environnement (envp) :

Lire,

Modifier (export, unset),

Remplacer les variables $VAR dans les commandes.

ğŸ“‹ Ce que tu dois faire dans cette Partie

Ã‰tape Objectif
1 Stocker proprement les variables d'environnement (envp)
2 GÃ©rer export (ajouter / modifier une variable)
3 GÃ©rer unset (supprimer une variable)
4 Remplacer $VAR dans les lignes de commande avant exÃ©cution
5 Afficher env correctement
ğŸ“š Comment stocker l'environnement
Au dÃ©marrage de ton minishell :

Copie le char **envp que reÃ§oit ton main,

Stocke-le dans ta propre structure,

Travaille toujours dessus ensuite.

ğŸ“‹ Exemple simple :
c
Copier
Modifier
char **copy_envp(char **envp)
{
```c
 int i = 0;
 char **new_env;
 
```
 while (envp[i])
 i++;
```c
 new_env = malloc(sizeof(char *) * (i + 1));
 i = 0;
 while (envp[i])
 {
 new_env[i] = strdup(envp[i]);
 i++;
 }
 new_env[i] = NULL;
 return (new_env);
}
ğŸ“š GÃ©rer export
ğŸ“‹ Quand tu tapes :
bash
Copier
Modifier
export VAR=42
Tu dois :

```
Chercher si VAR existe dÃ©jÃ  dans envp,

Si oui â” remplacer sa valeur,

Si non â” ajouter VAR=42 Ã  la fin de ton tableau.

ğŸ“š GÃ©rer unset
ğŸ“‹ Quand tu tapes :
bash
Copier
Modifier
unset VAR
Tu dois :

Supprimer l'entrÃ©e VAR=xxx de ton tableau envp,

DÃ©caler tous les Ã©lÃ©ments suivants,

Ajuster la taille de envp.

ğŸ“š Remplacer $VAR dans les commandes
ğŸ“‹ Quand tu tapes :
bash
Copier
Modifier
echo $HOME
Tu dois :

Chercher $HOME dans ton tableau envp,

Remplacer $HOME par sa valeur rÃ©elle (/home/tonuser).

ğŸ“‹ Mini mÃ©thode de substitution
c
Copier
Modifier
char *get_env_value(char *var, char **envp)
{
```c
 int i = 0;
 int len = strlen(var);

```
 while (envp[i])
 {
 if (!strncmp(envp[i], var, len) && envp[i][len] == '=')
```c
 return (envp[i] + len + 1);
 i++;
 }
 return (NULL);
}
(Ensuite tu replaces $VAR par sa valeur dans la commande.)

```
ğŸ“š Gestion spÃ©ciale de cas

Cas Que faire
$? Remplacer par le code retour de la derniÃ¨re commande
Variable inconnue ($XYZ) Remplacer par vide
Double dollar $$ Pas obligatoire dans ton mini-projet (sauf bonus)
ğŸ“‹ DÃ©tails critiques

PiÃ¨ge Solution
Modifier directement envp passÃ© Ã  main Toujours copier
Ne pas gÃ©rer le NULL final du tableau Toujours avoir envp[i] = NULL
LibÃ©rer l'ancien tableau lors d'un export/unset Refaire proprement
ğŸ¯ Mini plan d'action Partie 7
Copier envp dans ta propre structure,

GÃ©rer export et unset,

Substituer $VAR avant exÃ©cution,

Tester tout avec Valgrind âœ….

ğŸ“‹ TDD minimal Bloc 5 Partie 7 [ğŸŸ  AvancÃ©]

Test Attendu
export VAR=hello puis echo $VAR Affiche hello
unset VAR puis echo $VAR Affiche vide
env Affiche toutes les variables
RedÃ©finir une variable Remplace la bonne valeur
Valgrind 0 fuite mÃ©moire sur 10 000 variables

# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 8/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Maintenant que :

Ton shell sait exÃ©cuter, parser, rediriger, gÃ©rer l'environnement,

â” Il est temps de gÃ©rer proprement les signaux systÃ¨me :

CTRL+C pour interrompre proprement,

CTRL+D pour quitter proprement (EOF),

(Ã‰ventuellement plus tard: SIGQUIT, SIGTERM, etc.)

ğŸ“‹ Ce que tu dois faire dans cette Partie

Ã‰tape Objectif
1 Intercepter SIGINT (CTRL+C) pour ne pas quitter brutalement
2 GÃ©rer EOF (CTRL+D) proprement (afficher exit et fermer)
3 S'assurer que les signaux se comportent comme dans Bash
4 ProtÃ©ger les processus enfants des mauvais signaux
ğŸ“š Les signaux Ã  intercepter
ğŸ“¦ SIGINT (CTRL+C)
Quand l'utilisateur tape CTRL+C pendant que minishell attend une commande,
â” Ne pas quitter minishell.

Juste :

Afficher une nouvelle ligne propre,

RÃ©afficher le prompt (minishell$).

ğŸ“¦ EOF (CTRL+D)
Quand l'utilisateur tape CTRL+D (fin de fichier), â” minishell doit :

Quitter proprement,

Afficher exit avant de quitter.

ğŸ“š Fonctions utiles
ğŸ“‹ signal()
Te permet de capturer un signal et d'appeler une fonction personnalisÃ©e.

c
Copier
Modifier
```c
# include <signal.h>

```
void handler(int signum)
{
 if (signum == SIGINT)
 {
 write(1, "\nminishell$ ", 12);
 }
}

int main(void)
{
 signal(SIGINT, handler);
```c
 // ...
}
ğŸ“‹ readline() et signaux
Attention si tu utilises readline() :

```
readline intercepte automatiquement CTRL+C et CTRL+D !

Il te faudra appeler rl_replace_line("", 0) et rl_on_new_line() aprÃ¨s un signal pour Ãªtre propre.

ğŸ“‹ Exemple avec readline
c
Copier
Modifier
```c
# include <readline/readline.h>
# include <readline/history.h>

```
void handler(int signum)
{
 if (signum == SIGINT)
 {
 write(1, "\n", 1);
 rl_replace_line("", 0);
 rl_on_new_line();
 rl_redisplay();
 }
}

int main(void)
{
 signal(SIGINT, handler);
```c
 // minishell loop
}
ğŸ“‹ Comment dÃ©tecter CTRL+D ?
Quand tu utilises readline, tu peux savoir si l'utilisateur tape CTRL+D car :

```
c
Copier
Modifier
input = readline("minishell$ ");
if (!input) // si NULL
{
```c
 printf("exit\n");
 break; // quitter proprement
}
ğŸ“š Protection spÃ©ciale des enfants (bonus)
Pendant qu'un fils (fork) exÃ©cute une commande :

```
Tu peux choisir d'ignorer certains signaux temporairement,

Ou de leur laisser le comportement par dÃ©faut.

Exemple :

c
Copier
Modifier
signal(SIGINT, SIG_DFL); // Dans fils: comportement normal
ğŸ“‹ Points critiques Ã  bien respecter

PiÃ¨ge Solution
Quitter minishell sur un CTRL+C Jamais, juste afficher le prompt Ã  nouveau
Ne pas afficher exit sur CTRL+C Uniquement sur CTRL+D
Ignorer SIGQUIT (CTRL+\) si demandÃ© Possible en bonus
ğŸ¯ Mini plan d'action Partie 8
Capturer SIGINT (CTRL+C) et juste rÃ©afficher prompt,

DÃ©tecter CTRL+D (NULL sur readline) et quitter avec exit,

GÃ©rer signaux dans fils correctement (si bonus).

ğŸ“‹ TDD minimal Bloc 5 Partie 8 [ğŸŸ  AvancÃ©]

Test Attendu
CTRL+C pendant prompt Affiche une nouvelle ligne et re-prompt
CTRL+D pendant prompt Affiche exit et quitte
CTRL+C pendant exÃ©cution de sleep 5 Interrompt sleep mais minishell continue

# Bloc 5 â€” Minishell++ BoostÃ© â€” Partie 9/9 [ğŸŸ  AvancÃ©]
ğŸ“š Objectif immÃ©diat
Maintenant que :

Ton shell sait lire, parser, exÃ©cuter, gÃ©rer l'environnement, les pipes, les redirections et les signaux,

â” Il est temps de tout tester, nettoyer, et polir ton minishell pour en faire un projet solide et livrable !

ğŸ“‹ Ce que tu dois faire dans cette Phase Finale

Ã‰tape Objectif
1 Test intensif toutes fonctionnalitÃ©s
2 Nettoyer le code (pas d'interdits norme 42)
3 Faire un Makefile propre
4 Bonus possibles si tu veux aller encore plus loin
ğŸ“š Checklist ultra-complÃ¨te de tests ğŸ“‹
ğŸ“‹ FonctionnalitÃ©s obligatoires Ã  tester

Test RÃ©sultat attendu
ExÃ©cuter commande simple ls Fonctionne
ExÃ©cuter avec arguments ls -la Fonctionne
Commande inexistante Affiche erreur
Pipeline simple `ls wc -l`
Pipeline multiple `cat file grep hello
Redirection de sortie echo hello > file.txt Fonctionne
Redirection d'entrÃ©e cat < file.txt Fonctionne
Append echo world >> file.txt Fonctionne
Built-in cd changement de dossier Fonctionne
Built-in pwd retourne chemin correct Fonctionne
Built-in export, unset, env Fonctionnent
Substitution $VAR dans echo Fonctionne
CTRL+C dans prompt RÃ©affiche le prompt
CTRL+D dans prompt Quitte avec "exit"
ExÃ©cution massive (10000 commandes) Pas de fuite mÃ©moire (Valgrind âœ…)
ğŸ“‹ Nettoyage du code

RÃ¨gle Ã€ vÃ©rifier
Norme 42 respectÃ©e (fonctions courtes, pas de malloc sauvage, indentation) âœ…
Pas de warnings compilation (-Wall -Wextra -Werror) âœ…
LibÃ©ration de toute mÃ©moire avant exit âœ…
Makefile complet âœ…
Pas de fichiers .DS_Store, .vscode, etc. dans ton dÃ©pÃ´t âœ…
ğŸ“‹ Structure finale de ton projet Minishell++
plaintext
Copier
Modifier
minishell/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c
â”‚ â”œâ”€â”€ parser.c
â”‚ â”œâ”€â”€ executor.c
â”‚ â”œâ”€â”€ builtins/
â”‚ â”‚ â”œâ”€â”€ echo.c
â”‚ â”‚ â”œâ”€â”€ cd.c
â”‚ â”‚ â”œâ”€â”€ pwd.c
â”‚ â”‚ â”œâ”€â”€ export.c
â”‚ â”‚ â”œâ”€â”€ unset.c
â”‚ â”‚ â”œâ”€â”€ env.c
â”‚ â”‚ â”œâ”€â”€ exit.c
â”‚ â”œâ”€â”€ redirections.c
â”‚ â”œâ”€â”€ pipes.c
â”‚ â”œâ”€â”€ signals.c
â”‚ â”œâ”€â”€ env_utils.c
â”‚ â”œâ”€â”€ utils.c
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ minishell.h
â”œâ”€â”€ tests/
â”‚ â”œâ”€â”€ heavy_tests.sh
â”œâ”€â”€ Makefile
ğŸ“š Makefile final attendu

Target Action
all Compile minishell
clean Supprime les .o
fclean Supprime les .o et minishell
re clean + all
bonus (si tu as bonus, bonus compilation)
ğŸ¯ Mini plan d'action Partie 9
Passer tous les tests intensifs,

Nettoyer tout le code (norminette + valgrind clean),

Avoir un Makefile bÃ©ton,

(Optionnel) Ajouter bonus si envie !

ğŸ“š Bonus possibles â­

Bonus DÃ©tail
>> dans les pipes intermÃ©diaires Plus complexe mais faisable
Gestion Here-Doc (<<) Rediriger entrÃ©e avec input dynamique
Gestion avancÃ©e des signaux enfants Propagation fine des SIGINT/SIGQUIT
Support des variables d'environnement locales $?, etc.
Support du wildcard * (ls *.c) AvancÃ© mais faisable

# Bloc 6 â€” Malloc++ BoostÃ©
ğŸ“š Objectif gÃ©nÃ©ral
RecrÃ©er le fonctionnement de base de :

malloc() â” Allouer dynamiquement de la mÃ©moire,

free() â” LibÃ©rer proprement la mÃ©moire,

(Optionnel) realloc() â” Redimensionner une zone mÃ©moire.

â” Le tout sans utiliser malloc de la libc !

ğŸ“‹ Ce que tu vas construire concrÃ¨tement

Fonction Description
```c
void *malloc(size_t size); Allouer un bloc mÃ©moire de taille size
void free(void *ptr); LibÃ©rer un bloc mÃ©moire prÃ©cÃ©demment allouÃ©
(optionnel) void *realloc(void *ptr, size_t size); RÃ©allouer une mÃ©moire Ã  une autre taille
ğŸ“š Connaissances que tu vas renforcer ici

```
CompÃ©tence Importance
Gestion des pointeurs avancÃ©e âœ…
Gestion de la mÃ©moire systÃ¨me âœ…
ComprÃ©hension du heap (tas mÃ©moire) âœ…
Utilisation de brk() et sbrk() âœ…
Architecture de la mÃ©moire d'un programme âœ…
Organisation propre d'un mini-projet systÃ¨me âœ…
ğŸ“¦ Architecture mÃ©moire minimale que tu vas gÃ©rer
Chaque bloc allouÃ© doit contenir :

Un header (donnÃ©es internes, taille, libre ou pas),

La zone utilisateur (la vraie mÃ©moire allouÃ©e).

ğŸ“š Exemple d'un header minimal
c
Copier
Modifier
typedef struct s_block
{
```c
 size_t size;
 int free;
 struct s_block *next;
} t_block;
size: taille du bloc,

```
free: 0 ou 1 (occupÃ© ou libre),

next: pointeur vers le bloc suivant.

ğŸ“š Fonctionnement basique de ton malloc

Ã‰tape Action
1 Chercher un bloc libre assez grand dans ta liste
2 Si trouvÃ© â” rÃ©utiliser ce bloc
3 Si pas trouvÃ© â” demander plus de mÃ©moire au systÃ¨me avec sbrk()
4 Retourner un pointeur sur la zone utilisateur (aprÃ¨s le header)
ğŸ“‹ sbrk() rapide explication
sbrk(0) â” Retourne la fin actuelle du heap.

sbrk(size) â” Agrandit le heap de size octets.

Attention: pas autorisÃ© dans tous les systÃ¨mes modernes â” mais pour projet Ã©ducatif, parfait.

ğŸ“‹ Fonction signature de ton malloc++
c
Copier
Modifier
```c
void *malloc(size_t size);
Alloue dynamiquement size octets,

```
Retourne un pointeur utilisable par l'utilisateur.

ğŸ“š SchÃ©ma mÃ©moire aprÃ¨s quelques malloc
plaintext
Copier
Modifier
[block1_header][block1_data][block2_header][block2_data][block3_header][block3_data]...
Chaque block est liÃ© au suivant avec un pointeur next.

ğŸ“š Pourquoi ce projet est excellent ?

Raison Impact
Approfondir la gestion bas niveau âœ…
Savoir comment marche malloc/realloc/free vraiment âœ…
Comprendre fragmentation, compactage mÃ©moire âœ…
Apprendre organisation et rigueur âœ…
ğŸ“‹ DÃ©marrage rapide pour Bloc 6
Fichier principal malloc.c
Chercher un bloc libre,

Si non â” appeler sbrk pour agrandir le heap,

CrÃ©er un nouveau t_block,

Retourner l'adresse aprÃ¨s le header.

Fichier free.c
Marquer le bloc comme libre (block->free = 1),

(En bonus) Fusionner blocs libres voisins.

Fichier malloc.h
DÃ©finir :

c
Copier
Modifier
typedef struct s_block t_block;
```c
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);
ğŸ¯ Mini plan d'action Bloc 6
DÃ©finir la structure t_block,

```
Ã‰crire malloc() simple,

Ã‰crire free() simple,

GÃ©rer proprement la liste des blocs,

Option bonus: Ã©crire realloc().

ğŸ“‹ TDD minimal pour Malloc++

Test Attendu
malloc(10) Retourne un pointeur utilisable
malloc(0) Comportement dÃ©fini
malloc puis free Pas de fuite mÃ©moire
malloc(1000) puis free Pas d'erreur
Allocation massive Pas de crash

# Bloc 6 â€” Partie 1/?? â€” DÃ©finir les structures & la base du systÃ¨me
ğŸ“š Objectif immÃ©diat
Mettre en place :

âœ… La structure de donnÃ©es qui dÃ©crit chaque bloc de mÃ©moire,

âœ… Les fonctions de base (init, premier malloc),

âœ… Un pointeur global qui reprÃ©sente la tÃªte de ton heap simulÃ©.

ğŸ§± Structure de base: t_block
C'est la brique principale de tout ton systÃ¨me mÃ©moire.

c
Copier
Modifier
typedef struct s_block
{
```c
 size_t size; // Taille du bloc mÃ©moire utilisateur
 int free; // 1 si libre, 0 si utilisÃ©
 struct s_block *next; // Pointeur vers le bloc suivant
} t_block;
ğŸ¯ Ta "heap" personnalisÃ©e
Ton heap est simplement une liste chaÃ®nÃ©e de t_block.

```
Le premier Ã©lÃ©ment est un pointeur global :

c
Copier
Modifier
t_block *g_base = NULL;
ğŸ“ Fichiers Ã  crÃ©er maintenant

Fichier RÃ´le
malloc.c Contiendra ton malloc()
free.c Contiendra ton free()
malloc.h Toutes les structures + prototypes
(+ debug_utils.c si tu veux afficher les blocs) 
ğŸ“‹ Ã‰tapes dans malloc()
c
Copier
Modifier
void *malloc(size_t size)
{
 t_block *block;

 if (size <= 0)
```c
 return NULL;

```
 if (!g_base)
 {
```c
 // PremiÃ¨re allocation: crÃ©er le premier bloc avec sbrk
 block = sbrk(sizeof(t_block) + size);
 if (block == (void*) -1)
 return NULL;
 block->size = size;
 block->free = 0;
 block->next = NULL;
 g_base = block;
 return (void*)(block + 1);
 }

```
c
 // Ã€ complÃ©ter dans les parties suivantes: chercher bloc libre, etc.
}
ğŸ§ª Que fait (void*)(block + 1) ?
Ã‡a retourne: â” l'adresse juste aprÃ¨s ton t_block struct,
â” donc l'adresse utile pour l'utilisateur.

```
ğŸ“š SchÃ©ma mÃ©moire aprÃ¨s premier malloc(16)
plaintext
Copier
Modifier
[g_base] -> [BLOCK HEADER][USER DATA (16 bytes)]
ğŸ› ï¸ malloc.h (Ã  crÃ©er maintenant)
c
Copier
Modifier
# ifndef MALLOC_H
# define MALLOC_H

# include <unistd.h>
# include <stddef.h>

typedef struct s_block
{
```c
 size_t size;
 int free;
 struct s_block *next;
} t_block;

```
c
void *malloc(size_t size);
void free(void *ptr);

```
# endif
ğŸ“‹ Points importants Ã  retenir

Point DÃ©tail
Tu construis ton propre heap avec sbrk() (ne jamais utiliser le malloc standard)
t_block est toujours en mÃ©moire avant le pointeur que tu rends Ã  l'utilisateur TrÃ¨s utile pour free() plus tard
Tu commences avec une seule allocation Recherche de bloc libre viendra ensuite
ğŸ¯ Mini plan d'action Partie 1
DÃ©finir t_block dans malloc.h,

CrÃ©er malloc.c avec un premier malloc() fonctionnel,

Utiliser sbrk() pour allouer un seul bloc,

Retourner (block + 1) Ã  l'utilisateur,

PrÃ©parer g_base pour suivre la mÃ©moire.

ğŸ“‹ TDD minimal pour cette Ã©tape

Test Attendu
ptr = malloc(32); ptr != NULL
*ptr = 42; Pas de crash
malloc(0); Retourne NULL
Afficher (void*)ptr - sizeof(t_block) Doit pointer sur g_base

# Bloc 6 â€” Partie 2/?? â€” RÃ©utiliser les blocs libres
ğŸ“š Objectif de cette partie
Tu vas :

RÃ©utiliser un bloc mÃ©moire dÃ©jÃ  libÃ©rÃ© (Ã©viter sbrk trop souvent),

ImplÃ©menter une fonction find_free_block() dans ta liste chaÃ®nÃ©e,

Ne demander plus de mÃ©moire au systÃ¨me que quand c'est vraiment nÃ©cessaire.

ğŸ“‹ Ã‰tapes principales

Ã‰tape Action
1 Ajouter une fonction pour chercher un bloc libre assez grand
2 L'utiliser dans malloc()
3 Ajouter le bloc en fin de liste si rien n'est libre
4 Ne jamais oublier d'initialiser free = 0 en cas de rÃ©utilisation
ğŸ“ Fichier Ã  modifier: malloc.c
ğŸ§± Fonction Ã  ajouter: find_free_block()
c
Copier
Modifier
t_block *find_free_block(t_block **last, size_t size)
{
 t_block *current = g_base;

 while (current)
 {
 if (current->free && current->size >= size)
```c
 return current;
 *last = current;
 current = current->next;
 }
 return NULL;
}
ğŸ§  Comment elle fonctionne :
On parcourt la liste des blocs,

```
Si un bloc est free == 1 et que sa taille est suffisante â” on le prend,

Sinon, on garde le dernier bloc visitÃ© (dans *last) pour allouer un nouveau.

ğŸ” Mettre Ã  jour ta fonction malloc()
Voici une version amÃ©liorÃ©e :

c
Copier
Modifier
```c
void *malloc(size_t size)
{
 t_block *block;
 t_block *last;

 if (size <= 0)
```c
 return NULL;

```
 if (!g_base)
 {
 block = sbrk(sizeof(t_block) + size);
 if (block == (void*) -1)
```c
 return NULL;
 block->size = size;
 block->free = 0;
 block->next = NULL;
 g_base = block;
 }
 else
 {
 block = find_free_block(&last, size);
 if (block)
 block->free = 0;
 else
 {
 block = sbrk(sizeof(t_block) + size);
 if (block == (void*) -1)
 return NULL;
 block->size = size;
 block->free = 0;
 block->next = NULL;
 last->next = block;
 }
 }
 return (void*)(block + 1);
}
```
ğŸ’¡ RÃ©sumÃ© :
On rÃ©utilise si on peut,

```
Sinon, on agrandit le heap via sbrk.

ğŸ“š Bonus: Ã©tat mÃ©moire Ã  imprimer (optionnel debug)
Tu peux afficher :

c
Copier
Modifier
[Block 1] size=32 free=0 
[Block 2] size=128 free=1 
[Block 3] size=64 free=0 
â¡ï¸ pour t'assurer que tes blocs sont bien reliÃ©s et gÃ©rÃ©s.

ğŸ“‹ Cas Ã  tester maintenant

Code Comportement
p1 = malloc(64); free(p1); p2 = malloc(64); p2 = p1 (rÃ©utilisation âœ…)
p1 = malloc(64); p2 = malloc(32); free(p1); malloc(70); Ne rÃ©utilise pas p1 (pas assez grand)
ğŸ“š Tu viens d'implÃ©menter :

FonctionnalitÃ© BÃ©nÃ©fice
find_free_block() RÃ©duction des appels Ã  sbrk()
Recyclage mÃ©moire + Pro propre et + performant
Ajout dynamique de bloc Liste chaÃ®nÃ©e extensible Ã  l'infini

# Bloc 6 â€” Partie 3/?? â€” ImplÃ©menter free()
ğŸ“š Objectif immÃ©diat
Maintenant que tu peux :

Allouer des blocs avec malloc(),

RÃ©utiliser des blocs avec find_free_block(),

â” Tu vas maintenant permettre Ã  l'utilisateur de libÃ©rer un bloc avec free().

ğŸ“‹ Ã‰tapes Ã  suivre

Ã‰tape Action
1 RÃ©cupÃ©rer le t_block Ã  partir du void * fourni
2 Marquer le bloc comme free
3 Ne jamais oublier de vÃ©rifier que le pointeur est valide
4 (Option bonus plus tard) Fusionner les blocs adjacents libres
ğŸ“š Comment retrouver le bloc depuis ptr
Lorsque malloc() retourne :

c
Copier
Modifier
```c
return (void *)(block + 1);
Alors pour revenir en arriÃ¨re, on fait :

```
c
Copier
Modifier
t_block *block = (t_block *)ptr - 1;
Cela te donne directement accÃ¨s au header t_block du bloc correspondant.

ğŸ“‹ ImplÃ©mentation de free() simple
Dans free.c :

c
Copier
Modifier
```c
# include "malloc.h"

```
void free(void *ptr)
{
 t_block *block;

 if (!ptr)
```c
 return;

```
 block = (t_block *)ptr - 1;
 block->free = 1;
}
ğŸ§  Pourquoi cette implÃ©mentation fonctionne ?
On accÃ¨de au header grÃ¢ce au fait que malloc() renvoie (block + 1),

Le bloc est donc toujours juste avant le pointeur reÃ§u,

Marquer free = 1 suffit Ã  le rendre rÃ©utilisable par malloc() plus tard.

ğŸ“š Ã€ quoi faire attention

PiÃ¨ge Solution
ptr == NULL Ne rien faire
LibÃ©rer deux fois le mÃªme bloc Ã€ protÃ©ger en bonus
LibÃ©rer un pointeur invalide (pas d'un malloc Ã  toi) Bonus: vÃ©rifier si le bloc est dans la liste gÃ©rÃ©e
ğŸ§ª Cas Ã  tester

Code Ce qui doit se passer
p = malloc(64); free(p); block->free = 1
free(NULL); Ne plante pas
malloc(64); free(); malloc(64); RÃ©utilise le mÃªme bloc
ğŸ“‹ Debug utile
Tu peux Ã©crire une fonction (optionnelle) :

c
Copier
Modifier
void show_heap(void)
{
 t_block *current = g_base;
 while (current)
 {
```c
 printf("Block %p â€” size: %zu â€” free: %d\n", current, current->size, current->free);
 current = current->next;
 }
}
ğŸ“š Tu as maintenant :

```
FonctionnalitÃ© RÃ©sultat
Allocation avec malloc() âœ…
RÃ©utilisation avec find_free_block() âœ…
LibÃ©ration avec free() âœ…
Base solide pour ajouter fusion, realloc, debug avancÃ© ğŸ”œ

# Bloc 6 â€” Partie 4/?? â€” Fusionner les blocs libres adjacents
ğŸ“š Objectif immÃ©diat
Tu vas :

DÃ©tecter les blocs libres consÃ©cutifs dans ta liste,

Les fusionner en un seul grand bloc,

Ã‰viter ainsi la fragmentation, qui gaspille de la mÃ©moire inutilement.

â“ Pourquoi faire Ã§a ?
Imaginons :

scss
Copier
Modifier
[Bloc 1] (free, 64 bytes) [ğŸŸ¢ Facile]
[Bloc 2] (free, 128 bytes) [ğŸŸ¢ Facile]
[Bloc 3] (used) [ğŸŸ¡ IntermÃ©diaire]
Tu pourrais fusionner Bloc 1 + Bloc 2 en un seul  [ğŸŸ¢ Facile] [ğŸŸ¢ Facile]:

scss
Copier
Modifier
[Bloc fusionnÃ©] (free, 192 bytes)
Ce bloc fusionnÃ© pourra accueillir de plus grosses allocations.

ğŸ“‹ Ã‰tapes Ã  suivre

Ã‰tape Action
1 Parcourir toute la liste de blocs mÃ©moire
2 DÃ¨s que 2 blocs consÃ©cutifs sont libres â†’ fusionner
3 RÃ©pÃ©ter jusqu'Ã  ce qu'aucun bloc adjacent ne soit libre
ğŸ“¦ Fonction coalesce_free_blocks()
Ã€ appeler aprÃ¨s chaque free() :

c
Copier
Modifier
void coalesce_free_blocks(void)
{
 t_block *current = g_base;

 while (current && current->next)
 {
 if (current->free && current->next->free)
 {
 current->size += sizeof(t_block) + current->next->size;
 current->next = current->next->next;
 }
 else
 current = current->next;
 }
}
ğŸ“¦ Mise Ã  jour de free() :
c
Copier
Modifier
void free(void *ptr)
{
 t_block *block;

 if (!ptr)
```c
 return;

```
 block = (t_block *)ptr - 1;
 block->free = 1;
 coalesce_free_blocks();
}
ğŸ“š Illustration (avant/aprÃ¨s)
Avant :

css
Copier
Modifier
[g_base] â†’ [64 free] â†’ [128 free] â†’ [64 used]
AprÃ¨s :

css
Copier
Modifier
[g_base] â†’ [192 free] â†’ [64 used]
ğŸ“‹ Astuces pour Ã©viter les erreurs

Erreur courante Solution
Oublier de mettre Ã  jour next du bloc courant Toujours le rÃ©assigner aprÃ¨s fusion
Bloquer sur une boucle infinie N'avancer current que si tu ne fusionnes pas
Tenter de fusionner avec un NULL Toujours vÃ©rifier current && current->next
ğŸ¯ Mini plan d'action Partie 4
Ã‰crire coalesce_free_blocks(),

L'appeler Ã  chaque free(),

VÃ©rifier en debug visuel que ta heap se compacte,

Tester via allocations et libÃ©rations multiples.

ğŸ§ª Tests recommandÃ©s

Code Attendu
malloc A + B + C, puis free A et B A et B fusionnÃ©s
malloc A + B, free A, malloc C Si C < A, C rÃ©utilise A
malloc + free + free + malloc Aucune fuite mÃ©moire, blocs rÃ©utilisÃ©s
âœ… Tu viens d'ajouter Ã  ton malloc :

FonctionnalitÃ© BÃ©nÃ©fice
Fusion blocs libres RÃ©duction fragmentation
Coalescence automatique Pas besoin de forcer
Heap plus intelligent GÃ¨re mieux les gros mallocs

# Bloc 6 â€” Partie 5 â€” ImplÃ©menter realloc()
ğŸ“š Objectif immÃ©diat
Tu vas permettre Ã  l'utilisateur de :

ğŸ” Modifier la taille d'un bloc mÃ©moire dÃ©jÃ  allouÃ©,
sans perdre son contenu (dans la limite de la nouvelle taille bien sÃ»r).

ğŸ“‹ Signature Ã  respecter
c
Copier
Modifier
```c
void *realloc(void *ptr, size_t size);
ğŸ§  Que fait realloc() exactement ?

```
Situation Comportement
ptr == NULL MÃªme chose que malloc(size)
size == 0 et ptr != NULL MÃªme chose que free(ptr)
Sinon Essaie de garder les donnÃ©es, mais change la taille
ğŸ“¦ Ã‰tapes classiques d'un realloc
Si ptr == NULL â” malloc(size)

Si size == 0 â” free(ptr) puis NULL

Sinon :

Cherche le bloc d'origine (ptr - 1)

Si size <= block->size â†’ rien Ã  faire, retourne le mÃªme ptr

Sinon :

Alloue un nouveau bloc avec malloc(size)

Copie les donnÃ©es (via memcpy)

LibÃ¨re l'ancien

Retourne le nouveau

ğŸ“‹ ImplÃ©mentation complÃ¨te de realloc
c
Copier
Modifier
```c
# include "malloc.h"
# include <string.h>

```
void *realloc(void *ptr, size_t size)
{
 t_block *block;
```c
 void *new_ptr;

```
 if (!ptr)
```c
 return malloc(size);

```
 if (size == 0)
 {
 free(ptr);
```c
 return NULL;
 }

```
 block = (t_block *)ptr - 1;

 if (block->size >= size)
```c
 return ptr;

```
 new_ptr = malloc(size);
 if (!new_ptr)
```c
 return NULL;

```
 memcpy(new_ptr, ptr, block->size);
 free(ptr);
```c
 return new_ptr;
}
ğŸ“‹ Explication ligne par ligne

```
Bloc But
if (!ptr) Si realloc s'utilise comme un malloc
if (size == 0) Si realloc s'utilise comme un free
if (block->size >= size) Si la place est suffisante, ne rien faire
memcpy(new_ptr, ptr, block->size) Recopie les donnÃ©es
free(ptr) LibÃ¨re l'ancien bloc aprÃ¨s copie
ğŸ“š Avantages de realloc() bien fait

Point Pourquoi c'est utile
Ã‰vite de recopier inutilement si le bloc est assez grand âœ… performant
Garde les donnÃ©es intactes âœ… sÃ©curitÃ©
Permet Ã  un programme d'ajuster dynamiquement sa mÃ©moire âœ… souplesse
ğŸ¯ Mini plan d'action Partie 5
Ajouter realloc() dans malloc.h,

ImplÃ©menter les 3 cas (NULL, 0, agrandissement),

Utiliser memcpy() pour la recopie,

Tester sur des tableaux, strings, buffers, etc.

ğŸ“‹ TDD minimal Bloc 6 Partie 5

Code Ce qui doit se passer
realloc(NULL, 42) Agit comme malloc(42)
realloc(ptr, 0) Agit comme free(ptr)
realloc(ptr, old_size) Retourne mÃªme bloc
realloc(ptr, bigger_size) Copie, libÃ¨re, retourne nouveau

# Bloc 6 â€” Partie 6/6 â€” Tests, Debug, Valgrind, Makefile, Finalisation
ğŸ“š Objectif immÃ©diat
Tu vas :

ğŸ§ª Tester toutes tes fonctions avec des cas rÃ©els et critiques,

ğŸ” Ajouter des outils de debug,

ğŸ§¼ Valider l'absence de fuites mÃ©moire avec Valgrind,

ğŸ§° Rendre un projet propre, lisible, et maintenable.

âœ… Ã€ ce stade, tu as :

Fonction Fait
malloc(size_t size) âœ…
free(void *ptr) âœ…
realloc(void *ptr, size_t size) âœ…
Fusion de blocs (coalesce) âœ…
RÃ©utilisation mÃ©moire âœ…
Liste chaÃ®nÃ©e interne âœ…
Allocation avec sbrk() uniquement âœ…
ğŸ§ª Fichier de test minimal (test_malloc.c)
c
Copier
Modifier
```c
# include <stdio.h>
# include <string.h>
# include "malloc.h"

```
int main(void)
{
```c
 char *a = malloc(32);
 strcpy(a, "hello malloc!");
 printf("a = %s\n", a);

```
c
 char *b = malloc(16);
 char *c = malloc(64);
 free(b);

```
c
 char *d = malloc(16); // Devrait rÃ©utiliser l'ancien b
 char *e = realloc(a, 64);
 printf("e = %s\n", e);

```
 free(c);
 free(d);
 free(e);

```c
 return 0;
}
ğŸ“‹ Test Ã  lancer avec Valgrind
bash
Copier
Modifier
valgrind --leak-check=full ./test_malloc
Attendu :

```
0 memory leak

0 error

Heap usage correct

ğŸ§° Outil bonus: afficher la mÃ©moire
Dans debug_utils.c :

c
Copier
Modifier
void show_heap(void)
{
 t_block *current = g_base;
 while (current)
 {
 printf("Block at %p | size: %zu | free: %d | next: %p\n",
```c
 (void *)current, current->size, current->free, (void *)current->next);
 current = current->next;
 }
}
Tu peux l'appeler entre deux tests pour visualiser tes blocs mÃ©moire.

```
ğŸ“¦ Makefile minimal pour ton malloc++
makefile
Copier
Modifier
NAME = test_malloc

SRCS = malloc.c free.c realloc.c debug_utils.c test_malloc.c
OBJS = $(SRCS:.c=.o)
CC = gcc
CFLAGS = -Wall -Wextra -Werror

all: $(NAME)

$(NAME): $(OBJS)
 $(CC) $(CFLAGS) -o $@ $^

clean:
 rm -f $(OBJS)

fclean: clean
 rm -f $(NAME)

re: fclean all
ğŸ“‹ Structure finale recommandÃ©e
plaintext
Copier
Modifier
malloc++/
â”œâ”€â”€ malloc.h
â”œâ”€â”€ malloc.c
â”œâ”€â”€ free.c
â”œâ”€â”€ realloc.c
â”œâ”€â”€ debug_utils.c
â”œâ”€â”€ test_malloc.c
â”œâ”€â”€ Makefile
ğŸ“š Pour aller plus loin (Bonus/Futur)

Option Description
Fusion automatique au malloc aussi Optimise encore +
Aligner les blocs (alignement mÃ©moire) Architecture pro
Support multi-thread Gestion par mutex (avancÃ©)
Ajout d'un garbage collector personnalisÃ© Projet perso futur
âœ… Tu viens de terminer ton propre gestionnaire mÃ©moire complet en C.

Module Statut
Allocation dynamique (malloc) âœ…
LibÃ©ration (free) âœ…
RÃ©allocation (realloc) âœ…
Coalescence mÃ©moire âœ…
Affichage & debug âœ…
Makefile & test âœ…




ğŸ§© Module 2 â€” memory/allocators/ â€” Gestion mÃ©moire avancÃ©e
ğŸ“¦ Module memory/allocators/ â€” Mini-Allocateur & Debug mÃ©moire [ğŸ’¡ Niveau AvancÃ©]
ğŸ¯ Objectif pÃ©dagogique
La mÃ©moire est le cÅ“ur de tout programme en C. Ce module va t'apprendre Ã  :

DÃ©bugger des fuites mÃ©moire sans outils externes (sans Valgrind)

Ã‰crire un mini-allocateur personnalisÃ© (niveau expert)

GÃ©rer toi-mÃªme le heap, les blocs libres, et lâ€™alignement mÃ©moire

Approcher la gestion de la mÃ©moire comme dans les systÃ¨mes dâ€™exploitation

ğŸ“š Concepts abordÃ©s
âœ… 1. DÃ©tection manuelle de fuites mÃ©moire
Allouer â†’ libÃ©rer â†’ vÃ©rifier

SystÃ¨me de log dâ€™allocations

Utilisation de atexit() pour dÃ©tecter les oublis

c
Copier
Modifier
// memory_log.c
#include <stdlib.h>
#include <stdio.h>

static int allocs = 0;

void *xmalloc(size_t size) {
    allocs++;
    return malloc(size);
}

void xfree(void *ptr) {
    allocs--;
    free(ptr);
}

void check_memory(void) {
    if (allocs != 0)
        printf("âš ï¸ %d allocations non libÃ©rÃ©es !\n", allocs);
    else
        printf("âœ… Aucune fuite mÃ©moire dÃ©tectÃ©e.\n");
}

__attribute__((constructor)) void init(void) { atexit(check_memory); }
âœ… 2. Mini-allocateur : simulation dâ€™un malloc()
Zone mÃ©moire statique

Gestion de blocs libres

ImplÃ©mentation de malloc(), free(), realloc() simplifiÃ©s

c
Copier
Modifier
#define POOL_SIZE 4096
static char pool[POOL_SIZE];
static int used = 0;

void *simple_malloc(size_t size) {
    if (used + size > POOL_SIZE)
        return NULL;
    void *ptr = &pool[used];
    used += size;
    return ptr;
}
âœ… 3. Alignement mÃ©moire et "placement memory"
Simulation de placement new (style C++)

Alignement sur 8 ou 16 octets

uintptr_t pour manipulation bas niveau

c
Copier
Modifier
#include <stdint.h>

uintptr_t align(uintptr_t ptr, size_t align) {
    return (ptr + align - 1) & ~(align - 1);
}
ğŸ§ª Exercices
ğŸ“‚ memory/allocators/ex00 â€” DÃ©tecteur de fuites
Objectif : dÃ©tecter et afficher le nombre dâ€™allocations non libÃ©rÃ©es.

ğŸ§ª Tester avec :

c
Copier
Modifier
void *a = xmalloc(42);
void *b = xmalloc(10);
xfree(a);
// b oubliÃ© â†’ une fuite dÃ©tectÃ©e Ã  la sortie
ğŸ“‚ memory/allocators/ex01 â€” Simuler malloc statique
Objectif : crÃ©er une fonction simple_malloc() dans une zone statique de 4096 octets.

ğŸ§  Bonus : afficher le pourcentage utilisÃ© de la mÃ©moire.

ğŸ“‚ memory/allocators/ex02 â€” Fusion de blocs libres
ğŸ§  Objectif : rÃ©utiliser les blocs libÃ©rÃ©s dans une zone simulÃ©e. CrÃ©er des metadata en tÃªte de chaque bloc.

Structure de base :

c
Copier
Modifier
typedef struct s_block {
    size_t size;
    int    free;
    struct s_block *next;
} t_block;
ğŸ› ï¸ Extensions possibles (pour plus tard)
ImplÃ©menter un allocateur buddy system

CrÃ©er un calloc() custom

Utiliser sbrk() pour allouer dynamiquement (Unix-only, niveau OS)



ğŸ§© Module 4 â€” signals/ â€” Signaux Unix, interruptions et gestion fine des processus [ğŸš¨ Niveau AvancÃ©]
ğŸ“¦ Module signals/ â€” MaÃ®triser les signaux en C (UNIX) [ğŸš¨ AvancÃ©]
ğŸ¯ Objectif pÃ©dagogique
Ce module va tâ€™enseigner les bases vitales de la communication entre processus via les signaux, qui sont des interruptions logicielles :

Intercepter un CTRL+C (SIGINT)

GÃ©rer les signaux personnalisÃ©s avec sigaction

Programmer des alarmes avec alarm()

Utiliser kill() pour envoyer un signal Ã  un autre processus

EmpÃªcher les crashs par SIGSEGV, SIGFPE, etc.

ğŸ“š Concepts abordÃ©s
âœ… 1. signal() â€” Interception de signaux simples
c
Copier
Modifier
#include <signal.h>
#include <stdio.h>

void handler(int sig) {
    printf("Signal reÃ§u : %d\n", sig);
}

int main() {
    signal(SIGINT, handler); // CTRL+C
    while (1); // Boucle infinie
}
âš ï¸ signal() est obsolÃ¨te pour les projets sÃ©rieux. PrÃ©fÃ¨re sigaction().

âœ… 2. sigaction() â€” MÃ©thode moderne et fiable
c
Copier
Modifier
#include <signal.h>

struct sigaction sa;
sa.sa_handler = handler;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;

sigaction(SIGTERM, &sa, NULL);
Avantages :

Plus de contrÃ´le

CompatibilitÃ© POSIX

Masquage temporaire de signaux concurrents

âœ… 3. alarm() et SIGALRM
c
Copier
Modifier
#include <unistd.h>

alarm(5); // DÃ©clenche SIGALRM aprÃ¨s 5 secondes
â†’ Pratique pour crÃ©er des timeouts.

âœ… 4. kill() â€” Envoi de signaux
c
Copier
Modifier
kill(pid, SIGUSR1);
â†’ Permet de dialoguer entre processus, ou de stopper un service.

âœ… 5. Signaux systÃ¨me courants
Signal  Description
SIGINT  Interruption (Ctrl+C)
SIGTERM Demande d'arrÃªt propre
SIGKILL ArrÃªt brutal (non capturable)
SIGSEGV Segmentation fault
SIGALRM Minuterie / alarm()
SIGCHLD Enfant terminÃ© (wait)
SIGUSR1/2 Signaux utilisateur

ğŸ§ª Exercices
ğŸ“‚ signals/ex00 â€” Attraper SIGINT avec signal()
CrÃ©e une boucle infinie interrompue par Ctrl+C. Lors du signal, afficher Interruption reÃ§ue !.

ğŸ“‚ signals/ex01 â€” sigaction() propre
Utilise sigaction() pour intercepter SIGTERM, afficher un message, et quitter avec exit(0).

ğŸ“‚ signals/ex02 â€” Timeout avec alarm()
CrÃ©er une commande qui se termine automatiquement aprÃ¨s 3 secondes si rien ne se passe.
ğŸ’¡ Bonus : pause() pour attendre un signal.

ğŸ“‚ signals/ex03 â€” Envoi de signaux entre processus
CrÃ©er deux programmes :

receiver.c qui affiche un message sur SIGUSR1

sender.c qui envoie ce signal Ã  receiver via kill(pid, SIGUSR1)

ğŸ› ï¸ Bonus technique
sigprocmask() : bloquer certains signaux

sigpending(), sigismember() : gÃ©rer file dâ€™attente

RÃ©agir Ã  SIGSEGV pour afficher une stack avant crash


ğŸ§© Module 5 â€” file_syscalls/ â€” Appels systÃ¨me liÃ©s aux fichiers [ğŸ—ƒï¸ Niveau Moyen Ã  AvancÃ©]
ğŸ“¦ Module file_syscalls/ â€” Manipulation directe des fichiers via les appels systÃ¨me [ğŸ—ƒï¸ Moyen Ã  AvancÃ©]
ğŸ¯ Objectif pÃ©dagogique
Ce module te permet de comprendre et manipuler les fichiers Ã  bas niveau comme le fait un OS ou un shell, sans passer par fopen ou la libc standard. Tu vas apprendre Ã  :

Lire et Ã©crire un fichier avec read() / write()

Ouvrir et fermer manuellement un fichier (open, close)

Repositionner le curseur avec lseek()

Analyser les mÃ©tadonnÃ©es avec stat(), fstat()

Modifier les permissions avec chmod(), umask()

ğŸ“š Concepts abordÃ©s
âœ… 1. open() et O_RDONLY / O_WRONLY / O_CREAT
c
Copier
Modifier
#include <fcntl.h>

int fd = open("data.txt", O_WRONLY | O_CREAT, 0644);
â†’ Retourne un descripteur de fichier, Ã  manipuler comme un int.

âœ… 2. read() et write()
c
Copier
Modifier
#include <unistd.h>

char buffer[128];
int r = read(fd, buffer, 128);
int w = write(fd, "Hello", 5);
âš ï¸ Bien vÃ©rifier le retour pour EOF ou erreur (-1).

âœ… 3. close()
c
Copier
Modifier
close(fd);
â†’ Toujours fermer les fichiers pour Ã©viter les fuites.

âœ… 4. lseek() â€” Repositionner le curseur
c
Copier
Modifier
off_t pos = lseek(fd, 0, SEEK_END); // Aller Ã  la fin
â†’ Sert Ã  obtenir la taille du fichier, ou lire en arriÃ¨re.

âœ… 5. stat() et struct stat
c
Copier
Modifier
#include <sys/stat.h>

struct stat st;
stat("fichier.txt", &st);

printf("Taille : %ld octets\n", st.st_size);
printf("Type   : %d\n", st.st_mode & S_IFMT);
â†’ Obtenir toutes les infos systÃ¨me sur un fichier : taille, permissions, typeâ€¦

âœ… 6. chmod() et umask()
c
Copier
Modifier
chmod("file.txt", 0640);   // Modifie les droits
mode_t old = umask(0022);  // DÃ©finit le masque de crÃ©ation
â†’ Permet de gÃ©rer les droits dâ€™accÃ¨s UNIX (lecture, Ã©criture, exÃ©cution)

ğŸ§ª Exercices
ğŸ“‚ file_syscalls/ex00 â€” Ã‰crire dans un fichier
CrÃ©er un programme qui ouvre un fichier log.txt (ou le crÃ©e), y Ã©crit "Hello World\n", puis le referme.

ğŸ“‚ file_syscalls/ex01 â€” Lire un fichier caractÃ¨re par caractÃ¨re
Lire un fichier texte et afficher chaque caractÃ¨re en hexadÃ©cimal (utile pour fichiers binaires).

ğŸ“‚ file_syscalls/ex02 â€” Lire un fichier depuis la fin
Utiliser lseek() pour lire un fichier Ã  lâ€™envers (afficher le dernier octet, puis lâ€™avant-dernier, etc.).

ğŸ“‚ file_syscalls/ex03 â€” stat() complet
Afficher :

la taille du fichier

le type (fichier, dossier, lien)

les permissions (S_IRUSR, S_IWUSR, etc.)

la date de derniÃ¨re modification

ğŸ“‚ file_syscalls/ex04 â€” CrÃ©er un fichier avec permissions personnalisÃ©es
CrÃ©er un fichier en lecture/Ã©criture uniquement pour lâ€™utilisateur, puis changer ses permissions avec chmod().

ğŸ› ï¸ Bonus avancÃ©
Lire un fichier binaire et lâ€™afficher octet par octet

CrÃ©er un clone simplifiÃ© de la commande ls -l

Lire depuis /dev/random ou /proc/ (systÃ¨mes Linux only)




ğŸ§© Module 10 â€” types/ â€” Types personnalisÃ©s, unions, Ã©numÃ©rations, champs de bits [ğŸ§¬ Niveau Moyen Ã  AvancÃ©]
ğŸ“¦ Module types/ â€” Renforcer sa maÃ®trise des types C avancÃ©s [ğŸ§¬ Structuration & ContrÃ´le Fin]
ğŸ¯ Objectif pÃ©dagogique
Ce module est dÃ©diÃ© Ã  lâ€™expressivitÃ© du langage C via les types. Il tâ€™enseigne Ã  :

DÃ©finir des types personnalisÃ©s (typedef)

Utiliser les Ã©numÃ©rations (enum) pour des Ã©tats clairs

GÃ©rer des donnÃ©es variables avec les unions

Utiliser des bitfields pour encoder efficacement des flags

Comprendre les modificateurs const, volatile, restrict et leur impact

ğŸ“š Concepts abordÃ©s
âœ… 1. typedef : donner un nom Ã  un type
c
Copier
Modifier
typedef struct s_point {
    int x, y;
} t_point;
â†’ Rend le code plus lisible et modulaire.

âœ… 2. enum : listes de constantes
c
Copier
Modifier
typedef enum {
    STATE_IDLE,
    STATE_RUNNING,
    STATE_PAUSED
} t_state;
â†’ Remplace les #define par des valeurs symboliques liÃ©es Ã  un type.

âœ… 3. union : mÃ©moire partagÃ©e entre champs
c
Copier
Modifier
union u_data {
    int i;
    float f;
    char *str;
};
â†’ Tous les membres partagent la mÃªme zone mÃ©moire â†’ utile pour des donnÃ©es variables.

âœ… 4. Bitfields : Ã©conomie de mÃ©moire
c
Copier
Modifier
struct s_flags {
    unsigned int a : 1;
    unsigned int b : 1;
    unsigned int reserved : 6;
};
â†’ Permet de stocker plusieurs boolÃ©ens ou indicateurs dans un seul octet.

âœ… 5. const, volatile, restrict
const : interdit la modification

volatile : indique que la valeur peut changer sans que le code le voie (ex : registre matÃ©riel)

restrict : optimisation â†’ pointeur ne chevauche pas dâ€™autres (optimisations compilateur)

ğŸ§ª Exercices
ğŸ“‚ types/ex00 â€” CrÃ©er une structure point avec typedef
CrÃ©er un point 2D et une fonction affiche_point(t_point p).

ğŸ“‚ types/ex01 â€” EnumÃ©ration pour un Ã©tat de machine
CrÃ©er une fonction print_state(t_state) qui affiche "IDLE", "RUNNING" ou "PAUSED" selon la valeur.

ğŸ“‚ types/ex02 â€” Union gÃ©nÃ©rique
CrÃ©er une union u_token avec un int, un float, et un char*.
Ã‰crire une fonction affiche_token(union u_token, char type).

ğŸ“‚ types/ex03 â€” Bitfields pour flags
DÃ©finir une structure t_flags avec des champs binaires.
CrÃ©er une fonction print_flags() pour afficher leur Ã©tat binaire.

ğŸ“‚ types/ex04 â€” Utilisation de volatile
CrÃ©er une variable volatile int sensor_data; et une boucle qui la lit (simulation dâ€™un registre externe).

ğŸ› ï¸ Bonus
Simuler une machine dâ€™Ã©tat avec enum + switch

ImplÃ©menter un parser avec union pour stocker diffÃ©rents types

RÃ©aliser un mini flag register (inspiration CPU)






ğŸ§© Module 9 â€” memory/allocators/ â€” CrÃ©er son propre systÃ¨me de gestion mÃ©moire [ğŸ“¦ Niveau Expert]
ğŸ“¦ Module memory/allocators/ â€” ImplÃ©mentation dâ€™allocateurs mÃ©moire personnalisÃ©s en C [ğŸ“¦ Expert]
ğŸ¯ Objectif pÃ©dagogique
Ce module va bien au-delÃ  de lâ€™utilisation de malloc/free. Il te plonge dans lâ€™implÃ©mentation de ton propre systÃ¨me de gestion mÃ©moire, comme le ferait un OS ou un runtime C. Tu vas :

Comprendre comment fonctionne rÃ©ellement malloc

ImplÃ©menter un allocateur simple, puis plus avancÃ©

GÃ©rer la fragmentation, les zones libres, les alignements

Approcher des concepts comme les arenas, pools, buddy systems

Ã‰tudier la gestion du heap via sbrk, brk ou mmap

ğŸ“š Concepts abordÃ©s
âœ… 1. sbrk() et gestion manuelle du heap
c
Copier
Modifier
void *heap = sbrk(0); // Pointeur actuel
sbrk(4096);           // RÃ©server 4 Ko
â†’ Câ€™est la base de malloc.

âœ… 2. Structure de bloc mÃ©moire
c
Copier
Modifier
typedef struct block {
    size_t size;
    int is_free;
    struct block *next;
} block_t;
â†’ Permet de chaÃ®ner les blocs, et gÃ©rer les fragments.

âœ… 3. Allocation / LibÃ©ration
ImplÃ©mentation dâ€™un my_malloc() et my_free() :

Trouver un bloc libre de taille suffisante

Sinon, Ã©tendre le heap avec sbrk

Marquer un bloc comme occupÃ© ou libre

âœ… 4. Alignement mÃ©moire
c
Copier
Modifier
#define ALIGN4(x) (((((x)-1)>>2)<<2)+4)
â†’ Garantit que chaque bloc commence Ã  une adresse multiple de 4/8 octets.

âœ… 5. Fragmentation & fusion
AprÃ¨s libÃ©ration dâ€™un bloc : fusionner avec les blocs libres adjacents pour Ã©viter la fragmentation excessive.

âœ… 6. Techniques avancÃ©es
Buddy allocator : blocs divisibles par 2

Arena allocator : bloc prÃ©-rÃ©servÃ©, Ã  usage temporaire

Slab allocator : pour objets de taille fixe

Utilisation de mmap() au lieu de sbrk() (meilleure isolation)

ğŸ§ª Exercices
ğŸ“‚ memory/allocators/ex00 â€” ImplÃ©menter my_malloc
CrÃ©er un systÃ¨me minimal dâ€™allocation : structure + my_malloc() qui rÃ©serve via sbrk().

ğŸ“‚ memory/allocators/ex01 â€” ImplÃ©menter my_free
Marquer les blocs comme disponibles, sans fusions.

ğŸ“‚ memory/allocators/ex02 â€” Fusion et rÃ©utilisation de blocs
AmÃ©liorer my_free() pour permettre la fusion des blocs libres contigus.

ğŸ“‚ memory/allocators/ex03 â€” Aligner les blocs (padding)
Forcer les blocs Ã  Ãªtre alignÃ©s (ex: sur 8 octets). VÃ©rifier avec uintptr_t % 8.

ğŸ“‚ memory/allocators/ex04 â€” Afficher lâ€™Ã©tat du heap
CrÃ©er une fonction debug_heap() qui imprime :

Adresse de chaque bloc

Taille

Libre ou occupÃ©

ğŸ› ï¸ Bonus avancÃ©
ImplÃ©menter une version thread-safe (pthread_mutex)

GÃ©rer plusieurs pools (ex : petites tailles, moyennes, grandes)

CrÃ©er un benchmark contre malloc




ğŸ§© Module 6 â€” threads/ â€” Programmation concurrente en C (pthreads) [ğŸ§µ Niveau AvancÃ©]
ğŸ“¦ Module threads/ â€” Threads POSIX, mutex, synchronisation et conditions de course [ğŸ§µ AvancÃ©]
ğŸ¯ Objectif pÃ©dagogique
Ce module aborde la concurrence en C, câ€™est-Ã -dire lâ€™exÃ©cution simultanÃ©e de plusieurs tÃ¢ches. Tu vas apprendre Ã  :

CrÃ©er et gÃ©rer des threads avec pthread_create

Synchroniser des accÃ¨s mÃ©moire avec des mutex

DÃ©tecter et Ã©viter les conditions de course

Utiliser les sÃ©maphores pour gÃ©rer lâ€™accÃ¨s Ã  des ressources critiques

ğŸ“š Concepts abordÃ©s
âœ… 1. CrÃ©ation dâ€™un thread : pthread_create()
c
Copier
Modifier
#include <pthread.h>

void *task(void *arg) {
    printf("Thread lancÃ©\n");
    return NULL;
}

int main() {
    pthread_t t;
    pthread_create(&t, NULL, task, NULL);
    pthread_join(t, NULL);
}
â†’ Chaque thread exÃ©cute une fonction.

âœ… 2. Attente de fin de thread : pthread_join()
Assure que le thread sâ€™est bien terminÃ© avant de continuer.

âœ… 3. Mutex (pthread_mutex_t)
UtilisÃ©s pour Ã©viter que plusieurs threads accÃ¨dent Ã  une donnÃ©e partagÃ©e en mÃªme temps.

c
Copier
Modifier
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&lock);
// section critique
pthread_mutex_unlock(&lock);
âœ… 4. Conditions de course
Exemple :

c
Copier
Modifier
// Deux threads incrÃ©mentent la mÃªme variable
compteur++;
â†’ Peut produire des rÃ©sultats erronÃ©s si non synchronisÃ©.

âœ… 5. SÃ©maphores (POSIX)
c
Copier
Modifier
#include <semaphore.h>

sem_t sem;
sem_init(&sem, 0, 1);

sem_wait(&sem);
// section critique
sem_post(&sem);
â†’ Alternative aux mutex, permet un compteur de ressources.

ğŸ§ª Exercices
ğŸ“‚ threads/ex00 â€” CrÃ©er un thread
CrÃ©er un programme qui lance un thread qui affiche "Je suis un thread".

ğŸ“‚ threads/ex01 â€” Plusieurs threads simples
CrÃ©er 5 threads qui affichent leur numÃ©ro respectif.

ğŸ“‚ threads/ex02 â€” ProblÃ¨me de synchronisation
CrÃ©er deux threads qui incrÃ©mentent une variable int x = 0; 10000 fois chacun.
Sans mutex â†’ observer les valeurs erronÃ©es.
Avec mutex â†’ corriger.

ğŸ“‚ threads/ex03 â€” Utilisation dâ€™un mutex
CrÃ©er un thread_safe_log() qui Ã©crit dans un fichier log.txt sans collision entre threads.

ğŸ“‚ threads/ex04 â€” SÃ©maphore comme file dâ€™attente
CrÃ©er 3 threads producteurs qui Ã©crivent dans un tampon partagÃ© (tableau fixe)
et 1 thread consommateur qui lit les donnÃ©es.

ğŸ› ï¸ Bonus possible
CrÃ©er un mini-threadpool

ImplÃ©menter un sleep_sort (threads + sleep)

Observer la saturation de CPU avec htop







# Bloc 7 â€” Serveur RÃ©seau TCP BoostÃ© â€” Partie 0/?? (Introduction)
ğŸ“š Objectif global
CrÃ©er en C un serveur rÃ©seau TCP capable de :

Accepter plusieurs clients simultanÃ©s,

GÃ©rer des commandes simples envoyÃ©es par les clients,

RÃ©pondre correctement et de faÃ§on asynchrone Ã  chaque client,

Le tout sans bloquer les autres clients.

ğŸ”Œ Tu vas apprendre Ã  utiliser :

Ã‰lÃ©ment systÃ¨me UtilitÃ©
socket() CrÃ©er une interface rÃ©seau
bind() Attacher une IP/port
listen() Mettre le socket en attente de connexions
accept() Accepter une connexion client
read() / recv() Lire les messages entrants
write() / send() Envoyer des rÃ©ponses
select() GÃ©rer plusieurs clients en parallÃ¨le
(bonus) poll() / epoll() Performances ++
ğŸ” Fonctionnement minimal du serveur
plaintext
Copier
Modifier
[client1] â†’ â†˜
[client2] â†’ [socket serveur] â†’ GÃ¨re les requÃªtes clients
[client3] â†’ â†—
Chaque client se connecte et peut :

Envoyer une commande (PING, ECHO, etc.),

Recevoir une rÃ©ponse adaptÃ©e.

ğŸ¯ Les fonctionnalitÃ©s du projet

Ã‰tape FonctionnalitÃ©
Partie 1 CrÃ©er un serveur TCP simple (1 client Ã  la fois)
Partie 2 GÃ©rer plusieurs clients via select()
Partie 3 ImplÃ©menter des commandes textuelles (protocole mini)
Partie 4 Structurer et stabiliser le code
Partie 5 Ajouter un client C pour tester proprement
Partie 6 Bonus: mode broadcast / chat multiclient
Partie 7 Bonus: gestion de fichiers ou mini-API (FTP style)
ğŸ“¦ Format des messages clients (exemples)
plaintext
Copier
Modifier
> PING
< PONG

> ECHO Salut
< Salut

> TIME
< [serveur rÃ©pond avec l'heure]
ğŸ“š Structure de fichiers recommandÃ©e
plaintext
Copier
Modifier
tcp_server/
â”œâ”€â”€ main.c
â”œâ”€â”€ server.c
â”œâ”€â”€ server.h
â”œâ”€â”€ client_handler.c
â”œâ”€â”€ protocol.c
â”œâ”€â”€ utils.c
â”œâ”€â”€ Makefile
ğŸ“‹ TDD gÃ©nÃ©ral du projet

Ã‰tape Test
Lancement du serveur Port ouvert et Ã©coute
Connexion d'un client via telnet ou netcat AcceptÃ©e
Plusieurs clients en parallÃ¨le GÃ©rÃ©s sans bloquer
Envoi de message Serveur rÃ©pond
Commande inconnue Erreur propre
Fermeture client LibÃ©ration socket propre

# Bloc 7 â€” Partie 1 â€” Serveur TCP minimal en C (mono-client)
ğŸ“š Objectif immÃ©diat
Coder un serveur TCP qui fait :

ğŸ”Œ Ã‰coute sur un port fixe,

ğŸ¤ Accepte 1 client entrant,

ğŸ“¥ Lit un message envoyÃ©,

ğŸ“¤ RÃ©pond un message simple ("OK\n"),

âŒ Ferme proprement la connexion.

ğŸ§± Ã‰tapes de base

Ã‰tape Fonction Description
1 socket() CrÃ©er une socket rÃ©seau
2 bind() Associer Ã  une IP + port
3 listen() Mettre la socket en mode Ã©coute
4 accept() Accepter une connexion entrante
5 read() / write() Communiquer
6 close() Fermer proprement les sockets
ğŸ“‹ Code complet d'un serveur TCP mono-client (main.c)
c
Copier
Modifier
```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <netinet/in.h>
# include <sys/socket.h>

```
# define PORT 4242
# define BUFFER_SIZE 1024

int main(void)
{
```c
 int server_fd, client_fd;
 struct sockaddr_in address;
 socklen_t addrlen = sizeof(address);
 char buffer[BUFFER_SIZE] = {0};

```
c
 // 1. CrÃ©er socket
 server_fd = socket(AF_INET, SOCK_STREAM, 0);
 if (server_fd == -1)
 {
 perror("socket");
 exit(EXIT_FAILURE);
 }

```
c
 // 2. PrÃ©parer struct sockaddr_in
 address.sin_family = AF_INET;
 address.sin_addr.s_addr = INADDR_ANY; // accepte toutes les IP
 address.sin_port = htons(PORT); // convertir en format rÃ©seau

```
c
 // 3. Bind
 if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
 {
 perror("bind");
 exit(EXIT_FAILURE);
 }

```
c
 // 4. Listen
 if (listen(server_fd, 1) < 0)
 {
 perror("listen");
 exit(EXIT_FAILURE);
 }

```
c
 printf("ğŸŸ¢ Serveur prÃªt sur le port %d... Attente de connexion...\n", PORT);

```
c
 // 5. Accept
 client_fd = accept(server_fd, (struct sockaddr *)&address, &addrlen);
 if (client_fd < 0)
 {
 perror("accept");
 exit(EXIT_FAILURE);
 }

```
c
 printf("ğŸ¤ Client connectÃ©\n");

```
c
 // 6. Lecture
 int bytes = read(client_fd, buffer, BUFFER_SIZE - 1);
 if (bytes > 0)
 {
 buffer[bytes] = '\0';
 printf("ğŸ“¥ ReÃ§u: %s", buffer);
 // 7. RÃ©pondre
 write(client_fd, "OK\n", 3);
 }

```
c
 // 8. Fermer les sockets
 close(client_fd);
 close(server_fd);
 printf("âŒ Connexion fermÃ©e\n");

```
c
 return 0;
}
ğŸ“¦ Compilation
bash
Copier
Modifier
gcc -Wall -Wextra -Werror -o server main.c
ğŸ“‹ Test avec un client simple
Dans un autre terminal :

```
bash
Copier
Modifier
nc localhost 4242
Tapez un message (ex: Hello serveur) â” tu dois recevoir: OK

ğŸ“š Concepts appris dans cette partie

Ã‰lÃ©ment Appris
Socket Point d'entrÃ©e rÃ©seau
bind Fixe le port/IP
listen Met en attente de connexion
accept GÃ¨re une demande entrante
read/write Ã‰change de donnÃ©es
close() LibÃ©ration des ressources

# Bloc 7 â€” Partie 2 â€” Serveur TCP multiclient avec select()
ğŸ“š Objectif immÃ©diat
Tu vas modifier ton serveur TCP pour :

GÃ©rer plusieurs connexions clientes Ã  la fois,

Lire les messages de n'importe quel client sans bloquer,

RÃ©pondre correctement Ã  chacun.

Sans utiliser de threads ni de processus, uniquement select() !

ğŸ“‹ Pourquoi select() ?
Permet de surveiller plusieurs file descriptors (fd) en mÃªme temps,

Peut surveiller :

des sockets en lecture (read),

en Ã©criture (write),

en erreur.

ğŸ“¦ Comment fonctionne select()

Ã‰tape Action
1 CrÃ©er un ensemble (fd_set) de sockets Ã  surveiller
2 Appeler select() qui attend jusqu'Ã  ce qu'un fd soit prÃªt
3 Quand select() dÃ©tecte un Ã©vÃ©nement, traiter uniquement les sockets actifs
ğŸ“‹ Nouveau flux du serveur TCP
plaintext
Copier
Modifier
1. PrÃ©parer fd_set avec server_fd et tous les clients connectÃ©s
2. select()
3. Si server_fd est prÃªt â†’ nouvelle connexion
4. Si client_fd est prÃªt â†’ lire son message
5. RÃ©pondre ou fermer client si besoin
ğŸ“š Code de serveur TCP multiclient avec select()
c
Copier
Modifier
```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <netinet/in.h>
# include <sys/socket.h>
# include <sys/select.h>

```
# define PORT 4242
# define BUFFER_SIZE 1024
# define MAX_CLIENTS 10

int main(void)
{
```c
 int server_fd, client_fd, max_fd, activity, new_socket;
 struct sockaddr_in address;
 socklen_t addrlen = sizeof(address);
 int clients[MAX_CLIENTS];
 fd_set readfds;
 char buffer[BUFFER_SIZE];
 int i;

```
c
 // Initialiser les clients
 for (i = 0; i < MAX_CLIENTS; i++)
 clients[i] = 0;

```
c
 // 1. CrÃ©er socket serveur
 server_fd = socket(AF_INET, SOCK_STREAM, 0);
 if (server_fd == -1)
 {
 perror("socket");
 exit(EXIT_FAILURE);
 }

```
c
 // 2. Bind
 address.sin_family = AF_INET;
 address.sin_addr.s_addr = INADDR_ANY;
 address.sin_port = htons(PORT);

```
 if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
 {
 perror("bind");
 exit(EXIT_FAILURE);
 }

```c
 // 3. Listen
 if (listen(server_fd, 3) < 0)
 {
 perror("listen");
 exit(EXIT_FAILURE);
 }

```
c
 printf("ğŸŸ¢ Serveur multi-clients dÃ©marrÃ© sur port %d\n", PORT);

```
 while (1)
 {
 FD_ZERO(&readfds);
 FD_SET(server_fd, &readfds);
 max_fd = server_fd;

```c
 // Ajouter les clients existants
 for (i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] > 0)
 FD_SET(clients[i], &readfds);

```
 if (clients[i] > max_fd)
 max_fd = clients[i];
 }

```c
 // 4. Attendre activitÃ© sur n'importe quel socket
 activity = select(max_fd + 1, &readfds, NULL, NULL, NULL);
 if (activity < 0)
 {
 perror("select");
 continue;
 }

```
c
 // 5. Nouvelle connexion
 if (FD_ISSET(server_fd, &readfds))
 {
 if ((new_socket = accept(server_fd, (struct sockaddr *)&address, &addrlen)) < 0)
 {
 perror("accept");
 exit(EXIT_FAILURE);
 }

```
c
 printf("ğŸ¤ Nouveau client connectÃ©: socket fd %d\n", new_socket);

```
c
 for (i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] == 0)
 {
 clients[i] = new_socket;
 break;
 }
 }
 }

```
c
 // 6. Lire messages clients
 for (i = 0; i < MAX_CLIENTS; i++)
 {
 client_fd = clients[i];
 if (FD_ISSET(client_fd, &readfds))
 {
 int bytes = read(client_fd, buffer, BUFFER_SIZE);
 if (bytes <= 0)
 {
 // DÃ©connexion
 printf("âŒ Client dÃ©connectÃ©: socket fd %d\n", client_fd);
 close(client_fd);
 clients[i] = 0;
 }
 else
 {
 buffer[bytes] = '\0';
 printf("ğŸ“¥ Message du client %d: %s", client_fd, buffer);
 send(client_fd, "OK\n", 3, 0);
 }
 }
 }
 }

```
c
 return 0;
}
ğŸ“š Concepts renforcÃ©s ici

```
Ã‰lÃ©ment Ce qu'on apprend
fd_set Surveiller plusieurs sockets
select() Attendre plusieurs Ã©vÃ©nements simultanÃ©ment
Gestion dynamique des clients Ajouter/retirer proprement
RÃ©pondre individuellement Communication parallÃ¨le non bloquante
ğŸ¯ Mini Plan d'Action Partie 2
PrÃ©parer un tableau clients[],

Utiliser FD_SET pour surveiller server_fd + clients[],

Avec select(), gÃ©rer les connexions entrantes + messages,

DÃ©tecter les dÃ©connexions,

Tester avec netcat (nc localhost 4242) plusieurs clients.

ğŸ“‹ TDD minimal Bloc 7 Partie 2

Test Ce qu'on attend
Connexion 1 client â†’ dialogue OK
Connexion 3 clients â†’ dialogue en parallÃ¨le OK
DÃ©connexion brutale d'un client Pas de crash
Envoi rapide de messages multiples Pas de perte

# Bloc 7 â€” Partie 3 â€” ImplÃ©menter un mini-protocole (PING, ECHO, TIME, etc.)
ğŸ“š Objectif immÃ©diat
â” Ajouter un systÃ¨me simple pour :

Comprendre des commandes texte envoyÃ©es par les clients,

RÃ©pondre avec des rÃ©ponses adaptÃ©es,

GÃ©rer les erreurs (commande inconnue).

ğŸ“‹ Commandes Ã  implÃ©menter

Commande RÃ©ponse attendue
PING PONG\n
ECHO <texte> <texte>\n
TIME Affiche l'heure du serveur
EXIT Ferme la connexion avec le client
(bonus) commande inconnue ERROR: Unknown command\n
ğŸ§  Comment traiter un message reÃ§u
Lire la ligne envoyÃ©e par le client,

Parser la commande principale (PING, ECHO, etc.),

Comparer avec les commandes connues,

RÃ©pondre avec send(),

(Si EXIT) fermer proprement le client.

ğŸ“š Ajout de la fonction handle_client_message()
Dans client_handler.c :

c
Copier
Modifier
```c
# include <stdio.h>
# include <string.h>
# include <unistd.h>
# include <time.h>

```
void handle_client_message(int client_fd, char *message)
{
 if (strncmp(message, "PING", 4) == 0)
 {
 send(client_fd, "PONG\n", 5, 0);
 }
 else if (strncmp(message, "ECHO ", 5) == 0)
 {
 send(client_fd, message + 5, strlen(message + 5), 0);
 send(client_fd, "\n", 1, 0);
 }
 else if (strncmp(message, "TIME", 4) == 0)
 {
 time_t now = time(NULL);
```c
 char *timestr = ctime(&now);
 send(client_fd, timestr, strlen(timestr), 0);
 }
 else if (strncmp(message, "EXIT", 4) == 0)
 {
 send(client_fd, "Bye!\n", 5, 0);
 close(client_fd);
 }
 else
 {
 send(client_fd, "ERROR: Unknown command\n", 23, 0);
 }
}
ğŸ“‹ Mise Ã  jour du serveur dans main.c
Dans ta boucle principale, au lieu d'envoyer juste "OK\n", tu appelles :

```
c
Copier
Modifier
handle_client_message(client_fd, buffer);
ğŸ“¦ Nouveau flux complet
plaintext
Copier
Modifier
- Client envoie "PING"
- Serveur rÃ©pond "PONG"
- Client envoie "ECHO Hello"
- Serveur rÃ©pond "Hello"
- Client envoie "TIME"
- Serveur rÃ©pond date/heure
- Client envoie "EXIT"
- Serveur ferme connexion
ğŸ“š Astuces

ProblÃ¨me courant Solution
Comparaison partielle (seulement les premiers mots) Utiliser strncmp() et tailles fixes
Gestion propre de EXIT Fermer client_fd immÃ©diatement
Nettoyer les buffers avant d'Ã©crire Toujours remettre \0 aprÃ¨s read()
ğŸ¯ Mini plan d'action Partie 3
Lire les commandes des clients,

Appeler handle_client_message(client_fd, message),

RÃ©pondre selon la commande,

Fermer proprement aprÃ¨s EXIT.

ğŸ“‹ TDD minimal Bloc 7 Partie 3

Client commande RÃ©ponse attendue
PING PONG\n
ECHO Salut Salut\n
TIME Heure actuelle
EXIT DÃ©connexion immÃ©diate
HELLO ERROR: Unknown command\n

# Bloc 7 â€” Partie 4 â€” Refactorisation propre: serveur modulaire
ğŸ“š Objectif immÃ©diat
Structurer ton code pour :

Le rendre plus propre,

Le rendre plus lisible,

Le rendre plus Ã©volutif (ajout facile de nouvelles fonctionnalitÃ©s).

ğŸ“‹ Pourquoi structurer ?

Raison Impact
Code lisible âœ… Plus facile Ã  maintenir
Modulaire âœ… Ajout/suppression de fonctions rapide
Projet "pro" âœ… Ressemble Ã  un vrai projet C d'entreprise
Evite le "spaghetti code" âœ… Meilleure scalabilitÃ©
ğŸ“š Nouvelle architecture du projet
plaintext
Copier
Modifier
tcp_server/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c # Initialisation serveur + boucle principale
â”‚ â”œâ”€â”€ server.c # Gestion sockets serveur
â”‚ â”œâ”€â”€ client_handler.c # Gestion lecture/Ã©criture client
â”‚ â”œâ”€â”€ protocol.c # Parsing et rÃ©ponse aux commandes
â”‚ â”œâ”€â”€ utils.c # Petites fonctions utilitaires
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ server.h
â”‚ â”œâ”€â”€ client_handler.h
â”‚ â”œâ”€â”€ protocol.h
â”‚ â”œâ”€â”€ utils.h
â”œâ”€â”€ Makefile
ğŸ“š RÃ´le de chaque fichier

Fichier Contenu
main.c Boucle principale, select(), gestion des fd
server.c Fonctions pour socket(), bind(), listen(), accept()
client_handler.c Fonctions pour lire/Ã©crire sur les sockets clients
protocol.c DÃ©codage des commandes reÃ§ues
utils.c Fonctions annexes (debug, logs, buffer tools...)
ğŸ“‹ Exemples de fonctions par fichier
ğŸ“¦ server.c
c
Copier
Modifier
```c
int create_server_socket(int port);
int accept_new_client(int server_fd);
ğŸ“¦ client_handler.c
c
Copier
Modifier
void handle_client_activity(int client_fd);
void close_client(int client_fd, int *clients);
ğŸ“¦ protocol.c
c
Copier
Modifier
void handle_client_message(int client_fd, char *message);
ğŸ“¦ utils.c
c
Copier
Modifier
void error_exit(const char *msg);
void clear_buffer(char *buffer, int size);
ğŸ“š Mise Ã  jour de main.c
Ton main.c deviendra ultra lÃ©ger :

```
c
Copier
Modifier
```c
# include "server.h"
# include "client_handler.h"
# include "utils.h"

```
int main(void)
{
```c
 int server_fd = create_server_socket(4242);
 int clients[MAX_CLIENTS] = {0};

```
 while (1)
 server_loop(server_fd, clients);

```c
 return 0;
}
(Le server_loop() gÃ©rera select(), acceptations et lectures clients.)

```
ğŸ“‹ Makefile propre
Makefile
Copier
Modifier
NAME = server

SRCS = src/main.c src/server.c src/client_handler.c src/protocol.c src/utils.c
OBJS = $(SRCS:.c=.o)
INCS = -Iinclude
CC = gcc
CFLAGS = -Wall -Wextra -Werror

all: $(NAME)

$(NAME): $(OBJS)
 $(CC) $(CFLAGS) $(INCS) -o $@ $^

clean:
 rm -f $(OBJS)

fclean: clean
 rm -f $(NAME)

re: fclean all
ğŸ“š Mini rappel: MAX_CLIENTS
Ã€ garder dans server.h ou un config.h :

c
Copier
Modifier
# define MAX_CLIENTS 10
# define BUFFER_SIZE 1024
ğŸ¯ Mini plan d'action Partie 4
DÃ©couper main.c en 3-4 modules,

CrÃ©er dossiers src/ et include/,

Faire un Makefile propre,

Tester que tout fonctionne toujours,

PrÃ©parer pour ajouts futurs (authentification, messages privÃ©s, etc.).

ğŸ“‹ TDD minimal Bloc 7 Partie 4

VÃ©rification Attendu
Compilation sans warnings âœ…
Serveur fonctionnel âœ…
Clients multiples connectÃ©s simultanÃ©ment âœ…
PING, ECHO, TIME, EXIT fonctionnels âœ…
Makefile re propre âœ…

# Bloc 7 â€” Partie 5 â€” CrÃ©er ton propre client TCP en C
ğŸ“š Objectif immÃ©diat
â” Tu vas coder un programme qui :

Se connecte au serveur que tu as dÃ©veloppÃ©,

Envoie des commandes (PING, ECHO, TIME, EXIT...),

ReÃ§oit et affiche les rÃ©ponses du serveur,

Fonctionne dans une boucle interactive.

ğŸ“‹ Ã‰tapes principales du client

Ã‰tape Action
1 CrÃ©er une socket client
2 Connecter au serveur (connect())
3 Envoyer un message tapÃ© par l'utilisateur
4 Lire la rÃ©ponse du serveur
5 RÃ©pÃ©ter jusqu'Ã  EXIT ou fermeture
ğŸ“š Code complet d'un petit client TCP (client.c)
c
Copier
Modifier
```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <netinet/in.h>
# include <sys/socket.h>
# include <arpa/inet.h>

```
# define PORT 4242
# define BUFFER_SIZE 1024

int main(void)
{
```c
 int sock = 0;
 struct sockaddr_in serv_addr;
 char buffer[BUFFER_SIZE] = {0};
 char input[BUFFER_SIZE] = {0};
 int bytes;

```
c
 // 1. CrÃ©er socket
 sock = socket(AF_INET, SOCK_STREAM, 0);
 if (sock < 0)
 {
 perror("socket");
 exit(EXIT_FAILURE);
 }

```
c
 // 2. PrÃ©parer adresse serveur
 serv_addr.sin_family = AF_INET;
 serv_addr.sin_port = htons(PORT);

```
c
 // 3. Convertir IP
 if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0)
 {
 printf("âŒ Adresse invalide\n");
 return -1;
 }

```
c
 // 4. Connecter
 if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
 {
 perror("connect");
 exit(EXIT_FAILURE);
 }

```
c
 printf("ğŸŸ¢ ConnectÃ© au serveur sur 127.0.0.1:%d\n", PORT);

```
 while (1)
 {
```c
 printf("ğŸ–‹ï¸ > ");
 if (!fgets(input, BUFFER_SIZE, stdin))
 break;

```
c
 // Supprimer le '\n' de fgets
 input[strcspn(input, "\n")] = 0;

```
 if (send(sock, input, strlen(input), 0) < 0)
 {
 perror("send");
 break;
 }

 bytes = recv(sock, buffer, BUFFER_SIZE - 1, 0);
 if (bytes <= 0)
 {
```c
 printf("âŒ Serveur dÃ©connectÃ©\n");
 break;
 }

```
 buffer[bytes] = '\0';
```c
 printf("ğŸ“¥ RÃ©ponse: %s", buffer);

```
 if (strcmp(input, "EXIT") == 0)
 break;
 }

 close(sock);
```c
 printf("ğŸšª DÃ©connectÃ©\n");
 return 0;
}
ğŸ“¦ Compilation
bash
Copier
Modifier
gcc -Wall -Wextra -Werror -o client client.c
ğŸ“š Concepts appris ici

```
Ã‰lÃ©ment Ce qu'on apprend
socket() CrÃ©er une connexion TCP client
connect() Se lier Ã  une IP + port distant
send() / recv() Dialogue bidirectionnel
close() Fermer la socket proprement
Boucle interactive Simulation simple d'un terminal rÃ©seau
ğŸ“‹ Test complet

Ã‰tape Ce qui doit se passer
Lancer serveur (./server) 
Lancer client (./client) 
Taper PING Le serveur rÃ©pond PONG
Taper ECHO Hello World Le serveur rÃ©pÃ¨te Hello World
Taper TIME Le serveur donne l'heure
Taper EXIT Le serveur ferme la connexion
ğŸ¯ Mini plan d'action Partie 5
Ã‰crire client.c,

Connecter au serveur,

Envoyer/recevoir en boucle,

GÃ©rer la commande EXIT,

PrÃ©parer pour un client plus "pro" ensuite si besoin.

ğŸ“‹ TDD minimal Bloc 7 Partie 5

Test Ce qu'on attend
Connexion au serveur âœ…
Envoi de message âœ…
RÃ©ception de rÃ©ponse correcte âœ…
DÃ©connexion propre âœ…
Fermeture sur erreur âœ…

# Bloc 7 â€” Partie 6 â€” Mode Chat Multiclient (Broadcast)
ğŸ“š Objectif immÃ©diat
AmÃ©liorer ton serveur TCP pour :

ğŸ“¢ Quand un client envoie un message, le serveur retransmet ce message Ã  tous les autres clients,

GÃ©rer proprement les entrÃ©es/sorties pour tous,

GÃ©rer les dÃ©connexions sans casser tout.

ğŸ“‹ Fonctionnement du mode Chat

Action Comportement
Un client Ã©crit un message Serveur relaie Ã  tous les autres
Un client quitte (EXIT) Serveur ferme sa socket et informe les autres si besoin
Tous les messages sont diffusÃ©s Broadcast sauf vers l'expÃ©diteur
ğŸ“¦ Comment modifier ton serveur
Tu dois :

Lire un message d'un client,

Le retransmettre Ã  tous les autres clients connectÃ©s.

ğŸ“‹ Fonction broadcast_message()
Dans client_handler.c par exemple :

c
Copier
Modifier
```c
# include <string.h>
# include <unistd.h>
# include "server.h"

```
void broadcast_message(int sender_fd, int *clients, char *message)
{
```c
 for (int i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] > 0 && clients[i] != sender_fd)
 {
 send(clients[i], message, strlen(message), 0);
 }
 }
}
ğŸ“š Mise Ã  jour dans ta boucle principale
Quand tu reÃ§ois un message d'un client :

```
c
Copier
Modifier
```c
int bytes = read(client_fd, buffer, BUFFER_SIZE);
if (bytes <= 0)
{
 // DÃ©connexion
 printf("âŒ Client dÃ©connectÃ©: socket fd %d\n", client_fd);
 close(client_fd);
 clients[i] = 0;
}
else
{
 buffer[bytes] = '\0';
 printf("ğŸ“¥ Message du client %d: %s", client_fd, buffer);

```
 if (strncmp(buffer, "EXIT", 4) == 0)
 {
 send(client_fd, "Bye!\n", 5, 0);
 close(client_fd);
 clients[i] = 0;
 }
 else
 {
 broadcast_message(client_fd, clients, buffer);
 }
}
ğŸ“š Important

PiÃ¨ge courant Solution
Envoyer au client qui a Ã©crit VÃ©rifie clients[i] != sender_fd
Oublier \0 dans buffer Toujours terminer buffer[bytes] = '\0'
Ne pas fermer les sockets mortes Toujours close() et clients[i] = 0 si dÃ©connectÃ©
ğŸ“‹ Exemple de dialogue entre 3 clients
plaintext
Copier
Modifier
Client 1 â” Hello
Client 2 â” ReÃ§oit: Hello
Client 3 â” ReÃ§oit: Hello

Client 2 â” Hi there!
Client 1 â” ReÃ§oit: Hi there!
Client 3 â” ReÃ§oit: Hi there!
ğŸ“¦ Tu peux aussi ajouter une Ã©tiquette d'expÃ©diteur (bonus)
Exemple dans broadcast_message() :

c
Copier
Modifier
```c
char temp[BUFFER_SIZE];
snprintf(temp, sizeof(temp), "Client %d: %s", sender_fd, message);
Et ensuite envoyer temp au lieu de message â” plus propre !

```
ğŸ“‹ TDD minimal Bloc 7 Partie 6

Test Attendu
Client 1 Ã©crit Client 2 et 3 reÃ§oivent
Client 2 Ã©crit Client 1 et 3 reÃ§oivent
Client 3 dÃ©connecte Pas d'erreur, les autres continuent
Client flood rapide Serveur continue proprement

# Bloc 7 â€” Partie 7 â€” Commandes avancÃ©es pour Chat (/msg, /who)
ğŸ“š Objectif immÃ©diat
Ton serveur va maintenant :

GÃ©rer les messages privÃ©s (/msg <id> <message>),

Permettre Ã  un client de lister tous les clients connectÃ©s (/who).

â” Devenir un mini-IRC simplifiÃ© ! ğŸš€

ğŸ“‹ Commandes Ã  implÃ©menter

Commande Comportement
/msg <client_id> <message> Envoie un message privÃ© Ã  un seul client
/who Renvoie la liste des IDs de tous les clients connectÃ©s
Autre Message inconnu â” ERROR: Unknown command\n
ğŸ“¦ Mise Ã  jour dans handle_client_message()
Remplace la gestion simple par une gestion avancÃ©e des commandes :

ğŸ“‹ Nouveau handle_client_message()
c
Copier
Modifier
```c
# include <stdio.h>
# include <string.h>
# include <unistd.h>
# include "server.h"

```
void handle_client_message(int client_fd, int *clients, char *message)
{
```c
 char temp[BUFFER_SIZE];
 int target_fd;
 int target_id;
 char *msg_start;

```
 if (strncmp(message, "/msg ", 5) == 0)
 {
```c
 // /msg <client_id> <message>
 target_id = atoi(message + 5);
 msg_start = strchr(message + 5, ' ');
 if (msg_start)
 {
 msg_start++; // avancer aprÃ¨s l'espace
 for (int i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] == target_id)
 {
 snprintf(temp, sizeof(temp), "[privÃ© de %d]: %s\n", client_fd, msg_start);
 send(clients[i], temp, strlen(temp), 0);
 return;
 }
 }
 send(client_fd, "âŒ Client inconnu\n", 18, 0);
 }
 else
 {
 send(client_fd, "âŒ Format: /msg <id> <message>\n", 30, 0);
 }
 }
 else if (strncmp(message, "/who", 4) == 0)
 {
 strcpy(temp, "ğŸ‘¥ Clients connectÃ©s: ");
 for (int i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] > 0)
 {
 char id[10];
 snprintf(id, sizeof(id), "%d ", clients[i]);
 strcat(temp, id);
 }
 }
 strcat(temp, "\n");
 send(client_fd, temp, strlen(temp), 0);
 }
 else
 {
 send(client_fd, "ERROR: Unknown command\n", 23, 0);
 }
}
ğŸ“š Explication simple

```
Cas Action
/msg <id> <text> Trouve le client ayant cet ID, lui envoie le message privÃ©
/who Envoie la liste de tous les clients connectÃ©s
Commande inconnue Envoie une erreur simple
ğŸ“‹ Utilisation pratique par les utilisateurs
Exemple conversation :
plaintext
Copier
Modifier
Client 1 â” /who
Serveur â” ğŸ‘¥ Clients connectÃ©s: 4 5 6

Client 4 â” /msg 5 Salut toi !
Client 5 â” reÃ§oit "[privÃ© de 4]: Salut toi !"
ğŸ“¦ Mise Ã  jour de la boucle serveur
Dans ta boucle principale, au lieu de juste diffuser :

c
Copier
Modifier
if (buffer[0] == '/')
 handle_client_message(client_fd, clients, buffer);
else
 broadcast_message(client_fd, clients, buffer);
â” On traite les commandes spÃ©ciales (/msg, /who), sinon on diffuse Ã  tout le monde.

ğŸ¯ Mini plan d'action Partie 7
Modifier handle_client_message() pour comprendre /msg et /who,

Ajuster la boucle principale pour appeler correctement,

Tester plusieurs clients,

GÃ©rer erreur propre si mauvais format.

ğŸ“‹ TDD minimal Bloc 7 Partie 7

Commande RÃ©sultat attendu
/who Liste des IDs connectÃ©s
/msg <id> Hello Message privÃ© correct
/msg <id> sans texte Erreur de format
/msg id_inexistant Erreur "Client inconnu"
Commande inconnue Erreur standard

# Bloc 7 â€” Partie 8/8 â€” Finalisation du serveur: Robustesse & PropretÃ©
ğŸ“š Objectif immÃ©diat
â” Stabiliser totalement ton serveur :

âœ… DÃ©tecter proprement les dÃ©connexions inattendues (client qui quitte brutalement),

âœ… Ajouter un timeout d'inactivitÃ© (bonus),

âœ… Ã‰viter toute fuite mÃ©moire ou socket ouverte,

âœ… Rendre les erreurs visibles clairement,

âœ… Avoir un Makefile propre et une structure finale propre.

ğŸ“‹ Points critiques Ã  corriger / ajouter
1. DÃ©connexion brutale (CTRL+C, crash client)
Dans ta lecture (read() ou recv()), bytes == 0 signifie client dÃ©connectÃ©.

â” DÃ©jÃ  gÃ©rÃ© si tu as :

c
Copier
Modifier
if (bytes <= 0)
{
```c
 printf("âŒ Client dÃ©connectÃ©: socket fd %d\n", client_fd);
 close(client_fd);
 clients[i] = 0;
}
âœ”ï¸ Rien d'autre Ã  faire !

```
2. Timeout d'inactivitÃ© (bonus)
â” En option, avec select(), tu peux fixer un timeout sur la boucle principale.

Ajout simple :

c
Copier
Modifier
struct timeval timeout;
timeout.tv_sec = 300; // 5 minutes
timeout.tv_usec = 0;
Puis utiliser :

c
Copier
Modifier
select(max_fd + 1, &readfds, NULL, NULL, &timeout);
â” Si aucun client ne bouge pendant 5 minutes â” tu peux dÃ©cider d'envoyer un message d'inactivitÃ© ou fermer les connexions.

3. Messages d'erreur propres
Partout oÃ¹ un send(), recv(), ou accept() Ã©choue â” afficher un perror().

Exemple :

c
Copier
Modifier
if ((new_socket = accept(server_fd, (struct sockaddr *)&address, &addrlen)) < 0)
{
 perror("accept");
 continue;
}
4. Makefile final
Makefile propre avec debug facile :

Makefile
Copier
Modifier
NAME = server
NAME_CLIENT = client

SRCS_SERVER = src/main.c src/server.c src/client_handler.c src/protocol.c src/utils.c
SRCS_CLIENT = client/client.c

OBJS_SERVER = $(SRCS_SERVER:.c=.o)
OBJS_CLIENT = $(SRCS_CLIENT:.c=.o)

INCS = -Iinclude
CC = gcc
CFLAGS = -Wall -Wextra -Werror

all: $(NAME) $(NAME_CLIENT)

$(NAME): $(OBJS_SERVER)
 $(CC) $(CFLAGS) $(INCS) -o $@ $^

$(NAME_CLIENT): $(OBJS_CLIENT)
 $(CC) $(CFLAGS) -o $@ $^

clean:
 rm -f $(OBJS_SERVER) $(OBJS_CLIENT)

fclean: clean
 rm -f $(NAME) $(NAME_CLIENT)

re: fclean all
ğŸ“š Structure finale recommandÃ©e
plaintext
Copier
Modifier
tcp_server/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c
â”‚ â”œâ”€â”€ server.c
â”‚ â”œâ”€â”€ server.h
â”‚ â”œâ”€â”€ client_handler.c
â”‚ â”œâ”€â”€ client_handler.h
â”‚ â”œâ”€â”€ protocol.c
â”‚ â”œâ”€â”€ protocol.h
â”‚ â”œâ”€â”€ utils.c
â”‚ â”œâ”€â”€ utils.h
â”œâ”€â”€ client/
â”‚ â”œâ”€â”€ client.c
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ config.h (MAX_CLIENTS, BUFFER_SIZE)
â”œâ”€â”€ Makefile
ğŸ“‹ Tests finaux avant validation

Test Ce qui doit Ãªtre OK
Connexion 5 clients simultanÃ©s âœ…
Broadcast messages âœ…
Message privÃ© (/msg) âœ…
Liste connectÃ©s (/who) âœ…
DÃ©connexion brutale client Pas de crash
Timeout inactivitÃ© (option) DÃ©connecte proprement
Valgrind (pas de fuites sockets) âœ…
Norme 42 (-Wall -Wextra -Werror) âœ…
ğŸ¯ RÃ©sultat final
âœ… Tu as un vrai serveur TCP multiclient Chat :

Gestion multi-clients sans thread,

Commandes /msg, /who, EXIT,

Timeouts (bonus),

Code propre et bien modulaire.

# Bloc 8 â€” DÃ©veloppement d'un Mini Moteur 3D en C avec OpenGL
ğŸ“š Objectif global
CrÃ©er Ã  la main :

Un moteur de rendu 3D,

En C pur,

BasÃ© sur OpenGL + GLFW (librairies basiques pour ouverture de fenÃªtre et affichage),

Sans utiliser de moteur externe (pas Unity, pas Unreal).

ğŸ“‹ Ã‰tapes principales du projet

Ã‰tape Description
Partie 1 CrÃ©er une fenÃªtre OpenGL
Partie 2 Afficher un triangle simple
Partie 3 Charger des modÃ¨les 3D basiques
Partie 4 Ajouter une camÃ©ra mobile (vue FPS ou orbitale)
Partie 5 Ã‰clairages simples
Partie 6 Textures sur les objets
Partie 7 Bonus: scÃ¨ne complÃ¨te, skybox, UI simple
ğŸ“š CompÃ©tences que tu vas acquÃ©rir

CompÃ©tence UtilitÃ©
Programmation graphique 3D âœ…
Matrices 3D (MVP: Model-View-Projection) âœ…
Programmation Ã©vÃ©nementielle (clavier/souris) âœ…
Gestion mÃ©moire avancÃ©e pour ressources 3D âœ…
Optimisation du rendu âœ…
Bases solides pour OpenGL, Vulkan, Metal... âœ…
ğŸ“¦ MatÃ©riel requis

Logiciel DÃ©tail
OpenGL (dÃ©jÃ  inclus sur Linux / Mac) Affichage 3D
GLFW Ouverture de fenÃªtre, gestion input
GLAD (optionnel) Pour charger les fonctions OpenGL modernes
gcc Compilation classique
Makefile propre Comme d'habitude !
ğŸ“š Structure du projet recommandÃ©e
plaintext
Copier
Modifier
mini_3d_engine/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c # DÃ©marrage moteur
â”‚ â”œâ”€â”€ window.c # CrÃ©ation fenÃªtre + gestion Ã©vÃ©nements
â”‚ â”œâ”€â”€ renderer.c # Rendu de base (triangles, modÃ¨les)
â”‚ â”œâ”€â”€ shader.c # Chargement et utilisation de shaders
â”‚ â”œâ”€â”€ camera.c # Mouvement camÃ©ra
â”‚ â”œâ”€â”€ model.c # Gestion modÃ¨les 3D
â”‚ â”œâ”€â”€ texture.c # Application de textures
â”œâ”€â”€ shaders/
â”‚ â”œâ”€â”€ basic.vert # Shader de vertex
â”‚ â”œâ”€â”€ basic.frag # Shader de fragment
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ engine.h
â”‚ â”œâ”€â”€ window.h
â”‚ â”œâ”€â”€ renderer.h
â”‚ â”œâ”€â”€ shader.h
â”‚ â”œâ”€â”€ camera.h
â”‚ â”œâ”€â”€ model.h
â”‚ â”œâ”€â”€ texture.h
â”œâ”€â”€ Makefile
ğŸ“‹ Objectifs d'affichage

Cible Description
ğŸ¯ Partie 1 Ouvrir une fenÃªtre noire sans crash
ğŸ¯ Partie 2 Dessiner un triangle colorÃ©
ğŸ¯ Partie 3 Charger un modÃ¨le .obj basique
ğŸ¯ Partie 4 ContrÃ´ler une camÃ©ra FPS (WASD + souris)
ğŸ¯ Partie 5 Ajouter lumiÃ¨re simple (Phong, Blinn)
ğŸ¯ Partie 6 Appliquer textures sur modÃ¨les
ğŸ¯ Partie 7 Charger plusieurs objets dans une scÃ¨ne complÃ¨te
ğŸ“š Petites bases que tu dois connaÃ®tre avant de commencer
Un vertex est un point 3D (x,y,z),

Un triangle est 3 vertex liÃ©s,

Un shader est un petit programme qui dit comment afficher les pixels,

Une matrice MVP est la combinaison qui transforme tes objets en vue camÃ©ra.

ğŸ¯ Mini plan d'action global du Bloc 8
Initialiser GLFW et crÃ©er une fenÃªtre,

Dessiner un triangle OpenGL,

Charger/afficher des modÃ¨les 3D simples,

DÃ©placer la camÃ©ra,

Ã‰clairer la scÃ¨ne,

Appliquer des textures,

Finaliser avec une petite scÃ¨ne complÃ¨te.

# Bloc 8 â€” Partie 1 â€” CrÃ©er une fenÃªtre OpenGL avec GLFW
ğŸ“š Objectif immÃ©diat
Tu vas :

Initialiser la bibliothÃ¨que GLFW,

CrÃ©er une fenÃªtre vide,

Ouvrir une connexion OpenGL,

Laisser la fenÃªtre ouverte tant que l'utilisateur ne la ferme pas.

ğŸ“¦ Ce qu'est GLFW

Ã‰lÃ©ment UtilitÃ©
GLFW Librairie lÃ©gÃ¨re pour crÃ©er fenÃªtres OpenGL et capturer les Ã©vÃ©nements clavier/souris
ğŸ“‹ Ce qu'on veut obtenir maintenant
Une fenÃªtre vide noire,

Qui reste ouverte jusqu'Ã  ce que tu cliques sur [X] pour fermer.

ğŸ“š Installer GLFW
Sur Linux (Ubuntu/Debian) :

bash
Copier
Modifier
sudo apt-get install libglfw3 libglfw3-dev
Sur Mac :

bash
Copier
Modifier
brew install glfw
Sous Windows â” je te donnerai les instructions si tu veux.

ğŸ“‹ Code complet pour crÃ©er une fenÃªtre (main.c)
c
Copier
Modifier
```c
# include <GLFW/glfw3.h>
# include <stdio.h>

```
int main(void)
{
 if (!glfwInit())
 {
 fprintf(stderr, "âŒ Erreur d'initialisation GLFW\n");
```c
 return -1;
 }

```
c
 // SpÃ©cifier la version OpenGL
 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

```
c
 // CrÃ©er une fenÃªtre
 GLFWwindow* window = glfwCreateWindow(800, 600, "Mini 3D Engine", NULL, NULL);
 if (!window)
 {
 fprintf(stderr, "âŒ Erreur de crÃ©ation de fenÃªtre\n");
 glfwTerminate();
 return -1;
 }

```
c
 // Lier la fenÃªtre au contexte OpenGL courant
 glfwMakeContextCurrent(window);

```
c
 // Boucle principale
 while (!glfwWindowShouldClose(window))
 {
 // Couleur de fond
 glClearColor(0.1f, 0.1f, 0.2f, 1.0f);
 glClear(GL_COLOR_BUFFER_BIT);

```
c
 // Afficher le rendu
 glfwSwapBuffers(window);
 glfwPollEvents();
 }

```
 glfwDestroyWindow(window);
 glfwTerminate();
```c
 return 0;
}
ğŸ“¦ Compilation
bash
Copier
Modifier
gcc -Wall -Wextra -Werror main.c -lglfw -lGL -lm -ldl -pthread -o mini3d
(options lÃ©gÃ¨rement diffÃ©rentes sur Mac, je peux t'aider si besoin)

```
ğŸ“š Que fait ce code

Ã‰tape Action
glfwInit() Initialise la bibliothÃ¨que
glfwCreateWindow() CrÃ©e une fenÃªtre
glfwMakeContextCurrent() Associe OpenGL Ã  la fenÃªtre
Boucle principale Continue Ã  afficher jusqu'Ã  fermeture
glClearColor() DÃ©finit la couleur de fond
glClear() Efface l'Ã©cran Ã  chaque frame
glfwSwapBuffers() Affiche le nouveau contenu
glfwPollEvents() GÃ¨re les clics, clavier, etc
glfwDestroyWindow() et glfwTerminate() Nettoyage propre
ğŸ¯ Mini plan d'action Partie 1
Installer GLFW (si pas fait),

Ã‰crire et compiler main.c,

Ouvrir ta premiÃ¨re fenÃªtre OpenGL,

VÃ©rifier qu'elle reste ouverte sans crash.

ğŸ“‹ TDD minimal Bloc 8 Partie 1

Test Ce qui doit se passer
Lancer l'exÃ©cutable FenÃªtre vide apparaÃ®t
Cliquer sur fermer FenÃªtre disparaÃ®t proprement
Aucun crash âœ…

# Bloc 8 â€” Partie 2 â€” Dessiner un triangle en OpenGL
ğŸ“š Objectif immÃ©diat
Tu vas :

Envoyer des donnÃ©es de vertex Ã  ta carte graphique,

Afficher un triangle simple en couleur,

Comprendre comment la "pipeline graphique" fonctionne.

ğŸ“‹ Concepts importants ici

Terme Description
Vertex Un point (x, y, z) en 3D
VBO (Vertex Buffer Object) MÃ©moire pour stocker les vertex
VAO (Vertex Array Object) Configuration pour expliquer OpenGL comment lire le VBO
Shader Petit programme qui dÃ©cide de l'apparence finale
Pipeline graphique Chemin du vertex brut â†’ pixel affichÃ©
ğŸ“¦ DonnÃ©es pour un simple triangle
On veut dessiner ce triangle :

bash
Copier
Modifier
 â–²
 / \
 /___\
En coordonnÃ©es OpenGL :

c
Copier
Modifier
float vertices[] = {
 0.0f, 0.5f, 0.0f, // Sommet haut
 -0.5f, -0.5f, 0.0f, // Bas gauche
 0.5f, -0.5f, 0.0f // Bas droite
};
ğŸ“š Nouveau code complet (main.c amÃ©liorÃ©)
c
Copier
Modifier
```c
# include <GLFW/glfw3.h>
# include <stdio.h>

```
# define WIDTH 800
# define HEIGHT 600

const char *vertexShaderSource = "# version 330 core\n"
 "layout (location = 0) in vec3 aPos;\n"
 "void main() {\n"
 " gl_Position = vec4(aPos, 1.0);\n"
 "}\0";

const char *fragmentShaderSource = "# version 330 core\n"
 "out vec4 FragColor;\n"
 "void main() {\n"
 " FragColor = vec4(0.5, 0.8, 0.2, 1.0);\n"
 "}\n\0";

int main(void)
{
 if (!glfwInit())
```c
 return -1;

```
 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

 GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "Mini 3D Engine", NULL, NULL);
 if (!window)
 {
 glfwTerminate();
```c
 return -1;
 }
 glfwMakeContextCurrent(window);

```
c
 // DÃ©finir les vertex du triangle
 float vertices[] = {
 0.0f, 0.5f, 0.0f, 
 -0.5f, -0.5f, 0.0f, 
 0.5f, -0.5f, 0.0f
 };

```
c
 unsigned int VBO, VAO;
 glGenVertexArrays(1, &VAO);
 glGenBuffers(1, &VBO);

```
c
 // Lier le VAO
 glBindVertexArray(VAO);

```
c
 // Lier et remplir le VBO
 glBindBuffer(GL_ARRAY_BUFFER, VBO);
 glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

```
c
 // SpÃ©cifier comment lire les donnÃ©es
 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
 glEnableVertexAttribArray(0);

```
c
 // Compiler le vertex shader
 unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
 glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
 glCompileShader(vertexShader);

```
c
 // Compiler le fragment shader
 unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
 glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
 glCompileShader(fragmentShader);

```
c
 // CrÃ©er le shader program
 unsigned int shaderProgram = glCreateProgram();
 glAttachShader(shaderProgram, vertexShader);
 glAttachShader(shaderProgram, fragmentShader);
 glLinkProgram(shaderProgram);

```
c
 // Supprimer les shaders une fois liÃ©s
 glDeleteShader(vertexShader);
 glDeleteShader(fragmentShader);

```
c
 // Boucle principale
 while (!glfwWindowShouldClose(window))
 {
 glClearColor(0.1f, 0.1f, 0.2f, 1.0f);
 glClear(GL_COLOR_BUFFER_BIT);

```
c
 // Utiliser le shader et dessiner
 glUseProgram(shaderProgram);
 glBindVertexArray(VAO);
 glDrawArrays(GL_TRIANGLES, 0, 3);

```
 glfwSwapBuffers(window);
 glfwPollEvents();
 }

 glDeleteVertexArrays(1, &VAO);
 glDeleteBuffers(1, &VBO);

 glfwDestroyWindow(window);
 glfwTerminate();
```c
 return 0;
}
ğŸ“¦ Compilation
bash
Copier
Modifier
gcc -Wall -Wextra -Werror main.c -lglfw -lGL -lm -ldl -pthread -o mini3d
ğŸ“š Ce que tu fais dans ce code

```
Ã‰tape Action
CrÃ©er Vertex Shader Pour positionner les points
CrÃ©er Fragment Shader Pour colorer les pixels
Charger Vertex dans un VBO Stocker points en GPU
Configurer VAO DÃ©finir comment lire VBO
Boucle OpenGL Dessiner en continu
ğŸ¯ Mini plan d'action Partie 2
PrÃ©parer les vertex du triangle,

Compiler et lier shaders,

Envoyer les donnÃ©es vers la carte graphique,

Dessiner avec glDrawArrays().

ğŸ“‹ TDD minimal Bloc 8 Partie 2

Test Ce qui doit Ãªtre visible
Lancer l'exÃ©cutable FenÃªtre 800x600
Triangle vert clair centrÃ© âœ…
Pas de crash au clic fermeture âœ…

# Bloc 8 â€” Partie 3 â€” Charger un modÃ¨le 3D .obj
ğŸ“š Objectif immÃ©diat
Tu vas :

Lire un fichier .obj trÃ¨s simple,

Extraire les positions des vertex,

Envoyer ces vertex Ã  OpenGL,

Afficher le modÃ¨le 3D au lieu d'un simple triangle.

ğŸ“‹ Qu'est-ce qu'un fichier .obj ?
Un .obj (Wavefront OBJ) est un format texte simple contenant :

Les positions (v x y z),

Les faces (f v1 v2 v3) qui lient les vertex entre eux pour crÃ©er des triangles.

Exemple trÃ¨s basique :

plaintext
Copier
Modifier
v 0.0 0.5 0.0
v -0.5 -0.5 0.0
v 0.5 -0.5 0.0
f 1 2 3
(Un triangle exactement comme le prÃ©cÃ©dent mais depuis un fichier.)

ğŸ“š Ã‰tapes pour charger un .obj

Ã‰tape Action
1 Lire les lignes du fichier texte
2 RÃ©cupÃ©rer les v (positions 3D)
3 RÃ©cupÃ©rer les f (faces, indices)
4 GÃ©nÃ©rer un VBO/VAO OpenGL comme avant
5 Dessiner normalement
ğŸ“¦ Code simple pour lire un .obj
ğŸ“‹ Fonction basique pour parser .obj (model.c)
c
Copier
Modifier
```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include "model.h"

```
# define MAX_VERTICES 1000

void load_obj(const char *filename, float *vertices, int *vertex_count)
{
 FILE *file = fopen(filename, "r");
 if (!file)
 {
 perror("fopen");
 exit(EXIT_FAILURE);
 }

```c
 char line[128];
 int count = 0;

```
 while (fgets(line, sizeof(line), file))
 {
 if (line[0] == 'v' && line[1] == ' ')
 {
 float x, y, z;
 sscanf(line, "v %f %f %f", &x, &y, &z);
 vertices[count++] = x;
 vertices[count++] = y;
 vertices[count++] = z;
 }
 }

 fclose(file);
 *vertex_count = count / 3; // Chaque vertex = 3 floats
}
ğŸ“‹ Header associÃ© (model.h)
c
Copier
Modifier
# ifndef MODEL_H
# define MODEL_H

```c
void load_obj(const char *filename, float *vertices, int *vertex_count);

```
# endif
ğŸ“š Comment utiliser Ã§a dans main.c
ğŸ“‹ Ajout dans main.c
Remplacer la dÃ©finition du tableau vertices[] par une lecture .obj.

Exemple :

c
Copier
Modifier
```c
# include "model.h"

```
float vertices[MAX_VERTICES];
```c
int vertex_count;

```
load_obj("triangle.obj", vertices, &vertex_count);

```c
// Puis envoyer les vertices comme avant
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, vertex_count * 3 * sizeof(float), vertices, GL_STATIC_DRAW);
Et pour dessiner :

```
c
Copier
Modifier
glDrawArrays(GL_TRIANGLES, 0, vertex_count);
ğŸ“š Important

Point Ã€ retenir
Un .obj peut contenir Ã©normÃ©ment de vertex Utiliser un tableau assez grand
Cette mÃ©thode lit uniquement positions, pas couleurs, pas normales, pas textures (Ã§a viendra plus tard)
Chaque f doit Ãªtre triangulaire (f 1 2 3) pour ce parseur simplifiÃ© 
ğŸ“‹ Exemple fichier triangle.obj
(Ã€ crÃ©er dans ton projet !)

plaintext
Copier
Modifier
v 0.0 0.5 0.0
v -0.5 -0.5 0.0
v 0.5 -0.5 0.0
f 1 2 3
ğŸ¯ Mini plan d'action Partie 3
CrÃ©er model.c + model.h,

Charger un .obj simple,

Lier dans ton pipeline OpenGL,

Dessiner dynamiquement un modÃ¨le.

ğŸ“‹ TDD minimal Bloc 8 Partie 3

Test Ce qui doit Ãªtre visible
FenÃªtre s'ouvre âœ…
ModÃ¨le du .obj affichÃ© (triangle) âœ…
Aucune fuite mÃ©moire / crash âœ…

# Bloc 8 â€” Partie 4 â€” DÃ©placement et contrÃ´le de camÃ©ra (FPS / Orbitale)
ğŸ“š Objectif immÃ©diat
Tu vas :

ImplÃ©menter une camÃ©ra contrÃ´lable par clavier (WASD) et souris,

Pouvoir te dÃ©placer autour de ton modÃ¨le,

DÃ©couvrir les matrices de transformation 3D (MVP: Model-View-Projection).

ğŸ“‹ Concepts Ã  comprendre ici

Terme Description
View Matrix Position et orientation de la camÃ©ra dans le monde
Projection Matrix Comment convertir 3D â†’ 2D sur ton Ã©cran
WASD DÃ©placement sur les axes
Matrices MathÃ©matiques pour manipuler les points en espace 3D
ğŸ“¦ Outils utilisÃ©s

BibliothÃ¨que UtilitÃ©
GLFW DÃ©tection clavier / souris
GLM (option) BibliothÃ¨que de maths 3D en C (peut Ãªtre optionnel pour dÃ©buter)
(Tu peux commencer sans GLM avec tes propres fonctions, plus tard on optimisera.)

ğŸ“š Comment fonctionne une camÃ©ra simple
Stocke sa position (x, y, z),

Stocke sa direction (regard, angle yaw/pitch),

DÃ©place la position selon les touches clavier,

Change la direction avec la souris.

ğŸ“‹ Base de structure camera.h
c
Copier
Modifier
# ifndef CAMERA_H
# define CAMERA_H

typedef struct s_camera
{
 float pos_x, pos_y, pos_z;
 float yaw, pitch;
 float speed;
 float sensitivity;
} t_camera;

```c
void init_camera(t_camera *camera);
void process_keyboard(t_camera *camera, int key);
void process_mouse(t_camera *camera, double xoffset, double yoffset);
void get_view_matrix(t_camera *camera, float *view);

```
# endif
ğŸ“‹ Exemple d'implÃ©mentation rapide camera.c
c
Copier
Modifier
```c
# include "camera.h"
# include <math.h>

```
void init_camera(t_camera *camera)
{
 camera->pos_x = 0.0f;
 camera->pos_y = 0.0f;
 camera->pos_z = 3.0f;
 camera->yaw = -90.0f;
 camera->pitch = 0.0f;
 camera->speed = 0.05f;
 camera->sensitivity = 0.1f;
}

void process_keyboard(t_camera *camera, int key)
{
 float front_x = cosf(camera->yaw * (3.14159f/180.0f));
 float front_z = sinf(camera->yaw * (3.14159f/180.0f));

 if (key == GLFW_KEY_W)
 {
 camera->pos_x += front_x * camera->speed;
 camera->pos_z += front_z * camera->speed;
 }
 if (key == GLFW_KEY_S)
 {
 camera->pos_x -= front_x * camera->speed;
 camera->pos_z -= front_z * camera->speed;
 }
 if (key == GLFW_KEY_A)
 {
 camera->pos_x -= front_z * camera->speed;
 camera->pos_z += front_x * camera->speed;
 }
 if (key == GLFW_KEY_D)
 {
 camera->pos_x += front_z * camera->speed;
 camera->pos_z -= front_x * camera->speed;
 }
}

```c
// (Version simplifiÃ©e - souris plus tard !)
ğŸ“š Comment brancher dans main.c
ğŸ“‹ Ajout dans boucle principale
c
Copier
Modifier
if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
 process_keyboard(&camera, GLFW_KEY_W);
if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
 process_keyboard(&camera, GLFW_KEY_S);
if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
 process_keyboard(&camera, GLFW_KEY_A);
if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
 process_keyboard(&camera, GLFW_KEY_D);
ğŸ“¦ Modification de ta View Matrix (affichage)
â” Tu dois recalculer la matrice de vue Ã  chaque frame selon la position de ta camÃ©ra.

```
(On ajoutera get_view_matrix() dans Partie 5 avec matrices propres.)

ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
Appuyer sur W Avancer dans la scÃ¨ne
Appuyer sur S Reculer
Appuyer sur A/D Se dÃ©placer Ã  gauche/droite
Souris (plus tard) Bouger la vue
ğŸ¯ Mini plan d'action Partie 4
CrÃ©er camera.h + camera.c,

Stocker position et angles de la camÃ©ra,

ImplÃ©menter WASD simple,

Mettre Ã  jour Ã  chaque frame dans ta boucle.

ğŸ“‹ TDD minimal Bloc 8 Partie 4

Test Ce qui doit marcher
Touche W/S/A/D DÃ©placement visible (pour l'instant simple)
Pas de crash sur input clavier âœ…
CamÃ©ra dÃ©placÃ©e chaque frame âœ…

# Bloc 8 â€” Partie 5 â€” CamÃ©ra FPS complÃ¨te (Yaw, Pitch, Matrices 3D)
ğŸ“š Objectif immÃ©diat
Tu vas :

Permettre de contrÃ´ler la camÃ©ra avec la souris (orientation libre),

GÃ©nÃ©rer la vraie vue 3D via une matrice de vue (View Matrix),

Fusionner le tout pour un dÃ©placement fluide et naturel.

ğŸ“‹ Concepts essentiels ici

Terme Description
Yaw Rotation horizontale (gauche/droite)
Pitch Rotation verticale (haut/bas)
View Matrix Transforme la scÃ¨ne par rapport Ã  la camÃ©ra
LookAt Fonction spÃ©ciale qui construit la vue
ğŸ“š Comment Ã§a marche concrÃ¨tement

Action ConsÃ©quence
DÃ©placer la souris Ã  droite La camÃ©ra tourne Ã  droite
DÃ©placer la souris en haut La camÃ©ra regarde vers le haut
Matrice vue Calcule les bonnes transformations automatiquement
ğŸ“‹ Mise Ã  jour de camera.h
c
Copier
Modifier
# ifndef CAMERA_H
# define CAMERA_H

typedef struct s_camera
{
 float pos_x, pos_y, pos_z;
 float front_x, front_y, front_z;
 float up_x, up_y, up_z;
 float yaw, pitch;
 float speed;
 float sensitivity;
} t_camera;

```c
void init_camera(t_camera *camera);
void process_keyboard(t_camera *camera, int key);
void process_mouse(t_camera *camera, float xoffset, float yoffset);
void get_view_matrix(t_camera *camera, float *view);

```
# endif
ğŸ“š Dans camera.c
ğŸ“‹ Initialisation complÃ¨te
c
Copier
Modifier
void init_camera(t_camera *camera)
{
 camera->pos_x = 0.0f;
 camera->pos_y = 0.0f;
 camera->pos_z = 3.0f;
 camera->front_x = 0.0f;
 camera->front_y = 0.0f;
 camera->front_z = -1.0f;
 camera->up_x = 0.0f;
 camera->up_y = 1.0f;
 camera->up_z = 0.0f;
 camera->yaw = -90.0f;
 camera->pitch = 0.0f;
 camera->speed = 0.05f;
 camera->sensitivity = 0.1f;
}
ğŸ“‹ Gestion du clavier
(DÃ©jÃ  fait partie 4, Ã  amÃ©liorer ensuite si besoin)

ğŸ“‹ Gestion de la souris
c
Copier
Modifier
```c
# include <math.h>

```
void process_mouse(t_camera *camera, float xoffset, float yoffset)
{
 xoffset *= camera->sensitivity;
 yoffset *= camera->sensitivity;

 camera->yaw += xoffset;
 camera->pitch += yoffset;

```c
 // Limiter le pitch pour Ã©viter de retourner
 if (camera->pitch > 89.0f)
 camera->pitch = 89.0f;
 if (camera->pitch < -89.0f)
 camera->pitch = -89.0f;

```
c
 // Calculer la nouvelle direction
 camera->front_x = cosf(camera->yaw * (3.14159f/180.0f)) * cosf(camera->pitch * (3.14159f/180.0f));
 camera->front_y = sinf(camera->pitch * (3.14159f/180.0f));
 camera->front_z = sinf(camera->yaw * (3.14159f/180.0f)) * cosf(camera->pitch * (3.14159f/180.0f));
}
ğŸ“‹ Calcul de la View Matrix (sans GLM)
c
Copier
Modifier
void get_view_matrix(t_camera *camera, float *view)
{
 // (Construction d'une matrice LookAt simplifiÃ©e)
 // Ã€ coder en dÃ©tail dans Partie 6 pour la rendre propre !

```
c
 // Ici pour l'instant â” on mettra un appel "dummy" pour se prÃ©parer
}
ğŸ“š Dans main.c
ğŸ“‹ Ajout du callback souris
Avant la boucle principale :

```
c
Copier
Modifier
glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
(Cache et capture la souris dans la fenÃªtre.)

DÃ©finir un callback :

c
Copier
Modifier
void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{
 static float lastX = WIDTH / 2.0f;
 static float lastY = HEIGHT / 2.0f;
```c
 static int firstMouse = 1;
 float xoffset, yoffset;

```
 if (firstMouse)
 {
 lastX = xpos;
 lastY = ypos;
 firstMouse = 0;
 }

 xoffset = xpos - lastX;
 yoffset = lastY - ypos; // inversÃ© car coordonnÃ©e Ã©cran diffÃ©rente

 lastX = xpos;
 lastY = ypos;

 process_mouse(&camera, xoffset, yoffset);
}
L'enregistrer :

c
Copier
Modifier
glfwSetCursorPosCallback(window, mouse_callback);
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
Bouger souris droite/gauche Tourner camÃ©ra horizontalement
Bouger souris haut/bas Monter/descendre vue
DÃ©placer avec W/A/S/D Se dÃ©placer librement dans la scÃ¨ne
ğŸ¯ Mini plan d'action Partie 5
Ajouter process_mouse() pour yaw/pitch,

Capturer mouvement souris,

Mettre Ã  jour front direction camÃ©ra,

Bouger librement dans la scÃ¨ne 3D.

ğŸ“‹ TDD minimal Bloc 8 Partie 5

Test Ce qui doit fonctionner
Bouger la souris Tourner la vue
DÃ©placer avec W/A/S/D Se dÃ©placer tout en conservant la vue
Aucune inversion bizarre âœ…
Fluide et naturel âœ…

# Bloc 8 â€” Partie 6 â€” View Matrix (LookAt) + Perspective Projection
ğŸ“š Objectif immÃ©diat
Tu vas :

GÃ©nÃ©rer une View Matrix correcte basÃ©e sur ta position camÃ©ra,

GÃ©nÃ©rer une Projection Matrix perspective (champ de vision rÃ©aliste),

Envoyer ces matrices aux shaders pour afficher ta scÃ¨ne 3D proprement.

ğŸ“‹ Concepts essentiels ici

Terme Description
View Matrix "OÃ¹ est la camÃ©ra et oÃ¹ regarde-t-elle ?"
Projection Matrix "Comment voir en 3D sur un Ã©cran 2D (perspective)"
Uniforms Variables globales envoyÃ©es aux shaders depuis ton programme C
ğŸ“š Comment Ã§a marche visuellement
mathematica
Copier
Modifier
World Space (3D) --> [View Matrix] --> Camera Space (relative) --> [Projection Matrix] --> Screen Space (2D)
ğŸ“‹ 1. Construire la View Matrix (LookAt)
Nous allons crÃ©er notre propre fonction lookAt().

ğŸ“‹ ImplÃ©mentation dans camera.c
c
Copier
Modifier
```c
# include <math.h>

```
void normalize(float *x, float *y, float *z)
{
 float length = sqrtf(*x * *x + *y * *y + *z * *z);
 if (length != 0)
 {
 *x /= length;
 *y /= length;
 *z /= length;
 }
}

void cross(float ax, float ay, float az, float bx, float by, float bz, float *rx, float *ry, float *rz)
{
 *rx = ay * bz - az * by;
 *ry = az * bx - ax * bz;
 *rz = ax * by - ay * bx;
}

void get_view_matrix(t_camera *camera, float *view)
{
 float center_x = camera->pos_x + camera->front_x;
 float center_y = camera->pos_y + camera->front_y;
 float center_z = camera->pos_z + camera->front_z;

 float f_x = center_x - camera->pos_x;
 float f_y = center_y - camera->pos_y;
 float f_z = center_z - camera->pos_z;
 normalize(&f_x, &f_y, &f_z);

 float s_x, s_y, s_z;
 cross(f_x, f_y, f_z, camera->up_x, camera->up_y, camera->up_z, &s_x, &s_y, &s_z);
 normalize(&s_x, &s_y, &s_z);

 float u_x, u_y, u_z;
 cross(s_x, s_y, s_z, f_x, f_y, f_z, &u_x, &u_y, &u_z);

```c
 // Matrice LookAt
 view[0] = s_x;
 view[1] = u_x;
 view[2] = -f_x;
 view[3] = 0.0f;

```
 view[4] = s_y;
 view[5] = u_y;
 view[6] = -f_y;
 view[7] = 0.0f;

 view[8] = s_z;
 view[9] = u_z;
 view[10] = -f_z;
 view[11] = 0.0f;

 view[12] = -(s_x * camera->pos_x + s_y * camera->pos_y + s_z * camera->pos_z);
 view[13] = -(u_x * camera->pos_x + u_y * camera->pos_y + u_z * camera->pos_z);
 view[14] = f_x * camera->pos_x + f_y * camera->pos_y + f_z * camera->pos_z;
 view[15] = 1.0f;
}
ğŸ“‹ 2. CrÃ©er la Projection Matrix
â” Perspective standard :

c
Copier
Modifier
void get_projection_matrix(float *projection, float fov, float aspect, float near, float far)
{
 float tan_half_fov = tanf(fov / 2.0f);

 projection[0] = 1.0f / (aspect * tan_half_fov);
 projection[1] = 0.0f;
 projection[2] = 0.0f;
 projection[3] = 0.0f;

 projection[4] = 0.0f;
 projection[5] = 1.0f / tan_half_fov;
 projection[6] = 0.0f;
 projection[7] = 0.0f;

 projection[8] = 0.0f;
 projection[9] = 0.0f;
 projection[10] = -(far + near) / (far - near);
 projection[11] = -1.0f;

 projection[12] = 0.0f;
 projection[13] = 0.0f;
 projection[14] = -(2.0f * far * near) / (far - near);
 projection[15] = 0.0f;
}
ğŸ“š Et dans main.c
ğŸ“‹ Envoyer les matrices aux shaders
Dans ta boucle principale (Ã  chaque frame) :

c
Copier
Modifier
float view[16];
float projection[16];

get_view_matrix(&camera, view);
get_projection_matrix(projection, 45.0f * (3.14159f/180.0f), (float)WIDTH/(float)HEIGHT, 0.1f, 100.0f);

```c
// Maintenant tu dois envoyer view[] et projection[] aux shaders
ğŸ“‹ Ajout dans les shaders
ğŸ“‹ Vertex shader amÃ©liorÃ©
glsl
Copier
Modifier
# version 330 core
layout (location = 0) in vec3 aPos;

```
uniform mat4 view;
uniform mat4 projection;

void main()
{
 gl_Position = projection * view * vec4(aPos, 1.0);
}
ğŸ“š Envoi cÃ´tÃ© C (OpenGL)
AprÃ¨s glUseProgram(shaderProgram) :

c
Copier
Modifier
```c
int viewLoc = glGetUniformLocation(shaderProgram, "view");
int projLoc = glGetUniformLocation(shaderProgram, "projection");

```
glUniformMatrix4fv(viewLoc, 1, GL_FALSE, view);
glUniformMatrix4fv(projLoc, 1, GL_FALSE, projection);
ğŸ“‹ RÃ©sultat attendu

Action Effet
DÃ©placer camÃ©ra La vue change en 3D naturellement
Bouger souris Tourner le regard dans toutes les directions
Perspective rÃ©aliste âœ…
ğŸ¯ Mini plan d'action Partie 6
Coder get_view_matrix() et get_projection_matrix(),

Ajouter uniforms dans shaders,

Envoyer view et projection matrices Ã  chaque frame,

Tester en volant dans ta scÃ¨ne !

ğŸ“‹ TDD minimal Bloc 8 Partie 6

Test Ce qui doit fonctionner
DÃ©placement avec profondeur visible âœ…
Rotation camÃ©ra fluide âœ…
Effet de perspective correct âœ…
Aucun artefact graphique âœ…

# Bloc 8 â€” Partie 7 â€” Ajouter un Ã©clairage simple (Phong Lighting)
ğŸ“š Objectif immÃ©diat
Tu vas :

Simuler la lumiÃ¨re sur tes modÃ¨les,

Calculer des ombres douces et brillances,

Utiliser les normales pour rendre ta scÃ¨ne rÃ©aliste.

ğŸ“‹ Concepts essentiels ici

Terme Description
Normale Vecteur perpendiculaire Ã  une surface, utilisÃ© pour l'Ã©clairage
Phong Lighting ModÃ¨le qui combine: Ambient + Diffuse + Specular light
Shader Lighting Tous les calculs de lumiÃ¨re sont faits dans le vertex shader ou fragment shader
ğŸ“š Rappel du modÃ¨le Phong

Terme Effet
Ambient LumiÃ¨re de base qui vient de partout
Diffuse LumiÃ¨re directe sur une surface orientÃ©e vers la source
Specular Reflet brillant selon la position de l'observateur
ğŸ“‹ 1. Ã‰tendre les Vertex pour contenir des normales
ğŸ“‹ Nouveau tableau vertex
Chaque sommet aura :

3 coordonnÃ©es (x, y, z),

3 normales (nx, ny, nz).

Exemple :

c
Copier
Modifier
float vertices[] = {
```c
 // positions // normales
 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f,
 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f,
 0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f
};
(normales pointant vers l'avant Z+ pour un triangle plat)

```
ğŸ“‹ Mise Ã  jour VAO/VBO
Dans main.c :

c
Copier
Modifier
```c
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

```
c
// DeuxiÃ¨me attribut: normales
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);
ğŸ“‹ 2. Modifier tes Shaders
ğŸ“‹ Vertex Shader (basic.vert)
glsl
Copier
Modifier
# version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

```
out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
 FragPos = vec3(model * vec4(aPos, 1.0));
 Normal = mat3(transpose(inverse(model))) * aNormal; // transformation normale
 gl_Position = projection * view * vec4(FragPos, 1.0);
}
ğŸ“‹ Fragment Shader (basic.frag)
glsl
Copier
Modifier
# version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
```c
 // Ambient
 float ambientStrength = 0.1;
 vec3 ambient = ambientStrength * lightColor;

```
c
 // Diffuse
 vec3 norm = normalize(Normal);
 vec3 lightDir = normalize(lightPos - FragPos);
 float diff = max(dot(norm, lightDir), 0.0);
 vec3 diffuse = diff * lightColor;

```
c
 // Specular
 float specularStrength = 0.5;
 vec3 viewDir = normalize(viewPos - FragPos);
 vec3 reflectDir = reflect(-lightDir, norm);
 float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
 vec3 specular = specularStrength * spec * lightColor;

```
 vec3 result = (ambient + diffuse + specular) * objectColor;
 FragColor = vec4(result, 1.0);
}
ğŸ“š CÃ´tÃ© C - envoyer les uniformes
Avant de dessiner chaque frame :

c
Copier
Modifier
```c
// Position de la lumiÃ¨re et de la camÃ©ra
int lightPosLoc = glGetUniformLocation(shaderProgram, "lightPos");
int viewPosLoc = glGetUniformLocation(shaderProgram, "viewPos");
int lightColorLoc = glGetUniformLocation(shaderProgram, "lightColor");
int objectColorLoc = glGetUniformLocation(shaderProgram, "objectColor");

```
glUniform3f(lightPosLoc, 1.2f, 1.0f, 2.0f);
glUniform3f(viewPosLoc, camera.pos_x, camera.pos_y, camera.pos_z);
glUniform3f(lightColorLoc, 1.0f, 1.0f, 1.0f); // lumiÃ¨re blanche
glUniform3f(objectColorLoc, 0.6f, 0.6f, 0.8f); // objet bleu/gris
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
Un triangle illuminÃ© âœ…
Plus lumineux quand il fait face Ã  la lumiÃ¨re âœ…
RÃ©flexion spÃ©culaire si angle correct âœ…
Ombre douce sur les cÃ´tÃ©s âœ…
ğŸ¯ Mini plan d'action Partie 7
Modifier vertices[] pour contenir des normales,

Modifier VAO/VBO pour lire position + normale,

Changer shaders pour utiliser Phong Lighting,

Envoyer toutes les nouvelles uniforms.

ğŸ“‹ TDD minimal Bloc 8 Partie 7

Test Ce qui doit marcher
Triangle Ã©clairÃ© avec nuances rÃ©alistes âœ…
DÃ©placement camÃ©ra change la lumiÃ¨re perÃ§ue âœ…
Rotation lumiÃ¨re â†’ ombres diffÃ©rentes âœ…
Brillance visible sur bons angles âœ…

# Bloc 8 â€” Partie 8 â€” Textures sur les modÃ¨les 3D (JPG/PNG)
ğŸ“š Objectif immÃ©diat
Tu vas :

Charger une image (JPG ou PNG),

L'envoyer Ã  la carte graphique comme texture,

Mapper correctement cette texture sur tes modÃ¨les 3D.

ğŸ“‹ Concepts essentiels ici

Terme Description
UV Mapping Chaque vertex reÃ§oit des coordonnÃ©es 2D (u,v) pour mapper la texture
Texture Unit Emplacement mÃ©moire pour lier une image sur GPU
Sampler2D Type spÃ©cial dans les shaders pour accÃ©der aux textures
ğŸ“š Comment Ã§a fonctionne

Ã‰tape Description
Charger une image Obtenir un tableau de pixels
CrÃ©er une texture OpenGL TransfÃ©rer l'image sur la carte graphique
Ajouter coordonnÃ©es UV aux vertex Dire Ã  OpenGL comment appliquer l'image
Utiliser un sampler2D dans le fragment shader Lire la couleur correspondante pour chaque pixel
ğŸ“‹ 1. Ajouter des coordonnÃ©es UV aux vertex
ğŸ“‹ Nouveau tableau de vertex
Chaque sommet aura :

3 positions (x, y, z),

3 normales (nx, ny, nz),

2 UVs (u, v).

Exemple :

c
Copier
Modifier
float vertices[] = {
```c
 // pos // normal // texcoords
 0.5f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, // top right
 0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, // bottom right
 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom left
 -0.5f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f // top left 
};
unsigned int indices[] = { 0, 1, 3, 1, 2, 3 };
(Cette fois, 4 vertices et 2 triangles pour former un carrÃ©.)

```
ğŸ“‹ Mise Ã  jour VAO/VBO
c
Copier
Modifier
```c
// pos
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

```
c
// normal
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);

```
c
// texcoords
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
glEnableVertexAttribArray(2);
ğŸ“‹ 2. Charger l'image en C
Utiliser la lib simple stb_image.h (gratuite et lÃ©gÃ¨re).

```
ğŸ“‹ Ajouter stb_image.h
TÃ©lÃ©charger stb_image.h :
https://raw.githubusercontent.com/nothings/stb/master/stb_image.h

Dans un fichier .c :

c
Copier
Modifier
# define STB_IMAGE_IMPLEMENTATION
```c
# include "stb_image.h"
ğŸ“‹ CrÃ©er une texture OpenGL
c
Copier
Modifier
unsigned int texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);

```
c
// ParamÃ¨tres de texture
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

```
c
// Charger l'image
int width, height, nrChannels;
unsigned char *data = stbi_load("textures/mon_image.jpg", &width, &height, &nrChannels, 0);
if (data)
{
 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
 glGenerateMipmap(GL_TEXTURE_2D);
}
else
{
 printf("âŒ Erreur chargement texture\n");
}
stbi_image_free(data);
ğŸ“‹ 3. Modifier tes shaders
ğŸ“‹ Vertex Shader (ajouter TexCoords)
glsl
Copier
Modifier
layout (location = 2) in vec2 aTexCoords;

```
out vec2 TexCoords;

void main()
{
 TexCoords = aTexCoords;
 gl_Position = projection * view * vec4(aPos, 1.0);
}
ğŸ“‹ Fragment Shader (utiliser sampler2D)
glsl
Copier
Modifier
in vec2 TexCoords;

uniform sampler2D texture1;

void main()
{
 vec3 texColor = texture(texture1, TexCoords).rgb;
 FragColor = vec4(texColor, 1.0);
}
ğŸ“‹ 4. CÃ´tÃ© C - Activer la texture
Avant de dessiner :

c
Copier
Modifier
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture);

```c
// Puis utiliser le shader
glUseProgram(shaderProgram);
glUniform1i(glGetUniformLocation(shaderProgram, "texture1"), 0);
ğŸ“‹ RÃ©sultat attendu

```
Action RÃ©sultat
FenÃªtre s'ouvre âœ…
Un carrÃ© affichant l'image comme texture âœ…
DÃ©placement et rotation possibles âœ…
ğŸ¯ Mini plan d'action Partie 8
Modifier tes vertex pour contenir UV,

Charger une texture avec stb_image.h,

Lier la texture dans OpenGL,

Modifier shaders pour afficher textures,

Tester en dÃ©plaÃ§ant camÃ©ra.

ğŸ“‹ TDD minimal Bloc 8 Partie 8

Test Ce qui doit marcher
Texture chargÃ©e correctement âœ…
Texture visible sur le modÃ¨le âœ…
DÃ©placement camÃ©ra montre la texture sous diffÃ©rents angles âœ…
Aucun crash mÃªme si image manquante âœ…

# Bloc 8 â€” Partie 9 â€” CrÃ©er une Skybox 3D
ğŸ“š Objectif immÃ©diat
Tu vas :

CrÃ©er une Skybox (un "cube gÃ©ant" texturÃ© autour de ton monde),

Donner l'impression d'un univers immense,

Utiliser une cubemap (6 images pour le ciel).

ğŸ“‹ Concepts essentiels ici

Terme Description
Skybox Un cube immense avec une image de ciel sur chaque face
Cubemap Texture spÃ©ciale composÃ©e de 6 faces pour le cube
Projections La Skybox est dessinÃ©e sans translation (elle suit la camÃ©ra sans dÃ©placement)
ğŸ“š Comment fonctionne une Skybox

Action Ce qui se passe
Dessiner un cube autour de la camÃ©ra âœ…
Appliquer une cubemap comme texture âœ…
DÃ©sactiver translation dans la view matrix âœ…
Toujours dessiner la Skybox en premier âœ…
ğŸ“‹ 1. CrÃ©er ton modÃ¨le de Skybox (Cube)
ğŸ“‹ Vertices pour un cube
c
Copier
Modifier
float skyboxVertices[] = {
```c
 // positions 
 -1.0f, 1.0f, -1.0f,
 -1.0f, -1.0f, -1.0f,
 1.0f, -1.0f, -1.0f,
 1.0f, -1.0f, -1.0f,
 1.0f, 1.0f, -1.0f,
 -1.0f, 1.0f, -1.0f,

```
 -1.0f, -1.0f, 1.0f,
 -1.0f, -1.0f, -1.0f,
 -1.0f, 1.0f, -1.0f,
 -1.0f, 1.0f, -1.0f,
 -1.0f, 1.0f, 1.0f,
 -1.0f, -1.0f, 1.0f,

 1.0f, -1.0f, -1.0f,
 1.0f, -1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, -1.0f,
 1.0f, -1.0f, -1.0f,

 -1.0f, -1.0f, 1.0f,
 -1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, -1.0f, 1.0f,
 -1.0f, -1.0f, 1.0f,

 -1.0f, 1.0f, -1.0f,
 1.0f, 1.0f, -1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 -1.0f, 1.0f, 1.0f,
 -1.0f, 1.0f, -1.0f,

 -1.0f, -1.0f, -1.0f,
 -1.0f, -1.0f, 1.0f,
 1.0f, -1.0f, -1.0f,
 1.0f, -1.0f, -1.0f,
 -1.0f, -1.0f, 1.0f,
 1.0f, -1.0f, 1.0f
};
ğŸ“‹ 2. Charger une Cubemap
ğŸ“‹ CrÃ©er une Cubemap OpenGL
c
Copier
Modifier
```c
unsigned int cubemapTexture;
glGenTextures(1, &cubemapTexture);
glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);

```
c
int width, height, nrChannels;
unsigned char *data;
char *faces[6] = {
 "skybox/right.jpg",
 "skybox/left.jpg",
 "skybox/top.jpg",
 "skybox/bottom.jpg",
 "skybox/front.jpg",
 "skybox/back.jpg"
};

```
c
for (unsigned int i = 0; i < 6; i++)
{
 data = stbi_load(faces[i], &width, &height, &nrChannels, 0);
 if (data)
 {
 glTexImage2D(
 GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 
 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data
 );
 stbi_image_free(data);
 }
 else
 {
 printf("âŒ Erreur chargement skybox: %s\n", faces[i]);
 stbi_image_free(data);
 }
}

```
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
ğŸ“‹ 3. Shader pour Skybox
ğŸ“‹ Vertex Shader (skybox.vert)
glsl
Copier
Modifier
# version 330 core
layout (location = 0) in vec3 aPos;

out vec3 TexCoords;

uniform mat4 view;
uniform mat4 projection;

void main()
{
 TexCoords = aPos;
 vec4 pos = projection * view * vec4(aPos, 1.0);
 gl_Position = pos.xyww;
}
ğŸ“‹ Fragment Shader (skybox.frag)
glsl
Copier
Modifier
# version 330 core
out vec4 FragColor;

in vec3 TexCoords;

uniform samplerCube skybox;

void main()
{
 FragColor = texture(skybox, TexCoords);
}
ğŸ“‹ 4. Affichage spÃ©cial pour la Skybox
Changer ta View Matrix pour enlever la position camÃ©ra: â” utiliser seulement la rotation.

c
Copier
Modifier
mat4 view = mat4(mat3(viewMatrix)); // Supprimer la translation
DÃ©sactiver le depth writing temporairement avant de dessiner la Skybox :

c
Copier
Modifier
glDepthFunc(GL_LEQUAL);
drawSkybox();
glDepthFunc(GL_LESS);
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
FenÃªtre s'ouvre âœ…
Ciel visible tout autour âœ…
Tourner la camÃ©ra Le ciel bouge naturellement
DÃ©placer la camÃ©ra Le ciel reste Ã  la mÃªme distance (infini)
ğŸ¯ Mini plan d'action Partie 9
CrÃ©er VAO/VBO pour cube skybox,

Charger 6 faces cubemap,

Modifier viewMatrix pour Skybox,

Dessiner Skybox avant tout autre Ã©lÃ©ment.

ğŸ“‹ TDD minimal Bloc 8 Partie 9

Test Ce qui doit fonctionner
Skybox visible au dÃ©marrage âœ…
Pas d'artefacts visuels âœ…
Rotation camÃ©ra fluide sur ciel âœ…
DÃ©placement camÃ©ra ne change pas la Skybox âœ…

# Bloc 8 â€” Finalisation du moteur 3D
ğŸ“š RÃ©sumÃ© rapide de ce que tu sais dÃ©sormais faire

Module Ce que tu maÃ®trises
OpenGL setup CrÃ©er et gÃ©rer des fenÃªtres OpenGL en C
Affichage 3D Dessiner des modÃ¨les (triangles, objets)
ContrÃ´le camÃ©ra Clavier + souris pour vue libre FPS
Shaders CrÃ©er vertex et fragment shaders modernes
Lighting ImplÃ©menter un Ã©clairage Phong complet
Textures Charger et afficher des images sur des modÃ¨les
Skybox Entourer ta scÃ¨ne d'un univers infini avec cubemap
ğŸ“‹ Structure de projet final
Voici comment ton moteur 3D est proprement structurÃ© :

plaintext
Copier
Modifier
mini_3d_engine/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c # Boucle principale
â”‚ â”œâ”€â”€ window.c / .h # FenÃªtre GLFW
â”‚ â”œâ”€â”€ shader.c / .h # Shaders (load, compile, use)
â”‚ â”œâ”€â”€ camera.c / .h # Gestion de la camÃ©ra
â”‚ â”œâ”€â”€ model.c / .h # Chargement des modÃ¨les (.obj simplifiÃ©)
â”‚ â”œâ”€â”€ skybox.c / .h # Chargement + affichage de Skybox
â”‚ â”œâ”€â”€ texture.c / .h # Gestion des textures
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ Tous les .h
â”œâ”€â”€ shaders/
â”‚ â”œâ”€â”€ basic.vert
â”‚ â”œâ”€â”€ basic.frag
â”‚ â”œâ”€â”€ skybox.vert
â”‚ â”œâ”€â”€ skybox.frag
â”œâ”€â”€ textures/
â”‚ â”œâ”€â”€ images (.jpg / .png)
â”‚ â”œâ”€â”€ skybox faces
â”œâ”€â”€ Makefile
â”œâ”€â”€ README.md (explication du projet)
ğŸ“‹ To-do pour un projet prÃªt Ã  livrer

Ã€ faire Explication
Makefile ultra propre Avec targets all, clean, fclean, re
README.md clair Expliquer installation + commandes principales
Arborescence fichiers clean src/, shaders/, textures/, include/
Rendu stable Pas de crash mÃªme si ressource manquante
Norme C (si applicable) Bonus pour style professionnel
ğŸ¯ Mini bilan final
âœ… Tu as recrÃ©Ã© manuellement tout ce qu'un moteur de base propose :

OpenGL core,

Gestion camera FPS,

Lighting Phong,

Skybox environnement,

Chargement d'objets + textures.

C'est Ã  80% de ce qu'un moteur minimal commercial style "Godot Engine Core" pourrait reprÃ©senter !

ğŸ† En bonus tu peux ajouter aprÃ¨s :

IdÃ©e bonus ComplexitÃ©
Charger des modÃ¨les .obj complexes avec textures UV complÃ¨tes ğŸ§ ğŸ§ 
GÃ©rer l'animation (skeletal / bones) ğŸ§ ğŸ§ ğŸ§ 
Optimiser en utilisant VBO/VAO/UBO avancÃ©s ğŸ§ ğŸ§ 
Ajout d'un vrai systÃ¨me de collisions ğŸ§ ğŸ§ 
Shadow mapping (ombres dynamiques) ğŸ§ ğŸ§ ğŸ§ 

ğŸ§© Module 14 â€” threads/ â€” Programmation multithreadÃ©e avec pthread [ğŸ§µ Niveau AvancÃ©]
ğŸ“¦ Module threads/ â€” Multithreading, synchronisation, et gestion de la concurrence en C
ğŸ¯ Objectif pÃ©dagogique
Ce module tâ€™apprend Ã  Ã©crire des programmes concurrents et synchronisÃ©s, grÃ¢ce Ã  la bibliothÃ¨que POSIX pthread. Tu vas apprendre Ã  :

CrÃ©er et gÃ©rer des threads

Synchroniser leur accÃ¨s avec des mutex, sÃ©maphores, barriÃ¨res

Identifier et rÃ©soudre les race conditions

ImplÃ©menter des workers, des pipelines, ou des problÃ¨mes classiques (producteurs/consommateurs, lecteurs/Ã©crivains)

ğŸ“š Concepts abordÃ©s
âœ… 1. pthread_create, pthread_join
c
Copier
Modifier
pthread_t tid;
pthread_create(&tid, NULL, my_function, arg);
pthread_join(tid, NULL);
â†’ Lance un thread qui exÃ©cute une fonction en parallÃ¨le.

âœ… 2. Variables partagÃ©es et problÃ¨mes de concurrence
c
Copier
Modifier
int global = 0;
void *f(void *arg) { global++; }
â†’ Plusieurs threads modifiant global â†’ comportement indÃ©fini, race condition.

âœ… 3. Mutex (pthread_mutex_t)
c
Copier
Modifier
pthread_mutex_lock(&m);
global++;
pthread_mutex_unlock(&m);
â†’ ProtÃ¨ge les sections critiques.

âœ… 4. SÃ©maphores (sem_t)
c
Copier
Modifier
sem_wait(&sem);
critical_section();
sem_post(&sem);
â†’ Limite lâ€™accÃ¨s Ã  une ressource partagÃ©e Ã  N threads.

âœ… 5. Autres outils
pthread_detach() : laisse un thread sâ€™auto-libÃ©rer

pthread_cond_t : conditionnelles

BarriÃ¨res (pthread_barrier_t) : synchroniser plusieurs threads Ã  un point donnÃ©

ğŸ§ª Exercices
ğŸ“‚ threads/ex00 â€” CrÃ©er 3 threads et les faire travailler
CrÃ©er 3 threads qui affichent un message en parallÃ¨le. Utiliser pthread_create et pthread_join.

ğŸ“‚ threads/ex01 â€” IncrÃ©mentation concurrente
IncrÃ©menter une variable globale depuis 100 threads.
Sans mutex â†’ observer le rÃ©sultat incorrect.

ğŸ“‚ threads/ex02 â€” Corriger avec mutex
Ajouter un pthread_mutex_t pour rendre lâ€™incrÃ©mentation sÃ»re.

ğŸ“‚ threads/ex03 â€” ProblÃ¨me producteur / consommateur
ImplÃ©menter un buffer partagÃ© avec un producteur et un consommateur, synchronisÃ©s via mutex et conditionnelle.

ğŸ“‚ threads/ex04 â€” ExÃ©cution en tÃ¢che de fond (detach)
CrÃ©er un thread dÃ©tachÃ© qui affiche une animation, pendant que le programme principal continue.

ğŸ› ï¸ Bonus
RÃ©aliser une file de tÃ¢ches (worker pool)

ImplÃ©menter un serveur multi-threads

CrÃ©er un compteur de mots multi-threadÃ© sur gros fichier texte

ğŸ§© Module 15 â€” realtime/ â€” Simulation de systÃ¨mes temps rÃ©el et rÃ©actifs [â±ï¸ Niveau AvancÃ©]
ğŸ“¦ Module realtime/ â€” RÃ©agir en temps rÃ©el, simuler des systÃ¨mes vivants ou synchrones
ğŸ¯ Objectif pÃ©dagogique
Ce module tâ€™apprend Ã  crÃ©er des systÃ¨mes qui rÃ©agissent au temps ou Ã  des Ã©vÃ©nements, en simulant le comportement temps rÃ©el dâ€™un processus, dâ€™un systÃ¨me embarquÃ© ou dâ€™un moteur logique. Tu vas :

MaÃ®triser les dÃ©lais, les rafraÃ®chissements cadencÃ©s, la synchronisation au temps systÃ¨me

ImplÃ©menter des Ã©tats Ã©volutifs et des rÃ©actions conditionnelles

Ã‰crire des systÃ¨mes interactifs simples (ex: feux de circulation, moteurs, senseurs)

ğŸ“š Concepts abordÃ©s
âœ… 1. Boucle temps rÃ©el / boucle de simulation
c
Copier
Modifier
while (1) {
    update_state();
    render();
    usleep(100000); // pause 100 ms = 10 FPS
}
â†’ Boucle avec rythme fixe, appelÃ©e toutes les X ms.

âœ… 2. gettimeofday, clock_gettime, time.h
Obtenir un timestamp (time(NULL))

Calculer un delta de temps

Attendre jusquâ€™Ã  atteindre un instant donnÃ©

âœ… 3. Ã‰vÃ©nements temporels
DÃ©clencher une action si une durÃ©e est dÃ©passÃ©e :

c
Copier
Modifier
if (current_time - start_time > 5.0) {
    activate();
}
âœ… 4. Ã‰tats dynamiques
CrÃ©er des automates Ã  Ã©tats finis (FSM) ou des timers logiques (ex : feux tricolores).

ğŸ§ª Exercices
ğŸ“‚ realtime/ex00 â€” ChronomÃ¨tre basique
Afficher un compteur de secondes en temps rÃ©el.

ğŸ“‚ realtime/ex01 â€” Clignotement
Faire clignoter une LED (ASCII) toutes les 500 ms.

css
Copier
Modifier
[ ON ]
[OFF ]
ğŸ“‚ realtime/ex02 â€” Feu de circulation
Simuler un feu avec Ã©tats VERT -> ORANGE -> ROUGE, chacun durant un temps prÃ©cis.

ğŸ“‚ realtime/ex03 â€” DÃ©tecteur de seuil
Simuler un capteur : quand une variable dÃ©passe un seuil pendant X secondes, dÃ©clencher une alerte.

ğŸ“‚ realtime/ex04 â€” Animation cadencÃ©e
CrÃ©er une boucle qui anime un ASCII art image par image Ã  10 FPS.

ğŸ› ï¸ Bonus
CrÃ©er une alarme programmable

Simuler un automate industriel

IntÃ©grer la logique Ã  un DSL ou un moteur dâ€™agents




ğŸ§© Module 11 â€” standard_c_lib/ â€” RÃ©implÃ©menter les fonctions standards de la libc [ğŸ“š Niveau Moyen Ã  Expert]
ğŸ“¦ Module standard_c_lib/ â€” Mieux comprendre la libc en la recrÃ©ant soi-mÃªme
ğŸ¯ Objectif pÃ©dagogique
Ce module a pour but de dÃ©sacraliser la bibliothÃ¨que standard (libc) en te faisant rÃ©Ã©crire ses fonctions clÃ©s. Cela tâ€™amÃ¨ne Ã  :

Comprendre comment fonctionne la recherche, le tri, la tokenisation, etc.

Appliquer des concepts dâ€™algorithmes sur des cas concrets

DÃ©couvrir des comportements subtils de fonctions trÃ¨s utilisÃ©es

RÃ©duire ta dÃ©pendance aux bibliothÃ¨ques

ğŸ“š Concepts abordÃ©s
âœ… 1. qsort() â€” Tri gÃ©nÃ©rique
RÃ©implÃ©mentation dâ€™un tri Ã  comparaison, gÃ©nÃ©rique via void*, utilisant un pointeur vers fonction :

c
Copier
Modifier
void ft_qsort(void *base, size_t nmemb, size_t size,
              int (*compar)(const void *, const void *));
âœ… 2. bsearch() â€” Recherche binaire
c
Copier
Modifier
void *ft_bsearch(const void *key, const void *base,
                 size_t nmemb, size_t size,
                 int (*compar)(const void *, const void *));
âœ… 3. strtok() â€” DÃ©coupage dâ€™une chaÃ®ne
c
Copier
Modifier
char *ft_strtok(char *str, const char *delim);
GÃ¨re un pointeur statique pour avancer dans la chaÃ®ne.

âœ… 4. atoi() et itoa()
Conversion de chaÃ®ne vers entier (atoi), et entier vers chaÃ®ne (itoa).

âœ… 5. memset, memcpy, memcmp
Manipulation de blocs mÃ©moire bruts (void*).

ğŸ§ª Exercices
ğŸ“‚ standard_c_lib/ex00 â€” RÃ©Ã©crire ft_atoi()
GÃ©rer :

signes + / -

espaces

overflow minimal (INT_MAX, INT_MIN)

ğŸ“‚ standard_c_lib/ex01 â€” RÃ©Ã©crire ft_strtok()
CrÃ©er une version capable de dÃ©couper "a,b,c" avec "," comme sÃ©parateur.
âš ï¸ GÃ©rer le pointeur statique.

ğŸ“‚ standard_c_lib/ex02 â€” RÃ©Ã©crire ft_qsort()
Tri gÃ©nÃ©rique de nâ€™importe quel tableau (ex : int[], char*[]) avec une fonction de comparaison.

ğŸ“‚ standard_c_lib/ex03 â€” RÃ©Ã©crire ft_bsearch()
Recherche binaire dans un tableau triÃ©, gÃ©nÃ©rique avec void*.

ğŸ“‚ standard_c_lib/ex04 â€” memcpy / memset / memcmp
CrÃ©er trois fonctions de manipulation mÃ©moire bas-niveau.

ğŸ› ï¸ Bonus
Comparer performance ft_qsort vs qsort

RÃ©Ã©crire strchr, strrchr, strstr

ImplÃ©menter une mini-libc minimaliste embarquable




ğŸ§© Module 7 â€” archi_prog/ â€” Architecture mÃ©moire et compilation [ğŸ§  Niveau Fondamental / AvancÃ©]
ğŸ“¦ Module archi_prog/ â€” Comprendre lâ€™architecture mÃ©moire, la compilation et le linking [ğŸ§  Fondamental]
ğŸ¯ Objectif pÃ©dagogique
Ce module est essentiel pour maÃ®triser le cycle de vie complet dâ€™un programme C, depuis la source jusquâ€™Ã  lâ€™exÃ©cutable, en passant par les sections mÃ©moire et le linking. Tu vas apprendre Ã  :

Visualiser la mÃ©moire (pile, heap, bss, data, text)

Suivre le cycle de compilation : .c â†’ .o â†’ exÃ©cutable

Comprendre le rÃ´le du linker (Ã©dition de liens)

CrÃ©er et utiliser des librairies statiques (.a) et dynamiques (.so)

Manipuler et lire les mÃ©tadonnÃ©es dâ€™un binaire ELF

ğŸ“š Concepts abordÃ©s
âœ… 1. Sections mÃ©moire
Section Contenu
.text Code machine (fonctions compilÃ©es)
.data Variables globales initialisÃ©es
.bss  Variables globales non initialisÃ©es
heap  MÃ©moire dynamique (malloc)
stack Variables locales (pile)

ğŸ” Ã€ visualiser avec readelf -S ou objdump -h.

âœ… 2. Cycle de compilation
bash
Copier
Modifier
gcc -c prog.c     # compilation â†’ prog.o
gcc prog.o -o prog  # linking â†’ exÃ©cutable
ğŸ”§ Distinguer :

Compilation (analyse + gÃ©nÃ©ration assembleur)

Assemblage (assembleur â†’ binaire)

Linking (rassemble tous les objets)

âœ… 3. Librairies statiques .a
bash
Copier
Modifier
ar rcs libmymath.a add.o sub.o
gcc main.c -L. -lmymath
â†’ CopiÃ©e dans lâ€™exÃ©cutable au linking.

âœ… 4. Librairies dynamiques .so
bash
Copier
Modifier
gcc -fPIC -shared -o libmymath.so add.o sub.o
gcc main.c -L. -lmymath
export LD_LIBRARY_PATH=.
â†’ ChargÃ©e dynamiquement Ã  lâ€™exÃ©cution.

âœ… 5. Commandes utiles
nm prog : symboles

ldd prog : dÃ©pendances dynamiques

objdump -d prog : dÃ©sassemblage

readelf -h prog : en-tÃªte ELF

ğŸ§ª Exercices
ğŸ“‚ archi_prog/ex00 â€” Affichage des sections mÃ©moire
CrÃ©er un programme avec :

c
Copier
Modifier
int global = 42;
static int stat = 0;
char *heap = malloc(10);
int main(void) {
    int local = 1;
    static int mystatic = 5;
}
Utiliser nm ou objdump pour repÃ©rer .data, .bss, .heap, .stack.

ğŸ“‚ archi_prog/ex01 â€” Compilation manuelle
Compiler manuellement en plusieurs Ã©tapes :

bash
Copier
Modifier
gcc -c part1.c
gcc -c part2.c
gcc part1.o part2.o -o final
ğŸ“‚ archi_prog/ex02 â€” Librairie statique
CrÃ©er un mini .a avec une fonction ft_add(), lâ€™inclure dans un projet.

ğŸ“‚ archi_prog/ex03 â€” Librairie dynamique
CrÃ©er une .so partagÃ©e, puis exÃ©cuter un programme qui sâ€™y relie dynamiquement.

ğŸ“‚ archi_prog/ex04 â€” Analyse ELF
Compiler un programme simple et afficher :

les sections ELF

les symboles

les adresses de fonctions

ğŸ› ï¸ Bonus possible
DÃ©sassembler un programme avec objdump -d

CrÃ©er un loader ELF minimal

Lire la pile aprÃ¨s un crash (ulimit -c unlimited + gdb core)


ğŸ§© Module 12 â€” preprocessor/ â€” PrÃ©processeur C, macros et portabilitÃ© [ğŸ“ Niveau Moyen Ã  AvancÃ©]
ğŸ“¦ Module preprocessor/ â€” MaÃ®triser les directives du prÃ©processeur et les macros C
ğŸ¯ Objectif pÃ©dagogique
Ce module tâ€™initie Ã  un des mÃ©canismes fondamentaux du langage C, souvent mal compris : le prÃ©processeur. Tu vas :

MaÃ®triser les directives comme #define, #ifdef, #pragma, etc.

CrÃ©er des macros paramÃ©trÃ©es et sÃ»res

GÃ©rer la portabilitÃ© avec des macros conditionnelles

Comprendre comment le compilateur voit vraiment ton code

ğŸ“š Concepts abordÃ©s
âœ… 1. #define, #ifdef, #ifndef, #undef
c
Copier
Modifier
#define PI 3.1415
#ifdef DEBUG
    printf("Debug mode\n");
#endif
â†’ Permet de conditionner des morceaux de code Ã  la compilation.

âœ… 2. Macros avec paramÃ¨tres
c
Copier
Modifier
#define SQUARE(x) ((x)*(x))
âš ï¸ Attention aux doubles Ã©valuations : SQUARE(a++) â†’ produit 2 incrÃ©ments !

âœ… 3. __FILE__, __LINE__, __DATE__, __TIME__
c
Copier
Modifier
printf("Erreur dans %s Ã  la ligne %d\n", __FILE__, __LINE__);
â†’ Fournit des infos de debug compilÃ©es dans le binaire.

âœ… 4. #pragma, #error, #warning
c
Copier
Modifier
#pragma once
#error "Cette version du compilateur n'est pas supportÃ©e"
â†’ Influence le comportement du compilateur.

âœ… 5. Macros conditionnelles pour portabilitÃ©
c
Copier
Modifier
#ifdef _WIN32
    #define OS "Windows"
#elif __linux__
    #define OS "Linux"
#else
    #define OS "Inconnu"
#endif
â†’ Permet dâ€™adapter le code aux plateformes (cross-compilation).

âœ… 6. Inclusion sÃ©curisÃ©e : Include guards
c
Copier
Modifier
#ifndef MY_HEADER_H
#define MY_HEADER_H

// code

#endif
â†’ EmpÃªche les inclusions multiples.

ğŸ§ª Exercices
ğŸ“‚ preprocessor/ex00 â€” DÃ©finir une constante #define
CrÃ©er un programme qui utilise #define PI pour afficher la circonfÃ©rence dâ€™un cercle.

ğŸ“‚ preprocessor/ex01 â€” Macro SQUARE
CrÃ©er une macro SQUARE(x) et lâ€™utiliser sur plusieurs expressions. Ajouter un printf(__LINE__).

ğŸ“‚ preprocessor/ex02 â€” Inclusion conditionnelle
CrÃ©er un fichier os_name.h qui dÃ©finit une chaÃ®ne OS_NAME selon lâ€™OS dÃ©tectÃ© (_WIN32, __linux__, __APPLE__...).

ğŸ“‚ preprocessor/ex03 â€” Utiliser #pragma et #error
CrÃ©er un fichier qui affiche une erreur si __STDC__ nâ€™est pas dÃ©fini (non standard C).

ğŸ“‚ preprocessor/ex04 â€” Include guard propre
CrÃ©er un fichier .h avec un #ifndef et une macro dâ€™inclusion unique.

ğŸ› ï¸ Bonus
RÃ©aliser une mini-lib portable avec dÃ©tection automatique de lâ€™OS

CrÃ©er une macro de logging stylÃ©e LOG(msg) qui affiche le message, le fichier, et la ligne





ğŸ§© Module 8 â€” safety/ â€” Robustesse, sÃ©curitÃ© mÃ©moire, erreurs systÃ¨me [ğŸ›¡ï¸ Niveau Fondamental Ã  AvancÃ©]
ğŸ“¦ Module safety/ â€” SÃ©curiser un programme C et prÃ©venir les erreurs critiques [ğŸ›¡ï¸ SÃ©curitÃ© & Robustesse]
ğŸ¯ Objectif pÃ©dagogique
Ce module tâ€™apprend Ã  Ã©crire du code C robuste, sÃ©curisÃ© et prÃ©visible, en anticipant :

Les dÃ©passements de mÃ©moire (buffer overflow)

Les erreurs systÃ¨mes (errno, perror, strerror)

Les comportements indÃ©finis (segfault, dangling pointer, etc.)

Les protections mÃ©moire modernes (ASLR, stack canary, NX)

Câ€™est le fondement de toute programmation fiable, notamment en systÃ¨mes embarquÃ©s, en sÃ©curitÃ©, ou en rÃ©seau.

ğŸ“š Concepts abordÃ©s
âœ… 1. Buffer overflow
c
Copier
Modifier
char buffer[8];
strcpy(buffer, "Ceci est trop long"); // Overflow â†’ danger
â†’ Peut corrompre la pile, dÃ©tourner lâ€™exÃ©cution (ret2libc, etc.).

âœ… 2. Segfault et undefined behavior
c
Copier
Modifier
char *ptr = NULL;
*ptr = 'a';  // SEGFAULT
â†’ RÃ©sultat : crash du programme ou comportement imprÃ©visible.

âœ… 3. Gestion des erreurs systÃ¨me : errno, perror, strerror
c
Copier
Modifier
#include <errno.h>
#include <stdio.h>
#include <string.h>
open("inexistant.txt", O_RDONLY);
perror("Erreur"); // Affiche le message d'erreur associÃ©
âœ… 4. Stack canary (protection contre overflow)
ActivÃ© via :

bash
Copier
Modifier
gcc -fstack-protector-all
â†’ EmpÃªche lâ€™Ã©criture hors des variables locales de corrompre le retour dâ€™une fonction.

âœ… 5. ASLR (Address Space Layout Randomization)
Protection du systÃ¨me dâ€™exploitation :

Lâ€™adresse de la pile change Ã  chaque exÃ©cution

EmpÃªche les attaques prÃ©visibles basÃ©es sur les adresses

ğŸ” Ã€ tester via cat /proc/sys/kernel/randomize_va_space

ğŸ§ª Exercices
ğŸ“‚ safety/ex00 â€” DÃ©clencher un buffer overflow
Ã‰crire une fonction vulnÃ©rable (unsafe_copy()) et lâ€™appeler avec une chaÃ®ne trop longue.
Afficher le crash attendu ou le comportement anormal.

ğŸ“‚ safety/ex01 â€” Corriger avec strncpy
RÃ©Ã©crire la fonction prÃ©cÃ©dente avec strncpy() ou memcpy() + taille contrÃ´lÃ©e.

ğŸ“‚ safety/ex02 â€” Lire et interprÃ©ter errno
Forcer une erreur (open("foo.txt") sur fichier inexistant), afficher errno avec perror() et strerror(errno).

ğŸ“‚ safety/ex03 â€” Crash volontaire (NULL pointer)
CrÃ©er un programme qui provoque un segfault, puis lâ€™exÃ©cuter avec gdb pour afficher la backtrace.

ğŸ“‚ safety/ex04 â€” Compilation avec -fstack-protector
Compiler un programme vulnÃ©rable avec et sans -fstack-protector-all â†’ observer la diffÃ©rence (protection dÃ©tectÃ©e ou non).

ğŸ› ï¸ Bonus
Lire un core dump avec gdb core

Mesurer la robustesse avec valgrind ou AddressSanitizer

Comparer comportement avec ASLR activÃ©/dÃ©sactivÃ©

ğŸ§© Module 13 â€” dsl/ â€” CrÃ©er un langage interne (mini DSL) et son interprÃ©teur [ğŸ§¬ Niveau AvancÃ© / CrÃ©atif]
ğŸ“¦ Module dsl/ â€” CrÃ©er un langage simple (DSL) et l'interprÃ©teur associÃ© en C
ğŸ¯ Objectif pÃ©dagogique
Ce module tâ€™initie Ã  la crÃ©ation dâ€™un langage spÃ©cifique Ã  ton programme (DSL â€” Domain Specific Language), et tâ€™enseigne Ã  :

Concevoir une grammaire simple (avec commandes print, goto, pause, etc.)

Ã‰crire un interprÃ©teur qui lit et exÃ©cute des scripts .txt

Structurer un Ã©tat dâ€™exÃ©cution, avec labels, variables, pointeurs dâ€™instruction

Simuler des comportements de machines dâ€™Ã©tat ou scripts systÃ¨mes

ğŸ“š Concepts abordÃ©s
âœ… 1. Structure dâ€™un langage simple
CrÃ©er des instructions Ã©lÃ©mentaires comme :

arduino
Copier
Modifier
set A 42
print A
pause 1000
goto start
Chaque ligne est une commande, avec des arguments.

âœ… 2. InterprÃ©teur de ligne
Lire un fichier .dsl ligne par ligne avec fgets(), dÃ©couper les mots avec strtok(), et exÃ©cuter dynamiquement lâ€™action correspondante.

âœ… 3. SystÃ¨me de labels et goto
Construire une map (label -> ligne) au chargement, pour pouvoir faire des sauts conditionnels dans le script.

âœ… 4. Variables typÃ©es (int, string)
GÃ©rer des variables stockÃ©es dans une table (char *name -> valeur) avec un petit systÃ¨me de type.

âœ… 5. Machine dâ€™Ã©tat simple
CrÃ©er une structure :

c
Copier
Modifier
typedef struct {
    int running;
    int instruction_ptr;
    var_table_t vars;
} dsl_context_t;
Lâ€™interprÃ©teur Ã©volue ligne par ligne en manipulant cet Ã©tat.

ğŸ§ª Exercices
ğŸ“‚ dsl/ex00 â€” Lire et interprÃ©ter print
CrÃ©er une fonction execute_line(char *line) qui reconnaÃ®t :

dsl
Copier
Modifier
print Hello
print 42
Et affiche le message brut.

ğŸ“‚ dsl/ex01 â€” Ajouter set et variables
GÃ©rer :

dsl
Copier
Modifier
set A 10
print A
â†’ ImplÃ©menter une map var_name -> valeur (avec une struct dynamique).

ğŸ“‚ dsl/ex02 â€” Ajouter goto et label
Script :

dsl
Copier
Modifier
label start
print Start
goto start
CrÃ©er un interprÃ©teur qui saute Ã  une ligne nommÃ©e.

ğŸ“‚ dsl/ex03 â€” Ajouter pause
dsl
Copier
Modifier
pause 1000
â†’ Fait dormir lâ€™interprÃ©teur pendant 1000 ms avec usleep().

ğŸ“‚ dsl/ex04 â€” Ajouter if conditionnel
dsl
Copier
Modifier
set X 5
if X > 3 goto big
â†’ Comparer, et conditionner le saut.

ğŸ› ï¸ Bonus
CrÃ©er une commande input pour lire une valeur depuis le terminal

Ajouter un compteur de temps global (tick)

Autoriser les commentaires avec #




# Bloc 9 â€” Projet Graphique: Renderer PBR & Shaders avancÃ©s
ğŸ“š Objectif global
Ton moteur va Ã©voluer pour :

Utiliser des shaders rÃ©alistes basÃ©s sur la physique rÃ©elle (PBR),

GÃ©rer diffÃ©rents matÃ©riaux: mÃ©tal, bois, pierre, etc.,

Ajouter plusieurs lumiÃ¨res dynamiques (point lights, directional lights),

CrÃ©er une architecture de moteur modulaire (Renderer, Assets, Scene, etc.).

ğŸ“‹ Concepts avancÃ©s Ã  apprendre ici

Terme Description
PBR (Physically Based Rendering) Simule la vraie lumiÃ¨re du monde rÃ©el (rÃ©flexions, rugositÃ©)
Albedo, Normal Map, Roughness Map, Metallic Map Images servant Ã  dÃ©crire comment la lumiÃ¨re interagit avec chaque matÃ©riau
BRDF (Bidirectional Reflectance Distribution Function) Formule mathÃ©matique pour modÃ©liser la lumiÃ¨re sur les surfaces
HDR (High Dynamic Range) Travailler avec des couleurs au-delÃ  de 0.0â€“1.0 pour plus de rÃ©alisme
Gamma Correction Corriger la luminositÃ© pour correspondre Ã  la vision humaine
ğŸ“‹ Ã‰tapes principales du Bloc 9

Partie Objectif
9.1 Revoir structure OpenGL: modules Renderer, Asset Manager
9.2 RecrÃ©er pipeline shaders pour support PBR
9.3 Charger textures PBR (albedo, normal, roughness, metallic)
9.4 Ã‰clairer avec plusieurs types de lumiÃ¨res dynamiques
9.5 Support HDR rendering et gamma correction
9.6 ScÃ¨ne test avec plusieurs objets et matÃ©riaux
9.7 Bonus: Ajout de rÃ©flexion de l'environnement (IBL - Image-Based Lighting)
ğŸ“š Architecture recommandÃ©e du moteur
plaintext
Copier
Modifier
engine/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c
â”‚ â”œâ”€â”€ renderer/
â”‚ â”‚ â”œâ”€â”€ renderer.c/.h
â”‚ â”‚ â”œâ”€â”€ shader.c/.h
â”‚ â”‚ â”œâ”€â”€ camera.c/.h
â”‚ â”‚ â”œâ”€â”€ lighting.c/.h
â”‚ â”œâ”€â”€ assets/
â”‚ â”‚ â”œâ”€â”€ model_loader.c/.h
â”‚ â”‚ â”œâ”€â”€ texture_loader.c/.h
â”‚ â”œâ”€â”€ scene/
â”‚ â”‚ â”œâ”€â”€ scene.c/.h
â”œâ”€â”€ shaders/
â”‚ â”œâ”€â”€ pbr.vert
â”‚ â”œâ”€â”€ pbr.frag
â”‚ â”œâ”€â”€ skybox.vert
â”‚ â”œâ”€â”€ skybox.frag
â”œâ”€â”€ resources/
â”‚ â”œâ”€â”€ models/
â”‚ â”œâ”€â”€ textures/
â”‚ â”‚ â”œâ”€â”€ wood_albedo.png
â”‚ â”‚ â”œâ”€â”€ wood_normal.png
â”‚ â”‚ â”œâ”€â”€ wood_metallic.png
â”‚ â”‚ â”œâ”€â”€ wood_roughness.png
â”‚ â”‚ â”œâ”€â”€ skybox/
â”œâ”€â”€ Makefile
â”œâ”€â”€ README.md
ğŸ“š Ce que tu vas maÃ®triser Ã  la fin de ce Bloc 9

CompÃ©tence Niveau
OpenGL avancÃ© âœ…âœ…âœ…
Shaders complexes âœ…âœ…âœ…
ModÃ©lisation matÃ©riaux rÃ©alistes (PBR) âœ…âœ…âœ…
HDR & Gamma Correction âœ…âœ…
Asset management propre âœ…âœ…
PrÃ©paration Ã  Vulkan/DirectX ultÃ©rieurement âœ…
ğŸ“‹ Mini preview du premier shader PBR (extrait simplifiÃ©)
glsl
Copier
Modifier
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
```c
 return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

```
void main()
{
 vec3 N = normalize(Normal);
 vec3 V = normalize(cameraPos - FragPos);
 vec3 L = normalize(lightPos - FragPos);

 vec3 H = normalize(V + L);

 float distance = length(lightPos - FragPos);
 float attenuation = 1.0 / (distance * distance);

 float NdotL = max(dot(N, L), 0.0);

 vec3 radiance = lightColor * attenuation;

```c
 // Cook-Torrance BRDF
 vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
 vec3 specular = ...; // (calcul complet Ã  suivre)
 
```
c
 // Final color
 FragColor = vec4((ambient + diffuse + specular) * albedo, 1.0);
}
(On dÃ©taillera chaque Ã©lÃ©ment trÃ¨s prÃ©cisÃ©ment au fur et Ã  mesure.)

```
ğŸ¯ Plan immÃ©diat
Bloc 9 Partie 1: Restructuration de ton moteur + prÃ©pa shaders PBR

SÃ©parer proprement renderer/, assets/, scene/

PrÃ©parer shaders de base pour PBR

Tester que tout compile proprement en OpenGL 3.3+

# Bloc 9 â€” Partie 1 â€” Restructurer proprement ton moteur 3D
ğŸ“š Objectif immÃ©diat
Tu vas :

SÃ©parer proprement ton projet en modules clairs,

PrÃ©parer la structure Renderer / Assets / Scene,

Commencer Ã  prÃ©parer les shaders PBR.

ğŸ“‹ Pourquoi restructurer ?

Raison Pourquoi c'est crucial
LisibilitÃ© Tu sais tout de suite oÃ¹ trouver quoi
Maintenance Tu peux modifier Renderer sans toucher Assets
ScalabilitÃ© Tu peux ajouter facilement Skybox, Post-processing, Particules...
PropretÃ© pro C'est ce que font tous les vrais moteurs (Unity, Unreal, Godot)
ğŸ“‹ Nouvelle Arborescence du Projet
plaintext
Copier
Modifier
mini_3d_engine/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main.c # Point d'entrÃ©e principal
â”‚
â”‚ â”œâ”€â”€ renderer/
â”‚ â”‚ â”œâ”€â”€ renderer.c/.h # SystÃ¨me global de rendu
â”‚ â”‚ â”œâ”€â”€ shader.c/.h # Chargement et utilisation de shaders
â”‚ â”‚ â”œâ”€â”€ camera.c/.h # Gestion camÃ©ra (FPS, Orbitale)
â”‚ â”‚ â”œâ”€â”€ lighting.c/.h # Gestion des lumiÃ¨res (point light, directional)
â”‚
â”‚ â”œâ”€â”€ assets/
â”‚ â”‚ â”œâ”€â”€ model_loader.c/.h # Chargement de modÃ¨les 3D (.obj, futur .gltf)
â”‚ â”‚ â”œâ”€â”€ texture_loader.c/.h # Chargement textures 2D et cubemaps
â”‚
â”‚ â”œâ”€â”€ scene/
â”‚ â”‚ â”œâ”€â”€ scene.c/.h # Gestion de la scÃ¨ne, des objets et transformations
â”‚
â”œâ”€â”€ shaders/
â”‚ â”œâ”€â”€ pbr.vert # Vertex shader PBR
â”‚ â”œâ”€â”€ pbr.frag # Fragment shader PBR
â”‚ â”œâ”€â”€ skybox.vert
â”‚ â”œâ”€â”€ skybox.frag
â”‚
â”œâ”€â”€ resources/
â”‚ â”œâ”€â”€ models/
â”‚ â”œâ”€â”€ textures/
â”‚ â”‚ â”œâ”€â”€ bois_albedo.png
â”‚ â”‚ â”œâ”€â”€ bois_normal.png
â”‚ â”‚ â”œâ”€â”€ bois_roughness.png
â”‚ â”‚ â”œâ”€â”€ bois_metallic.png
â”‚ â”‚ â”œâ”€â”€ skybox/
â”‚ â”‚ â”œâ”€â”€ right.jpg, left.jpg, etc.
â”‚
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ Tous les headers (.h)
â”‚
â”œâ”€â”€ Makefile # Compilation
â”œâ”€â”€ README.md # Explication du moteur
ğŸ“‹ Module par Module
ğŸ“š renderer/
renderer.c/.h â” Initialiser OpenGL, rÃ©gler les modes, dessiner les scÃ¨nes.

shader.c/.h â” Charger un shader depuis des fichiers .vert et .frag, le compiler et le linker.

camera.c/.h â” FPS + Orbit camÃ©ra.

lighting.c/.h â” GÃ©rer types de lumiÃ¨res (directional, point lights, spotlights plus tard).

ğŸ“š assets/
model_loader.c/.h â” Lire .obj (et plus tard .gltf) â” envoyer dans VBO/VAO.

texture_loader.c/.h â” Charger images .png/.jpg via stb_image, crÃ©ation de textures.

ğŸ“š scene/
scene.c/.h â” CrÃ©er et gÃ©rer plusieurs objets (transformations individuelles, matÃ©riaux attachÃ©s, etc.).

ğŸ“š Makefile minimal prÃ©vu
Makefile
Copier
Modifier
NAME = mini3d

SRCS = src/main.c \
 src/renderer/renderer.c \
 src/renderer/shader.c \
 src/renderer/camera.c \
 src/renderer/lighting.c \
 src/assets/model_loader.c \
 src/assets/texture_loader.c \
 src/scene/scene.c

INCS = -Isrc -Iinclude
CC = gcc
CFLAGS = -Wall -Wextra -Werror -g
LIBS = -lglfw -lGL -ldl -lm -pthread

OBJ = $(SRCS:.c=.o)

all: $(NAME)

$(NAME): $(OBJ)
 $(CC) $(CFLAGS) $(OBJ) -o $(NAME) $(LIBS)

clean:
 rm -f $(OBJ)

fclean: clean
 rm -f $(NAME)

re: fclean all
ğŸ“‹ TÃ¢ches immÃ©diates aprÃ¨s restructuration

Ã€ faire Explication
Migrer camera.c, shader.c, etc. dans renderer/ âœ…
CrÃ©er assets/ et scene/ mÃªme vide pour l'instant âœ…
S'assurer que make re fonctionne sans erreur âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 1
Restructurer tout le projet selon l'architecture ci-dessus,

Corriger les includes (# include "renderer/shader.h", etc.),

Adapter ton Makefile proprement,

Valider compilation (make, pas d'erreur),

PrÃ©parer pour Bloc 9 Partie 2: Premier Shader PBR !

ğŸ“‹ TDD minimal Bloc 9 Partie 1

Test Ce qui doit marcher
make re fonctionne et lance ton moteur âœ…
Organisation des fichiers clean et respectÃ©e âœ…
Aucun warning ou erreur âœ…

# Bloc 9 â€” Partie 2 â€” Premier Shader PBR (Physically Based Rendering)
ğŸ“š Objectif immÃ©diat
Tu vas :

Comprendre la structure d'un shader PBR,

Ã‰crire un vertex shader pour prÃ©parer les donnÃ©es,

Ã‰crire un fragment shader pour le calcul rÃ©aliste de la lumiÃ¨re,

Tester ton premier rendu rÃ©aliste avec rÃ©flexions et matÃ©riaux physiques.

ğŸ“‹ Rappel rapide sur PBR

Ã‰lÃ©ment RÃ´le
Albedo Couleur de base de l'objet (diffuse)
Metallic Indique si la surface est mÃ©tallique (1.0) ou non (0.0)
Roughness DÃ©termine la "rugositÃ©" de la surface (lisse ou mate)
Normal Influence la direction des rÃ©flexions locales
F0 (Fresnel) RÃ©flexion au contact entre matÃ©riaux diffÃ©rents
ğŸ“‹ Organisation rapide
shaders/pbr.vert

shaders/pbr.frag

ğŸ“‹ 1. Vertex Shader PBR (pbr.vert)
glsl
Copier
Modifier
# version 330 core

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
 FragPos = vec3(model * vec4(aPos, 1.0));
 Normal = mat3(transpose(inverse(model))) * aNormal;
 TexCoords = aTexCoords;
 gl_Position = projection * view * vec4(FragPos, 1.0);
}
ğŸ“‹ 2. Fragment Shader PBR (pbr.frag)
Version simplifiÃ©e pour commencer (une seule lumiÃ¨re, pas encore d'IBL) :

glsl
Copier
Modifier
# version 330 core

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

```c
// MatÃ©riaux
uniform sampler2D albedoMap;
uniform sampler2D normalMap;
uniform sampler2D metallicMap;
uniform sampler2D roughnessMap;

```
c
// LumiÃ¨re
uniform vec3 lightPos;
uniform vec3 lightColor;

```
c
// Vue
uniform vec3 camPos;

```
c
// Constantes PBR
const float PI = 3.14159265359;

```
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
```c
 return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

```
void main()
{
 vec3 albedo = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2)); // correction gamma
 float metallic = texture(metallicMap, TexCoords).r;
 float roughness = texture(roughnessMap, TexCoords).r;

 vec3 N = normalize(Normal);
 vec3 V = normalize(camPos - FragPos);
 vec3 L = normalize(lightPos - FragPos);
 vec3 H = normalize(V + L);

 float distance = length(lightPos - FragPos);
 float attenuation = 1.0 / (distance * distance);
 vec3 radiance = lightColor * attenuation;

```c
 // Cook-Torrance BRDF
 float NDF = max(pow(dot(N, H), roughness * roughness), 0.001); // SimplifiÃ©
 float G = 0.5; // SimplifiÃ©
 vec3 F0 = mix(vec3(0.04), albedo, metallic);
 vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);

```
 vec3 nominator = NDF * G * F;
 float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;
 vec3 specular = nominator / denominator;

 vec3 kS = F;
 vec3 kD = vec3(1.0) - kS;
 kD *= 1.0 - metallic;

 float NdotL = max(dot(N, L), 0.0);

 vec3 Lo = (kD * albedo / PI + specular) * radiance * NdotL;

 vec3 ambient = vec3(0.03) * albedo * 0.1;

 vec3 color = ambient + Lo;

```c
 // Gamma correction
 color = pow(color, vec3(1.0/2.2));

```
 FragColor = vec4(color, 1.0);
}
ğŸ“š Explication rapide de ce Fragment Shader

Section RÃ´le
RÃ©cupÃ¨re albedo, roughness, metallic ğŸ“š Lecture des textures
Calcule vecteurs N, V, L, H ğŸ“š Bases de l'Ã©clairage
Applique modÃ¨le Cook-Torrance BRDF ğŸ“š Calcul rÃ©aliste de lumiÃ¨re
MÃ©lange spÃ©culaire et diffuse selon matÃ©riau ğŸ“š RÃ©alisme des surfaces
Ajoute lumiÃ¨re ambiante douce ğŸ“š Pour Ã©viter objets totalement noirs
Correction gamma ğŸ“š Adapter au moniteur humain
ğŸ“‹ Dans main.c / renderer.c
Charger toutes les textures :

wood_albedo.png

wood_normal.png

wood_roughness.png

wood_metallic.png

Lier les uniforms :

c
Copier
Modifier
glUniform1i(glGetUniformLocation(shaderProgram, "albedoMap"), 0);
glUniform1i(glGetUniformLocation(shaderProgram, "normalMap"), 1);
glUniform1i(glGetUniformLocation(shaderProgram, "metallicMap"), 2);
glUniform1i(glGetUniformLocation(shaderProgram, "roughnessMap"), 3);

```c
// Activer les textures
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, albedoTexture);

```
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, normalTexture);

glActiveTexture(GL_TEXTURE2);
glBindTexture(GL_TEXTURE_2D, metallicTexture);

glActiveTexture(GL_TEXTURE3);
glBindTexture(GL_TEXTURE_2D, roughnessTexture);
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
Ton objet 3D est rÃ©aliste âœ…
Surface mÃ©tallique / plastique diffÃ©rente âœ…
RÃ©flexions visibles selon angle camÃ©ra âœ…
DÃ©placement lumiÃ¨re change comportement âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 2
CrÃ©er pbr.vert et pbr.frag,

Modifier shaders actifs dans OpenGL,

Lier textures PBR,

Observer rendu rÃ©aliste ğŸ¨.

ğŸ“‹ TDD minimal Bloc 9 Partie 2

Test Ce qui doit Ãªtre rÃ©ussi
Chargement textures OK âœ…
Shader compile sans erreurs âœ…
Rendu visuel correct selon matÃ©riaux âœ…
Pas d'artefacts (NaN pixels) âœ…

# Bloc 9 â€” Partie 3 â€” LumiÃ¨res dynamiques multiples
ğŸ“š Objectif immÃ©diat
Tu vas :

GÃ©rer plusieurs sources de lumiÃ¨re en mÃªme temps (comme dans un vrai moteur de jeu),

ImplÃ©menter Point Lights et Directional Lights,

Rendre ta scÃ¨ne beaucoup plus vivante et immersive.

ğŸ“‹ Types de lumiÃ¨res Ã  gÃ©rer

Type de lumiÃ¨re Description
Directional Light Simule le soleil â” lumiÃ¨re venant d'une direction constante
Point Light Lampe ou flamme â” lumiÃ¨re depuis un point prÃ©cis dans l'espace
ğŸ“‹ Comment Ã§a marche

Type Ce qui change
Directional Seule direction importante (ex: lumiÃ¨re du soleil)
Point Light Position ET attÃ©nuation (distance influence la force)
ğŸ“š 1. DÃ©finir les structures dans le Shader
ğŸ“‹ Dans pbr.frag :
glsl
Copier
Modifier
# define NR_POINT_LIGHTS 4

struct PointLight {
 vec3 position;
 vec3 color;
};

uniform PointLight pointLights[NR_POINT_LIGHTS];
uniform vec3 dirLightDirection;
uniform vec3 dirLightColor;
ğŸ“‹ 2. Ajouter la contribution de chaque lumiÃ¨re
ğŸ“‹ Directional Light (Soleil)
glsl
Copier
Modifier
```c
// Directional light contribution
vec3 L = normalize(-dirLightDirection);
vec3 H = normalize(V + L);

```
float NdotL = max(dot(N, L), 0.0);
vec3 radiance = dirLightColor; // Pas d'attÃ©nuation pour Directional Light

```c
// Ajout contribution
Lo += (kD * albedo / PI + specular) * radiance * NdotL;
ğŸ“‹ Boucle sur les Point Lights
glsl
Copier
Modifier
for (int i = 0; i < NR_POINT_LIGHTS; ++i)
{
 vec3 L = normalize(pointLights[i].position - FragPos);
 vec3 H = normalize(V + L);
 float distance = length(pointLights[i].position - FragPos);
 float attenuation = 1.0 / (distance * distance);
 vec3 radiance = pointLights[i].color * attenuation;

```
 float NdotL = max(dot(N, L), 0.0);
 Lo += (kD * albedo / PI + specular) * radiance * NdotL;
}
ğŸ“š 3. CÃ´tÃ© C â€” Envoyer les lumiÃ¨res
ğŸ“‹ Exemple pour envoyer 4 Point Lights
c
Copier
Modifier
```c
char uniformName[64];
for (int i = 0; i < 4; i++)
{
 snprintf(uniformName, sizeof(uniformName), "pointLights[%d].position", i);
 glUniform3f(glGetUniformLocation(shaderProgram, uniformName),
 pointLightPositions[i].x, pointLightPositions[i].y, pointLightPositions[i].z);

```
 snprintf(uniformName, sizeof(uniformName), "pointLights[%d].color", i);
 glUniform3f(glGetUniformLocation(shaderProgram, uniformName),
 pointLightColors[i].x, pointLightColors[i].y, pointLightColors[i].z);
}
ğŸ“‹ Exemple pour envoyer la Directional Light
c
Copier
Modifier
glUniform3f(glGetUniformLocation(shaderProgram, "dirLightDirection"), -0.2f, -1.0f, -0.3f);
glUniform3f(glGetUniformLocation(shaderProgram, "dirLightColor"), 1.0f, 1.0f, 1.0f);
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
ScÃ¨ne illuminÃ©e par plusieurs sources âœ…
Point lights visibles et influenÃ§ant diffÃ©rents objets âœ…
Directional light (comme le soleil) affectant tout âœ…
DÃ©placement camÃ©ra montre zones d'ombre/lumiÃ¨re naturelles âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 3
DÃ©finir les structures PointLight et Directional dans shaders,

Adapter la boucle de calcul dans pbr.frag,

Envoyer les lumiÃ¨res depuis ton code C,

Tester en temps rÃ©el plusieurs sources de lumiÃ¨re.

ğŸ“‹ TDD minimal Bloc 9 Partie 3

Test Ce qui doit marcher
Jusqu'Ã  4+ Point Lights visibles âœ…
Directional Light fonctionnelle âœ…
DÃ©placement camÃ©ra influence rendu âœ…
Pas de gros artefact ou NaN visuel âœ…

# Bloc 9 â€” Partie 4 â€” HDR et Gamma Correction
ğŸ“š Objectif immÃ©diat
Tu vas :

Passer ton moteur en rendu haute dynamique (HDR),

Appliquer une gamma correction correcte,

Obtenir un rendu ultra rÃ©aliste comparable Ã  ce qu'on voit dans les moteurs professionnels.

ğŸ“‹ Pourquoi HDR et Gamma Correction ?

Terme Pourquoi c'est important
HDR Permet d'avoir des lumiÃ¨res plus intenses sans saturation, effets naturels
Gamma Correction Corrige la perception lumineuse pour l'Å“il humain
â” Sans gamma, tes objets seront trop sombres ou trop brillants de maniÃ¨re irrÃ©aliste.

ğŸ“š Comment Ã§a fonctionne techniquement

Ã‰tape Action
1. Dessiner toute la scÃ¨ne dans un Framebuffer HDR (format flottant) 
2. Appliquer gamma correction (pow(color, 1/2.2)) lors du post-processing 
ğŸ“‹ 1. CrÃ©er un Framebuffer HDR
Dans renderer.c :

c
Copier
Modifier
```c
unsigned int hdrFBO;
glGenFramebuffers(1, &hdrFBO);
glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);

```
c
// CrÃ©er une texture couleur flottante
unsigned int colorBuffer;
glGenTextures(1, &colorBuffer);
glBindTexture(GL_TEXTURE_2D, colorBuffer);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, WIDTH, HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);

```
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorBuffer, 0);

```c
// CrÃ©er et attacher un Renderbuffer Depth
unsigned int rboDepth;
glGenRenderbuffers(1, &rboDepth);
glBindRenderbuffer(GL_RENDERBUFFER, rboDepth);
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, WIDTH, HEIGHT);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth);

```
c
// VÃ©rifier framebuffer
if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
 printf("âŒ Framebuffer HDR non complet\n");
glBindFramebuffer(GL_FRAMEBUFFER, 0);
ğŸ“‹ 2. Modifier la boucle principale
Avant de rendre ta scÃ¨ne :

```
c
Copier
Modifier
glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

```c
// Rendu normal ici...
// Draw all objects
AprÃ¨s avoir tout dessinÃ© :

```
c
Copier
Modifier
glBindFramebuffer(GL_FRAMEBUFFER, 0); // Retour Ã  l'Ã©cran
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

```c
// Activer ton shader de post-processing (simple quad)
// Passer la texture HDR (colorBuffer) en input
// Appliquer gamma correction ici
ğŸ“‹ 3. Shader de Post-Processing
ğŸ“‹ Vertex Shader post.vert
glsl
Copier
Modifier
# version 330 core
layout (location = 0) in vec2 aPos;
layout (location = 1) in vec2 aTexCoords;

```
out vec2 TexCoords;

void main()
{
 TexCoords = aTexCoords;
 gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);
}
ğŸ“‹ Fragment Shader post.frag
glsl
Copier
Modifier
# version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D hdrBuffer;
uniform bool hdr;
uniform float exposure;

void main()
{
 const float gamma = 2.2;
 vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;

 if(hdr)
 {
```c
 // tone mapping
 vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);
 // gamma correction
 mapped = pow(mapped, vec3(1.0/gamma));
 FragColor = vec4(mapped, 1.0);
 }
 else
 {
 // Sans HDR
 vec3 mapped = pow(hdrColor, vec3(1.0/gamma));
 FragColor = vec4(mapped, 1.0);
 }
}
ğŸ“‹ 4. CÃ´tÃ© C - ContrÃ´ler HDR / Gamma dynamiquement
Tu peux ajouter une variable toggle :

```
c
Copier
Modifier
bool hdr = true;
float exposure = 1.0f;

```c
// Input clavier
if (glfwGetKey(window, GLFW_KEY_H) == GLFW_PRESS)
 hdr = !hdr;

```
if (glfwGetKey(window, GLFW_KEY_KP_ADD) == GLFW_PRESS)
 exposure += 0.01f;
if (glfwGetKey(window, GLFW_KEY_KP_SUBTRACT) == GLFW_PRESS)
 exposure -= 0.01f;
Et l'envoyer au shader :

c
Copier
Modifier
glUniform1i(glGetUniformLocation(postShader, "hdr"), hdr);
glUniform1f(glGetUniformLocation(postShader, "exposure"), exposure);
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
LumiÃ¨res naturelles sans saturer âœ…
ContrÃ´le du contraste avec exposure âœ…
Gamma correction visible (moins "plat") âœ…
Peut dÃ©sactiver HDR Ã  la volÃ©e âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 4
CrÃ©er framebuffer HDR + texture flottante,

Ajouter post-processing shader simple,

Appliquer tone mapping + gamma correction,

Tester visuellement diffÃ©rentes expositions.

ğŸ“‹ TDD minimal Bloc 9 Partie 4

Test Ce qui doit marcher
Scene rendu via HDR framebuffer âœ…
Rendu avec lumiÃ¨re rÃ©aliste âœ…
Toggle HDR fonctionne avec touche âœ…
Gamma correction visible et naturelle âœ…

# Bloc 9 â€” Partie 5 â€” SystÃ¨me complet de MatÃ©riaux
ğŸ“š Objectif immÃ©diat
Tu vas :

Donner Ã  chaque objet 3D ses propres textures et propriÃ©tÃ©s,

CrÃ©er un systÃ¨me Material pour stocker albedo, roughness, metallic, normal map,

Permettre Ã  ton moteur d'afficher diffÃ©rents matÃ©riaux en mÃªme temps sur plusieurs objets.

ğŸ“‹ Pourquoi un "Material System" est indispensable

Raison Pourquoi c'est nÃ©cessaire
FlexibilitÃ© Chaque objet peut avoir son propre aspect sans recompiler les shaders
Performance RÃ©duction des changements de shaders inutiles
RÃ©alisme MÃ©langer matÃ©riaux mÃ©tal, plastique, bois, roche dans la mÃªme scÃ¨ne
ScÃ¨ne complexe Gerer plusieurs objets dynamiques proprement
ğŸ“‹ Architecture prÃ©vue du systÃ¨me MatÃ©riaux
plaintext
Copier
Modifier
src/assets/
â”œâ”€â”€ material.c/.h --> DÃ©finir structure de Material + crÃ©ation + liaison aux shaders
ğŸ“‹ 1. DÃ©finir un Material
ğŸ“‹ Dans material.h
c
Copier
Modifier
# ifndef MATERIAL_H
# define MATERIAL_H

typedef struct s_material
{
```c
 unsigned int albedo;
 unsigned int normal;
 unsigned int metallic;
 unsigned int roughness;
} t_material;

```
c
t_material *create_material(const char *albedoPath, const char *normalPath, const char *metallicPath, const char *roughnessPath);
void bind_material(t_material *material);

```
# endif
ğŸ“‹ Dans material.c
c
Copier
Modifier
```c
# include "material.h"
# include "texture_loader.h" // fonction pour charger textures
# include <stdlib.h>

```
t_material *create_material(const char *albedoPath, const char *normalPath, const char *metallicPath, const char *roughnessPath)
{
 t_material *material = malloc(sizeof(t_material));
 if (!material)
```c
 return NULL;
 material->albedo = load_texture(albedoPath);
 material->normal = load_texture(normalPath);
 material->metallic = load_texture(metallicPath);
 material->roughness = load_texture(roughnessPath);
 return material;
}

```
void bind_material(t_material *material)
{
 glActiveTexture(GL_TEXTURE0);
 glBindTexture(GL_TEXTURE_2D, material->albedo);

 glActiveTexture(GL_TEXTURE1);
 glBindTexture(GL_TEXTURE_2D, material->normal);

 glActiveTexture(GL_TEXTURE2);
 glBindTexture(GL_TEXTURE_2D, material->metallic);

 glActiveTexture(GL_TEXTURE3);
 glBindTexture(GL_TEXTURE_2D, material->roughness);
}
ğŸ“š 2. Utiliser un Material dans la scÃ¨ne
Dans ton scene.c :

Chaque objet aura maintenant un t_material *material;

Par exemple :

c
Copier
Modifier
typedef struct s_object3d
{
```c
 unsigned int vao;
 unsigned int vbo;
 unsigned int ebo;
 t_material *material;
 // Transform (position, rotation, scale) peut Ãªtre ici aussi
} t_object3d;
ğŸ“‹ 3. Pendant le rendu
Avant de dessiner chaque objet :

```
c
Copier
Modifier
bind_material(object->material);
glDrawElements(GL_TRIANGLES, object->indexCount, GL_UNSIGNED_INT, 0);
Chaque objet utilisera alors ses propres textures, tout en restant sur le mÃªme shader PBR global !

ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
DiffÃ©rents matÃ©riaux sur diffÃ©rents objets âœ…
Aucun bug visuel ou artefact âœ…
MatÃ©riaux changÃ©s facilement (bois, mÃ©tal, roche, etc.) âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 5
CrÃ©er material.h et material.c,

Donner un t_material * Ã  chaque objet 3D,

Charger des textures diffÃ©rentes par objet,

Lier et dessiner les matÃ©riaux au moment du draw.

ğŸ“‹ TDD minimal Bloc 9 Partie 5

Test Ce qui doit marcher
Plusieurs objets avec matÃ©riaux diffÃ©rents âœ…
Switch de matÃ©riaux sans recompiler shader âœ…
Textures respectÃ©es pour chaque objet âœ…

# Bloc 9 â€” Partie 6 â€” Activer Normal Mapping dynamique
ğŸ“š Objectif immÃ©diat
Tu vas :

Utiliser des normal maps pour ajouter du relief sans gÃ©omÃ©trie supplÃ©mentaire,

Calculer la matrice TBN (Tangent, Bitangent, Normal),

Afficher des surfaces qui rÃ©agissent Ã  la lumiÃ¨re comme si elles avaient du volume rÃ©el.

ğŸ“‹ Pourquoi utiliser le Normal Mapping ?

Bump Mapping / Normal Mapping Avantages
Normal Mapping Simule la lumiÃ¨re rÃ©agissant Ã  des dÃ©tails 3D sans ajouter de polygones
Performant Ne coÃ»te rien en gÃ©omÃ©trie (GPU friendly)
RÃ©aliste Donne de la profondeur visuelle mÃªme sur des plans plats
ğŸ“‹ 1. Ce qu'il faut ajouter aux vertices
Tu dois :

Ajouter tangent et bitangent Ã  chaque sommet,

Calculer la matrice TBN pour transformer la normal map correctement.

Chaque vertex devient :

c
Copier
Modifier
```c
// pos // normal // texcoord // tangent // bitangent
x, y, z, nx, ny, nz, u, v, tx, ty, tz, bx, by, bz
â¡ï¸ Total de 14 floats par vertex !

```
ğŸ“‹ 2. Calcul des Tangents & Bitangents
Fais ce calcul une fois aprÃ¨s avoir chargÃ© ton modÃ¨le .obj, pour chaque triangle :

c
Copier
Modifier
```c
// EntrÃ©e: pos1, pos2, pos3 â€” uv1, uv2, uv3
vec3 edge1 = pos2 - pos1;
vec3 edge2 = pos3 - pos1;
vec2 deltaUV1 = uv2 - uv1;
vec2 deltaUV2 = uv3 - uv1;

```
float f = 1.0 / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);

vec3 tangent;
tangent.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
tangent.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
tangent.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);
normalize(tangent);

vec3 bitangent;
bitangent.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);
bitangent.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);
bitangent.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);
normalize(bitangent);
ğŸ“‹ 3. Vertex Shader pbr.vert (mis Ã  jour)
Ajoute en entrÃ©e :

glsl
Copier
Modifier
layout (location = 3) in vec3 aTangent;
layout (location = 4) in vec3 aBitangent;
Et dans le shader :

glsl
Copier
Modifier
out vec3 FragPos;
out vec2 TexCoords;
out mat3 TBN;

void main()
{
 vec3 T = normalize(mat3(model) * aTangent);
 vec3 B = normalize(mat3(model) * aBitangent);
 vec3 N = normalize(mat3(model) * aNormal);
 TBN = mat3(T, B, N);

 FragPos = vec3(model * vec4(aPos, 1.0));
 TexCoords = aTexCoords;
 gl_Position = projection * view * vec4(FragPos, 1.0);
}
ğŸ“‹ 4. Fragment Shader pbr.frag (mis Ã  jour)
Remplace :

glsl
Copier
Modifier
vec3 N = normalize(Normal); // â›” ancien code
par :

glsl
Copier
Modifier
vec3 normalMap = texture(normalMap, TexCoords).rgb;
normalMap = normalMap * 2.0 - 1.0; // Transform 0â€“1 -> -1 to 1
vec3 N = normalize(TBN * normalMap); // âœ… Vrai relief !
ğŸ“š RÃ©sultat attendu

Action RÃ©sultat
Surface "plate" semble avoir des bosses âœ…
RÃ©agit Ã  la lumiÃ¨re selon angle camÃ©ra âœ…
Relief change avec les tangents et la texture âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 6
Ajouter tangents/bitangents aux vertex,

Calculer TBN matrix dans vertex shader,

Lire la normal map dans fragment shader,

Appliquer le mapping dynamique.

ğŸ“‹ TDD minimal Bloc 9 Partie 6

Test Ce qui doit marcher
Surface avec normal map rÃ©agit correctement Ã  la lumiÃ¨re âœ…
Sans normal map, rendu reste OK âœ…
Rotation camÃ©ra modifie bien le relief âœ…
Aucun artefact visuel (noirs ou cassÃ©s) âœ…

# Bloc 9 â€” Partie 7 â€” Image-Based Lighting (IBL)
ğŸ“š Objectif immÃ©diat
Tu vas :

Ajouter un systÃ¨me de rÃ©flexion rÃ©aliste basÃ© sur ta Skybox (cubemap),

IntÃ©grer IBL Diffuse et IBL Specular (simplifiÃ© au dÃ©part),

AmÃ©liorer visuellement tous tes matÃ©riaux sans nouvelle gÃ©omÃ©trie ni lumiÃ¨re dynamique.

ğŸ“‹ Qu'est-ce que l'IBL ?

Ã‰lÃ©ment Description
IBL = Image-Based Lighting Utiliser une image HDR (skybox) comme source de lumiÃ¨re globale
RÃ©flexions rÃ©elles Les matÃ©riaux reflÃ¨tent le ciel, l'environnement
Ã‰conomie de calcul Pas besoin de 10 lampes pour simuler un Ã©clairage naturel
Immersion ++ ReflÃ©ter ce qui est autour dans l'objet comme un miroir flou ou parfait
ğŸ“‹ Deux composants IBL

Type But
IBL Diffuse Teinte gÃ©nÃ©rale issue de l'environnement
IBL Specular RÃ©flexions plus ou moins brillantes (dÃ©pend du roughness)
On commence ici par un IBL simplifiÃ© statique (trÃ¨s bon rendu, trÃ¨s peu de calcul).

ğŸ“‹ Ã‰tapes gÃ©nÃ©rales Ã  suivre
Charger ta Skybox (dÃ©jÃ  fait âœ…)

La convertir en irradiance map (basse rÃ©solution, floutÃ©e pour IBL diffuse)

La convertir en prefilter map (pour IBL specular)

Utiliser un BRDF LUT (lookup texture) pour corriger la brillance

IntÃ©grer tout Ã§a dans ton pbr.frag

ğŸ“‹ 1. Charger Skybox HDR (format .hdr)
Tu dois utiliser une skybox HDRI (pas juste une image .jpg !)

Exemple HDRI :
ğŸ‘‰ https://polyhaven.com/hdris â€” Gratuit

Charge-la avec stbi_loadf() (au lieu de stbi_load classique) :

c
Copier
Modifier
float *data = stbi_loadf("resources/hdr/newport_loft.hdr", &width, &height, &nrComponents, 0);
Et utilise GL_RGB16F pour la texture OpenGL.

ğŸ“‹ 2. GÃ©nÃ©rer la irradiance map
Une fois la skybox chargÃ©e :

c
Copier
Modifier
glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);
glFramebufferTexture2D(...); // target irradianceMap

```c
// Lancer un shader spÃ©cial de convolution
// RÃ©solution: 32x32 (ou mÃªme 16x16)
ğŸ’¡ Ce shader prend la skybox, floute les directions et gÃ©nÃ¨re la lumiÃ¨re ambiante par face.

```
ğŸ“‹ 3. GÃ©nÃ©rer la prefilter map
MÃªme idÃ©e que pour irradiance, mais :

RÃ©solution plus grande (128x128),

Shader + complexe: prÃ©filtre selon roughness.

ğŸ“‹ 4. GÃ©nÃ©rer la BRDF LUT texture
Ce n'est pas une image â†’ c'est une texture 2D (512Ã—512) gÃ©nÃ©rÃ©e une seule fois avec un shader.

Ce LUT sert Ã  corriger l'intensitÃ© des rÃ©flexions spÃ©culaires dans pbr.frag.

ğŸ“‹ 5. IntÃ©grer dans pbr.frag
Ajoute :

glsl
Copier
Modifier
uniform samplerCube irradianceMap;
uniform samplerCube prefilterMap;
uniform sampler2D brdfLUT;
Et modifie ton calcul :

glsl
Copier
Modifier
```c
// IBL Diffuse
vec3 irradiance = texture(irradianceMap, N).rgb;
vec3 diffuseIBL = irradiance * albedo;

```
c
// IBL Specular
vec3 R = reflect(-V, N);
float roughness = ...;
vec3 prefilteredColor = textureLod(prefilterMap, R, roughness * MAX_LOD).rgb;

```
vec2 brdf = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;
vec3 specularIBL = prefilteredColor * (F * brdf.x + brdf.y);

```c
// Final color
vec3 color = ambient + Lo + diffuseIBL + specularIBL;
ğŸ“‹ RÃ©sultat attendu

```
Action RÃ©sultat
MatÃ©riaux reflÃ¨tent la Skybox âœ…
Surfaces mÃ©talliques = miroirs rÃ©alistes âœ…
MatiÃ¨res mates = diffus mais teintÃ©es par environnement âœ…
Rotation camÃ©ra = reflet rÃ©aliste âœ…
Aucun artefact de lumiÃ¨re en intÃ©rieur âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 7
Charger une HDR Skybox (.hdr)

GÃ©nÃ©rer 3 textures dÃ©rivÃ©es :

Irradiance Map

Prefilter Map

BRDF LUT

Modifier pbr.frag pour ajouter IBL

Tester sur plusieurs objets

ğŸ“‹ TDD minimal Bloc 9 Partie 7

Test Ce qui doit Ãªtre fonctionnel
Reflets dynamiques selon la Skybox âœ…
Surfaces mÃ©talliques montrent miroir (flou/net) âœ…
Brillance correcte avec BRDF LUT âœ…
Diffuse naturel mÃªme sans lumiÃ¨re directe âœ…

# Bloc 9 â€” Partie 8 â€” Instancing OpenGL (dessiner 10 000 objets d'un coup)
ğŸ“š Objectif immÃ©diat
Tu vas :

Utiliser l'OpenGL Instancing pour dessiner des centaines / milliers d'objets identiques avec des positions diffÃ©rentes,

Apprendre Ã  envoyer des matrices de transformation pour chaque instance,

Booster les performances pour simuler foules, forÃªts, pluie, Ã©toiles...

ğŸ“‹ Pourquoi utiliser Instancing ?

Sans Instancing Avec Instancing
glDrawElements() appelÃ© 10 000 fois AppelÃ© une seule fois
Chaque objet â†’ CPU + GPU Calcul CPU une fois â†’ GPU fait tout
Super lent âš¡ Ultra rapide
ğŸ“‹ Exemple typique d'usage

Projet Utilisation
ForÃªt 1 arbre x 10 000 positions
SystÃ¨me solaire 1 planÃ¨te x 100 satellites
Champ d'astÃ©roÃ¯des 1 rocher x 1000 instances
Particules 1 sprite / bill x 100 000
ğŸ“‹ 1. Ajouter un VBO de matrices (par instance)
Dans renderer.c :

c
Copier
Modifier
```c
unsigned int instanceVBO;
glGenBuffers(1, &instanceVBO);
glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(glm::mat4) * amount, modelMatrices, GL_STATIC_DRAW);
modelMatrices[] est un tableau de glm::mat4 (ou Ã©quivalent float[16]) contenant toutes les positions, rotations, Ã©chelles.

```
ğŸ“‹ 2. Attacher les matrices Ã  ton VAO (en tant qu'attributs par instance)
Un mat4 = 4 vec4 â†’ 4 glVertexAttribPointer

c
Copier
Modifier
```c
for (int i = 0; i < 4; i++) {
 glEnableVertexAttribArray(3 + i);
 glVertexAttribPointer(3 + i, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float) * i * 4));
 glVertexAttribDivisor(3 + i, 1); // 1 = par instance
}
ğŸ“‹ 3. Modifier ton Vertex Shader pour inclure model par instance
Dans pbr.vert :

```
glsl
Copier
Modifier
layout (location = 3) in mat4 instanceModel;

uniform mat4 view;
uniform mat4 projection;

void main()
{
 vec4 worldPosition = instanceModel * vec4(aPos, 1.0);
 FragPos = vec3(worldPosition);
 gl_Position = projection * view * worldPosition;

 Normal = mat3(transpose(inverse(instanceModel))) * aNormal;
 TexCoords = aTexCoords;
}
ğŸ“‹ 4. CÃ´tÃ© dessin (main.c ou scene.c)
Au lieu de faire une boucle :

c
Copier
Modifier
```c
for (int i = 0; i < 10000; i++)
 glDrawElements(...);
Fais simplement :

```
c
Copier
Modifier
glDrawElementsInstanced(GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, 0, instanceCount);
Boom ğŸ’¥: 1 appel, 10 000 objets rendus.

ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
10 000 objets visibles âœ…
FPS Ã©levÃ© (si pas de post-process lourd) âœ…
Chaque objet positionnÃ© diffÃ©remment âœ…
Pas de lag CPU âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 8
GÃ©nÃ©rer un tableau de modelMatrices (positions alÃ©atoires par exemple),

CrÃ©er un VBO avec ces matrices,

Lier ce VBO comme des attributs d'instance,

Modifier le shader pour utiliser la matrice par objet,

Dessiner via glDrawElementsInstanced.

ğŸ“‹ TDD minimal Bloc 9 Partie 8

Test Ce qui doit marcher
Tous les objets sont visibles âœ…
Chaque objet a une transformation unique âœ…
Un seul appel de rendu âœ…
Aucun crash ou artefact graphique âœ…

# Bloc 9 â€” Partie 9 â€” Architecture de ScÃ¨ne: Entity Component System (ECS)
ğŸ“š Objectif immÃ©diat
Tu vas :

Construire une architecture modulaire extensible pour gÃ©rer des milliers d'objets dynamiques,

ImplÃ©menter un systÃ¨me Entity / Component / System comme dans Unity ou Godot,

ContrÃ´ler facilement transformations, matÃ©riaux, comportements et rendu de chaque objet.

ğŸ“‹ Pourquoi utiliser un ECS ?

Sans ECS Avec ECS
Objets en struct fixes imbriquÃ©es Objets dynamiques avec composants indÃ©pendants
Difficile Ã  maintenir Super flexible et modulaire
Code spaghetti Code clair, par type de logique
Ajouter un composant = casser le reste Ajouter un composant = plug and play âœ…
ğŸ“‹ Concepts de base

Ã‰lÃ©ment RÃ´le
Entity Identifiant unique (souvent juste un uint)
Component DonnÃ©e (Transform, Material, Physics...)
System Logique (rendering, update, collision...)
ğŸ“‹ Exemple visuel
plaintext
Copier
Modifier
Entity 1: [Transform] + [Renderable] + [Material]
Entity 2: [Transform] + [Physics]
Entity 3: [Transform] + [Light] + [Material]
Chaque System itÃ¨re uniquement sur les entitÃ©s qui ont les bons composants.

ğŸ“‹ 1. CrÃ©er les bases dans scene/
ğŸ“‹ entity.h
c
Copier
Modifier
# ifndef ENTITY_H
# define ENTITY_H

```c
typedef unsigned int Entity;
# define MAX_ENTITIES 10000

```
c
Entity create_entity(void);
void destroy_entity(Entity e);

```
# endif
ğŸ“‹ component.h
c
Copier
Modifier
# ifndef COMPONENT_H
# define COMPONENT_H

```c
# include "entity.h"

```
typedef struct {
 float position[3];
 float rotation[3];
 float scale[3];
} Transform;

typedef struct {
```c
 unsigned int vao;
 unsigned int index_count;
} Renderable;

```
typedef struct {
```c
 unsigned int material_id;
} MaterialComponent;

```
c
void add_transform(Entity e, Transform t);
void add_renderable(Entity e, Renderable r);
void add_material(Entity e, MaterialComponent m);

```
Transform* get_transform(Entity e);
Renderable* get_renderable(Entity e);
MaterialComponent* get_material(Entity e);

# endif
ğŸ“‹ scene.h
c
Copier
Modifier
# ifndef SCENE_H
# define SCENE_H

```c
void init_scene(void);
void update_scene(float dt);
void render_scene(void);

```
# endif
ğŸ“‹ 2. Exemple d'utilisation dans ton moteur
c
Copier
Modifier
Entity asteroid = create_entity();

Transform t = {{10.0f, 2.0f, -50.0f}, {0, 0, 0}, {1.0f, 1.0f, 1.0f}};
Renderable r = {asteroid_vao, index_count};
MaterialComponent m = {material_id};

add_transform(asteroid, t);
add_renderable(asteroid, r);
add_material(asteroid, m);
ğŸ“‹ 3. render_system.c (un "System")
c
Copier
Modifier
void render_scene(void)
{
```c
 for (Entity e = 0; e < MAX_ENTITIES; e++)
 {
 if (has_transform(e) && has_renderable(e) && has_material(e))
 {
 Transform* t = get_transform(e);
 Renderable* r = get_renderable(e);
 MaterialComponent* m = get_material(e);

```
c
 // GÃ©nÃ©rer model matrix depuis t
 // Lier m->material_id
 // Lancer draw pour r->vao
 }
 }
}
ğŸ“š RÃ©sultat attendu

```
Action RÃ©sultat
Ajouter un objet = 3 appels add_...() âœ…
Chaque entitÃ© a sa logique propre âœ…
SystÃ¨me modulable: ajouter Composant Physics plus tard âœ…
Code clair, propre, scalable âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 9
CrÃ©er Entity, Component, System modules,

Init 10 entitÃ©s avec diffÃ©rents composants,

ImplÃ©menter le systÃ¨me de rendu proprement,

Ajouter la possibilitÃ© d'avoir des transformations individuelles.

ğŸ“‹ TDD minimal Bloc 9 Partie 9

Test Ce qui doit marcher
Ajouter une entitÃ© et lui assigner 3 composants âœ…
Le render_system dÃ©tecte et dessine l'objet âœ…
La structure supporte 1000+ entitÃ©s âœ…
Aucun couplage entre composants âœ…

# Bloc 9 â€” Partie 10 â€” Moteur Temps RÃ©el: Input, Physique & Mouvements dans ECS
ğŸ“š Objectif immÃ©diat
Tu vas :

Ajouter la gestion du temps (deltaTime),

IntÃ©grer les mouvements physiques dans les entitÃ©s (vitesse, gravitÃ©...),

Rendre les objets dynamiques (input clavier, animation, comportements dans le monde 3D).

ğŸ“‹ Composants Ã  ajouter

Nom du composant Contenu
Velocity Vecteur de vitesse (x, y, z)
InputController Touches associÃ©es Ã  l'entitÃ© (player, NPC)
Timer (facultatif) ChronomÃ¨tre d'action (attaque, respawn, etc.)
ğŸ“‹ 1. Nouveau composant: Velocity
ğŸ“‹ Dans component.h
c
Copier
Modifier
typedef struct {
 float x;
 float y;
 float z;
} Velocity;

```c
void add_velocity(Entity e, Velocity v);
Velocity* get_velocity(Entity e);
bool has_velocity(Entity e);
ğŸ“‹ 2. Nouveau systÃ¨me: physics_system.c
c
Copier
Modifier
void update_physics(float dt)
{
 for (Entity e = 0; e < MAX_ENTITIES; e++)
 {
 if (has_transform(e) && has_velocity(e))
 {
 Transform* t = get_transform(e);
 Velocity* v = get_velocity(e);

```
 t->position[0] += v->x * dt;
 t->position[1] += v->y * dt;
 t->position[2] += v->z * dt;
 }
 }
}
ğŸ“‹ 3. Nouveau composant: InputController (pour joueur)
c
Copier
Modifier
typedef struct {
```c
 int forward_key;
 int back_key;
 int left_key;
 int right_key;
 float speed;
} InputController;

```
c
void add_input(Entity e, InputController c);
InputController* get_input(Entity e);
bool has_input(Entity e);
ğŸ“‹ 4. SystÃ¨me: input_system.c
c
Copier
Modifier
void update_input(GLFWwindow* window, float dt)
{
 for (Entity e = 0; e < MAX_ENTITIES; e++)
 {
 if (has_input(e) && has_velocity(e))
 {
 InputController* ctrl = get_input(e);
 Velocity* vel = get_velocity(e);

```
 vel->x = 0;
 vel->z = 0;

 if (glfwGetKey(window, ctrl->forward_key) == GLFW_PRESS)
 vel->z -= ctrl->speed;
 if (glfwGetKey(window, ctrl->back_key) == GLFW_PRESS)
 vel->z += ctrl->speed;
 if (glfwGetKey(window, ctrl->left_key) == GLFW_PRESS)
 vel->x -= ctrl->speed;
 if (glfwGetKey(window, ctrl->right_key) == GLFW_PRESS)
 vel->x += ctrl->speed;

```c
 // Tu peux ajouter Y si besoin (saut)
 }
 }
}
ğŸ“‹ 5. Boucle principale (main loop)
c
Copier
Modifier
float lastTime = glfwGetTime();
while (!glfwWindowShouldClose(window))
{
 float currentTime = glfwGetTime();
 float deltaTime = currentTime - lastTime;
 lastTime = currentTime;

```
 glfwPollEvents();

 update_input(window, deltaTime);
 update_physics(deltaTime);
 update_scene(deltaTime);
 render_scene();

 glfwSwapBuffers(window);
}
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
Le joueur peut bouger un objet avec le clavier âœ…
Chaque objet avec Velocity bouge naturellement âœ…
Ajouter un saut ou une chute devient simple âœ…
Le temps rÃ©el est stable et fluide âœ…
ğŸ¯ Mini plan d'action Bloc 9 Partie 10
CrÃ©er les composants Velocity et InputController,

Ajouter les systÃ¨mes update_physics() et update_input(),

Brancher Ã§a Ã  ta boucle de jeu (avec deltaTime),

CrÃ©er un objet "Player" qui rÃ©agit au clavier ğŸ®

ğŸ“‹ TDD minimal Bloc 9 Partie 10

Test Ce qui doit fonctionner
DÃ©placement via touches âœ…
Mouvements fluides et temps rÃ©el âœ…
Vitesse ajustable facilement âœ…
SystÃ¨me scalable Ã  des NPCs, ennemis, balles, etc. âœ…
âœ… Bloc 9 â€” Partie 10 terminÃ© proprement !
Ton moteur est maintenant entiÃ¨rement interactif, temps rÃ©el et orientÃ© jeu ğŸ¯ğŸ”¥

# Bloc 10 â€” Projet Simulation de Jeu RÃ©el (sur ton moteur) [ğŸŸ¢ Facile]
ğŸ® Titre provisoire: Project_ZeroAlpha

ğŸ“š Objectif global
CrÃ©er un prototype de jeu complet et jouable, Ã  choisir parmi :

Prototype Description DifficultÃ©
ğŸª Shoot Spatial 3D Tu pilotes un vaisseau dans l'espace, tu tires, tu esquives, tu gagnes. ğŸ”¥ğŸ”¥
ğŸ¦¾ Jeu de Plateforme FPS Tu explores un monde 3D, tu sautes, tu rÃ©sous des puzzles. ğŸ”¥ğŸ”¥ğŸ”¥
âš”ï¸ Prototype ARÃˆNE TPS Tu joues un personnage qui se bat dans une arÃ¨ne Ã  la 3áµ‰ personne. ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
ğŸ‘¾ Jeu minimal Rogue-like 3D Tu explores, lootes, meurs, recommences. ğŸ”¥ğŸ”¥ğŸ”¥
ğŸ’¡ Tu pourras TOUS les faire ensuite, mais on commence avec UN prototype bien structurÃ©.

âœ… Par dÃ©faut: Shoot Spatial 3D
Si tu ne choisis pas, on part lÃ -dessus: simple, nerveux, parfait pour valider ton moteur.

ğŸ“‹ Ã‰tapes globales

Ã‰tape Objectif
10.1 CrÃ©er le joueur (vaisseau, contrÃ´les, camÃ©ra)
10.2 CrÃ©er les ennemis + vagues alÃ©atoires
10.3 GÃ©rer tirs, projectiles, collisions
10.4 Afficher HUD (vie, score, armes)
10.5 Ajouter explosion, sons, feedbacks
10.6 Menu pause, restart, victoire/dÃ©faite
10.7 Export build stable Linux (et plus tard Windows ?)
ğŸ—‚ï¸ Organisation du projet
plaintext
Copier
Modifier
game_project_zero/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ game/ # logiques spÃ©cifiques au jeu
â”‚ â”‚ â”œâ”€â”€ player.c/.h
â”‚ â”‚ â”œâ”€â”€ enemy.c/.h
â”‚ â”‚ â”œâ”€â”€ bullet.c/.h
â”‚ â”‚ â”œâ”€â”€ hud.c/.h
â”‚ â”‚ â”œâ”€â”€ game_state.c/.h
â”‚ â”œâ”€â”€ engine/ # ton moteur OpenGL actuel
â”œâ”€â”€ assets/
â”‚ â”œâ”€â”€ models/ # vaisseau, ennemis, projectiles
â”‚ â”œâ”€â”€ textures/
â”‚ â”œâ”€â”€ sounds/
â”‚ â”œâ”€â”€ shaders/
â”œâ”€â”€ include/
â”œâ”€â”€ Makefile
ğŸ§  SystÃ¨me utilisÃ©

Ã‰lÃ©ment Moteur
Rendu OpenGL PBR avec IBL
ECS Oui (Entity, Component, System)
Input GLFW + systÃ¨me maison
Physique Simple: AABB collisions, vitesse
UI Textes et barres via primitives 2D (Ã  venir)
ğŸ§© Composants typiques du jeu

Composant Description
Transform Position, rotation, Ã©chelle
Velocity Direction et vitesse
InputController Pour le joueur
AIController Pour les ennemis
Health Points de vie
Bullet DÃ©gÃ¢ts, vitesse, collision
ScoreTag Permet de compter les points
ğŸ“‹ PrÃªt pour: Bloc 10 â€” Partie 1 [ğŸŸ¢ Facile]
âœ… Bloc 10 Partie 1 â€” CrÃ©er ton joueur [ğŸŸ¢ Facile]
Tu vas :

CrÃ©er une entitÃ© Player,

Ajouter composants: Transform, Velocity, InputController, Health, Renderable,

ContrÃ´ler ses dÃ©placements (ZQSD ou FlÃ¨ches),

Lier la camÃ©ra Ã  la position du joueur (TPS ou cockpit).

# Bloc 10 â€” Partie 1 â€” CrÃ©er le Joueur [ğŸŸ¢ Facile]: ContrÃ´les, Apparence, CamÃ©ra
ğŸ¯ Objectif de cette partie
Tu vas :

CrÃ©er une entitÃ© Player dans l'ECS,

Lui donner un vaisseau visible, contrÃ´lable au clavier,

Ajouter une camÃ©ra liÃ©e au joueur (mode cockpit ou suivi TPS),

Le rendre prÃªt Ã  tirer plus tard (Partie 2).

ğŸ“š Composants utilisÃ©s pour Player

Composant RÃ´le
Transform Position dans le monde 3D
Velocity Mouvement contrÃ´lÃ©
InputController LiÃ© aux touches clavier
Renderable Apparence du vaisseau (VAO + mesh)
MaterialComponent Apparence visuelle PBR
CameraFollow (bonus) CamÃ©ra suit automatiquement cette entitÃ©
ğŸ“‹ Ã‰tapes concrÃ¨tes
1ï¸âƒ£ CrÃ©er l'entitÃ© dans game/player.c
c
Copier
Modifier
```c
# include "entity.h"
# include "component.h"
# include "player.h"

```
Entity player;

void create_player(void)
{
 player = create_entity();

 Transform t = {{0.0f, 0.0f, 0.0f}, {0, 0, 0}, {1, 1, 1}};
 Velocity v = {0, 0, 0};
 InputController ctrl = {
 .forward_key = GLFW_KEY_W,
 .back_key = GLFW_KEY_S,
 .left_key = GLFW_KEY_A,
 .right_key = GLFW_KEY_D,
 .speed = 20.0f
 };

 Renderable r = {load_player_vao(), player_index_count};
 MaterialComponent m = {load_player_material()};

 add_transform(player, t);
 add_velocity(player, v);
 add_input(player, ctrl);
 add_renderable(player, r);
 add_material(player, m);
}
2ï¸âƒ£ Lier la camÃ©ra au joueur
Dans camera_follow_system.c :

c
Copier
Modifier
void update_camera_follow(float dt)
{
 if (has_transform(player))
 {
 Transform* t = get_transform(player);
 set_camera_position(t->position[0], t->position[1] + 2.0f, t->position[2] + 10.0f);
 look_at(t->position); // fonction Ã  Ã©crire
 }
}
3ï¸âƒ£ Brancher le tout
Dans main.c ou game_state.c :

c
Copier
Modifier
create_player();

while (!glfwWindowShouldClose(window))
{
 float dt = compute_delta_time();

 glfwPollEvents();
 update_input(window, dt);
 update_physics(dt);
 update_camera_follow(dt);
 render_scene();

 glfwSwapBuffers(window);
}
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
Un vaisseau visible au centre âœ…
ContrÃ´lable avec ZQSD âœ…
La camÃ©ra suit de prÃ¨s ou derriÃ¨re âœ…
Vitesse fluide et responsive âœ…
ğŸ”§ Exemple VAO minimal du vaisseau (temporaire)
Tu peux commencer par charger un simple cube .obj ou quad en OpenGL avec une couleur de test.

ğŸ¯ Mini-TDD Bloc 10 Partie 1 [ğŸŸ¢ Facile]

Test Ce qui doit marcher
Appui sur Z avance le joueur âœ…
Appui sur D tourne Ã  droite âœ…
La camÃ©ra suit correctement âœ…
Aucun lag, aucun artefact visuel âœ…

# Bloc 10 â€” Partie 2 â€” Tirs et projectiles du Joueur [ğŸŸ¢ Facile]
ğŸ“š Objectif immÃ©diat
Tu vas :

Permettre au joueur de tirer en appuyant sur une touche,

CrÃ©er des projectiles dynamiques (missiles, lasers, balles),

Faire avancer automatiquement les projectiles,

PrÃ©parer les bases pour les collisions contre les ennemis.

ğŸ“‹ Composants supplÃ©mentaires nÃ©cessaires

Composant RÃ´le
Projectile Identifie une entitÃ© comme projectile
Velocity ContrÃ´le la vitesse du projectile
Renderable Pour afficher un modÃ¨le de laser
Transform Position du projectile dans l'espace
ğŸ“‹ 1. Ajouter Projectile dans component.h
c
Copier
Modifier
typedef struct {
 float damage;
 Entity owner;
} Projectile;

```c
void add_projectile(Entity e, Projectile p);
Projectile* get_projectile(Entity e);
bool has_projectile(Entity e);
ğŸ“‹ 2. Code pour tirer un projectile dans player.c
Quand le joueur appuie sur une touche (espace par exemple) :

```
c
Copier
Modifier
void shoot_projectile(Entity shooter)
{
 if (!has_transform(shooter))
```c
 return;

```
 Entity bullet = create_entity();

 Transform* shooterTransform = get_transform(shooter);
 Transform t = {
 {shooterTransform->position[0], shooterTransform->position[1], shooterTransform->position[2]},
 {0.0f, 0.0f, 0.0f},
 {0.2f, 0.2f, 0.2f}
 };

 Velocity v = {0.0f, 0.0f, -100.0f}; // Va tout droit vers le "devant"
 Renderable r = {load_bullet_vao(), bullet_index_count};
 MaterialComponent m = {load_bullet_material()};
 Projectile p = {.damage = 10.0f, .owner = shooter};

 add_transform(bullet, t);
 add_velocity(bullet, v);
 add_renderable(bullet, r);
 add_material(bullet, m);
 add_projectile(bullet, p);
}
ğŸ“‹ 3. Gestion de l'Input pour tirer
Dans ton update_input(window, dt) :

c
Copier
Modifier
static double lastShotTime = 0.0;
double currentTime = glfwGetTime();

if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS && currentTime - lastShotTime > 0.25)
{
 shoot_projectile(player);
 lastShotTime = currentTime;
}
(Un dÃ©lai de 0.25s entre deux tirs pour Ã©viter spam.)

ğŸ“‹ 4. Avancer les projectiles (dÃ©jÃ  gÃ©rÃ© par update_physics())
GrÃ¢ce Ã  ton Velocity, les projectiles avancent automatiquement !

â” Tu n'as rien de spÃ©cial Ã  ajouter cÃ´tÃ© mouvement. âœ…

ğŸ“‹ 5. DÃ©truire les projectiles trop Ã©loignÃ©s (nettoyage)
Ajoute dans update_physics() :

c
Copier
Modifier
if (has_projectile(e))
{
 Transform* t = get_transform(e);
 if (t->position[2] < -100.0f || t->position[2] > 100.0f)
 destroy_entity(e);
}
Pour Ã©viter qu'ils existent Ã  l'infini dans l'espace.

ğŸ“š RÃ©sultat attendu

Action RÃ©sultat
Appui sur Espace â” crÃ©ation d'un laser âœ…
Le laser avance automatiquement âœ…
Le laser disparaÃ®t aprÃ¨s 100 unitÃ©s âœ…
Tir fluide sans freeze du moteur âœ…
ğŸ¯ Mini plan d'action Bloc 10 Partie 2 [ğŸŸ¢ Facile]
Ajouter Projectile en tant que composant,

Permettre au joueur de tirer via Espace,

GÃ©nÃ©rer entitÃ©s projectiles en temps rÃ©el,

GÃ©rer le mouvement + destruction automatique.

ğŸ“‹ TDD minimal Bloc 10 Partie 2 [ğŸŸ¢ Facile]

Test Ce qui doit fonctionner
Tirs visibles et alignÃ©s avec le vaisseau âœ…
DÃ©placement fluide des projectiles âœ…
Tirs dÃ©sactivÃ©s aprÃ¨s une certaine distance âœ…
Aucun crash ou fuite mÃ©moire âœ…

# Bloc 10 â€” Partie 3 â€” GÃ©nÃ©rer Ennemis et Vagues d'Attaque [ğŸŸ¢ Facile]
ğŸ“š Objectif immÃ©diat
Tu vas :

CrÃ©er des entitÃ©s ennemies dynamiques,

Les placer en formation ou alÃ©atoirement dans l'espace,

Leur donner un comportement basique (avancer / foncer vers toi),

PrÃ©parer la logique de vagues successives.

ğŸ“‹ Composants des Ennemis

Composant RÃ´le
Transform Position 3D de l'ennemi
Velocity DÃ©placement automatique
Renderable Apparence (modÃ¨le 3D d'ennemi)
MaterialComponent Aspect visuel (textures, shaders)
Health Points de vie
EnemyTag Pour les identifier comme ennemis
ğŸ“‹ 1. Ajouter EnemyTag dans component.h
c
Copier
Modifier
typedef struct {
```c
 int waveNumber;
} EnemyTag;

```
c
void add_enemy(Entity e, EnemyTag et);
bool has_enemy(Entity e);
EnemyTag* get_enemy(Entity e);
ğŸ“‹ 2. CrÃ©er un gÃ©nÃ©rateur d'ennemis dans enemy.c
c
Copier
Modifier
void spawn_enemy(float x, float y, float z, int wave)
{
 Entity enemy = create_entity();

```
 Transform t = {{x, y, z}, {0, 0, 0}, {1.0f, 1.0f, 1.0f}};
 Velocity v = {0.0f, 0.0f, 5.0f}; // Viens vers toi
 Renderable r = {load_enemy_vao(), enemy_index_count};
 MaterialComponent m = {load_enemy_material()};
 EnemyTag et = {wave};
 Health h = {100}; // 100 PV par dÃ©faut

 add_transform(enemy, t);
 add_velocity(enemy, v);
 add_renderable(enemy, r);
 add_material(enemy, m);
 add_enemy(enemy, et);
 add_health(enemy, h);
}
ğŸ“‹ 3. GÃ©rer la gÃ©nÃ©ration de vagues
Dans wave_manager.c :

c
Copier
Modifier
```c
static int current_wave = 0;
static float time_since_last_wave = 0.0f;

```
void update_wave_manager(float dt)
{
 time_since_last_wave += dt;

 if (time_since_last_wave > 10.0f) // Toutes les 10 secondes
 {
 current_wave++;
 time_since_last_wave = 0.0f;

```c
 int number_of_enemies = 5 + current_wave * 2;

```
c
 for (int i = 0; i < number_of_enemies; i++)
 {
 float x = (rand() % 40) - 20;
 float y = (rand() % 10) - 5;
 float z = -100.0f; // Toujours loin en avant
 spawn_enemy(x, y, z, current_wave);
 }
 }
}
ğŸ“‹ 4. IntÃ©grer dans ta boucle principale
Dans main.c :

```
c
Copier
Modifier
update_wave_manager(deltaTime);
AjoutÃ© juste avant render_scene().

ğŸ“‹ 5. (Optionnel) DÃ©truire les ennemis arrivÃ©s au bout
Dans update_physics() :

c
Copier
Modifier
if (has_enemy(e))
{
 Transform* t = get_transform(e);
 if (t->position[2] > 10.0f) // Passe derriÃ¨re toi ?
 destroy_entity(e);
}
ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
Apparition d'ennemis toutes les 10 secondes âœ…
Ennemis se dÃ©placent vers toi automatiquement âœ…
Vagues deviennent plus grandes Ã  chaque fois âœ…
Pas de lag visible si vague < 100 ennemis âœ…
ğŸ¯ Mini plan d'action Bloc 10 Partie 3 [ğŸŸ¢ Facile]
Ajouter EnemyTag et Health,

CrÃ©er fonction spawn_enemy(x, y, z, wave),

CrÃ©er un gestionnaire de vagues update_wave_manager(),

Nettoyer les ennemis hors de la scÃ¨ne.

ğŸ“‹ TDD minimal Bloc 10 Partie 3 [ğŸŸ¢ Facile]

Test Ce qui doit marcher
Apparition rÃ©guliÃ¨re d'ennemis âœ…
DÃ©placement fluide vers le joueur âœ…
Vagues de plus en plus difficiles âœ…
Pas d'ennemis fantÃ´mes persistants âœ…

# Bloc 10 â€” Partie 4 â€” SystÃ¨me de Collisions et Destruction d'Ennemis [ğŸŸ¢ Facile]
ğŸ“š Objectif immÃ©diat
Tu vas :

DÃ©tecter les collisions entre projectiles et ennemis,

Infliger des dÃ©gÃ¢ts via le composant Health,

DÃ©truire l'ennemi ou le projectile en consÃ©quence,

PrÃ©parer les effets visuels et le score pour la Partie 5.

ğŸ“‹ Composants nÃ©cessaires

Composant RÃ´le
Projectile Identifie un projectile (avec source & dÃ©gÃ¢ts)
EnemyTag Identifie un ennemi
Health Pour retirer les PV
Transform Permet de dÃ©terminer la position (collision)
ğŸ“‹ 1. Ajouter un systÃ¨me de collision simple
Dans collision_system.c :

c
Copier
Modifier
float distance_squared(float* a, float* b)
{
 float dx = a[0] - b[0];
 float dy = a[1] - b[1];
 float dz = a[2] - b[2];
```c
 return dx * dx + dy * dy + dz * dz;
}

```
void update_projectile_collisions(void)
{
```c
 for (Entity proj = 0; proj < MAX_ENTITIES; proj++)
 {
 if (!has_projectile(proj) || !has_transform(proj)) continue;

```
 Transform* pt = get_transform(proj);
 Projectile* p = get_projectile(proj);

```c
 for (Entity e = 0; e < MAX_ENTITIES; e++)
 {
 if (!has_enemy(e) || !has_transform(e) || !has_health(e)) continue;

```
 Transform* et = get_transform(e);

 if (distance_squared(pt->position, et->position) < 1.0f) // Rayon = 1 unitÃ©
 {
```c
 // Appliquer les dÃ©gÃ¢ts
 Health* h = get_health(e);
 h->value -= p->damage;

```
c
 // DÃ©truire projectile
 destroy_entity(proj);

```
c
 // Ennemi mort ?
 if (h->value <= 0)
 {
 destroy_entity(e);
 // Ajouter score plus tard
 }

```
 break; // Un projectile touche un seul ennemi
 }
 }
 }
}
ğŸ“‹ 2. Appeler ce systÃ¨me dans la boucle principale
Dans main.c (ou Ã©quivalent) :

c
Copier
Modifier
update_projectile_collisions(); // AprÃ¨s update_physics()
ğŸ“‹ 3. CrÃ©er Health dans component.h
c
Copier
Modifier
typedef struct {
 float value;
} Health;

```c
void add_health(Entity e, Health h);
Health* get_health(Entity e);
bool has_health(Entity e);
ğŸ“‹ 4. Visuel (temporaire)
Tu peux afficher dans la console :

```
c
Copier
Modifier
```c
printf("[+] Enemy hit! Remaining HP: %.1f\n", h->value);
Ou plus tard, afficher une explosion (Partie 5).

```
ğŸ“š RÃ©sultat attendu

Action RÃ©sultat
Projectile touche ennemi â” ennemi perd PV âœ…
Ennemi meurt si PV â‰¤ 0 âœ…
Projectile disparaÃ®t Ã  l'impact âœ…
Aucun bug ou crash âœ…
ğŸ¯ Mini plan d'action Bloc 10 Partie 4 [ğŸŸ¢ Facile]
CrÃ©er le systÃ¨me update_projectile_collisions,

Ajouter composant Health,

GÃ©rer dÃ©gÃ¢t + destruction entitÃ©,

Appeler le systÃ¨me Ã  chaque frame.

ğŸ“‹ TDD minimal Bloc 10 Partie 4 [ğŸŸ¢ Facile]

Test Ce qui doit marcher
Collision correcte mÃªme Ã  grande vitesse âœ…
Plusieurs ennemis peuvent Ãªtre touchÃ©s âœ…
Score prÃªt Ã  Ãªtre incrÃ©mentÃ© (Ã  suivre) âœ…
Aucun objet "zombie" restant sur scÃ¨ne âœ…

# Bloc 10 â€” Partie 5 â€” HUD, Score et Effets visuels [ğŸŸ¢ Facile]
ğŸ“š Objectif immÃ©diat
Tu vas :

Afficher un HUD complet avec score, vies, vague actuelle,

Ajouter une explosion visuelle ou effet de disparition Ã  la mort des ennemis,

GÃ©rer le systÃ¨me de score, de vies et de fin de partie (game over).

ğŸ“‹ Ã‰lÃ©ments Ã  gÃ©rer maintenant

Ã‰lÃ©ment Type Objectif
Score Variable globale ou composant PlayerScore +10 points par ennemi
Vies Variable globale ou composant PlayerHealth -1 si ennemi te dÃ©passe
HUD Dessin 2D (texte ou primitives) Affichage Ã  l'Ã©cran
Explosion EntitÃ© temporaire ou effet visuel simple Feedback de destruction
âœ… Ã‰tape 1 â€” Ajouter le score (via composant)
ğŸ“‹ Dans component.h
c
Copier
Modifier
typedef struct {
```c
 int score;
 int lives;
} PlayerStatus;

```
c
void add_player_status(Entity e, PlayerStatus s);
PlayerStatus* get_player_status(Entity e);
bool has_player_status(Entity e);
ğŸ“‹ Lors de la crÃ©ation du joueur (create_player())
c
Copier
Modifier
PlayerStatus status = {0, 3}; // 3 vies au dÃ©part
add_player_status(player, status);
âœ… Ã‰tape 2 â€” IncrÃ©menter le score quand un ennemi meurt
Dans update_projectile_collisions() (lÃ  oÃ¹ l'ennemi est dÃ©truit) :

```
c
Copier
Modifier
PlayerStatus* s = get_player_status(player);
if (s)
 s->score += 10;
âœ… Ã‰tape 3 â€” Perdre une vie si un ennemi passe derriÃ¨re le joueur
Dans update_physics() :

c
Copier
Modifier
if (has_enemy(e))
{
 Transform* t = get_transform(e);
 if (t->position[2] > 10.0f) // Ennemi a dÃ©passÃ© le joueur
 {
 PlayerStatus* s = get_player_status(player);
 if (s)
 s->lives--;

 destroy_entity(e);
 }
}
âœ… Ã‰tape 4 â€” GÃ©rer le Game Over
Dans ta boucle principale :

c
Copier
Modifier
if (has_player_status(player))
{
 PlayerStatus* s = get_player_status(player);
 if (s->lives <= 0)
 {
```c
 printf("GAME OVER - Score: %d\n", s->score);
 running = false;
 }
}
âœ… Ã‰tape 5 â€” Afficher le HUD (score + vies)
ğŸ“‹ Option simple: via printf() en console
c
Copier
Modifier
printf("Score: %d | Vies: %d | Vague: %d\r", s->score, s->lives, current_wave);
ğŸ“‹ Option avancÃ©e: afficher texte en 2D via OpenGL (Ã  venir)
Tu pourras utiliser :

```
Soit des sprites 2D OpenGL,

Soit une mini-lib comme stb_easy_font ou bitmap font
(ajoutÃ© plus tard dans Bloc 11 si tu veux) [ğŸŸ¢ Facile]

âœ… Ã‰tape 6 â€” Ajouter une "explosion" visuelle
ğŸ“‹ Dans enemy_death() (ou dans update_projectile_collisions())
c
Copier
Modifier
Entity fx = create_entity();
Transform t = *get_transform(enemy);
Renderable r = {load_explosion_vao(), explosion_index_count};
MaterialComponent m = {load_explosion_material()};

add_transform(fx, t);
add_renderable(fx, r);
add_material(fx, m);
Et dÃ©truis l'explosion aprÃ¨s 0.5s (avec un timer ou via fx_lifetime_system()).

ğŸ“‹ RÃ©sultat attendu

Action RÃ©sultat
Score augmente quand tu dÃ©truis un ennemi âœ…
Tu perds une vie si un ennemi t'Ã©chappe âœ…
Le HUD affiche Score, Vies et Vague actuelle âœ…
Une explosion rapide est jouÃ©e Ã  chaque mort âœ…
Le jeu s'arrÃªte proprement si lives == 0 âœ…
ğŸ¯ Mini plan d'action Bloc 10 Partie 5 [ğŸŸ¢ Facile]
Ajouter composant PlayerStatus (score, vies),

Afficher score & vies via console ou HUD,

Ajouter mini explosion Ã  la mort,

GÃ©rer GAME OVER en cas de 0 vie.

ğŸ“‹ TDD minimal Bloc 10 Partie 5 [ğŸŸ¢ Facile]

Test Ce qui doit Ãªtre visible
Score = nombre d'ennemis dÃ©truits Ã— 10 âœ…
Vies dÃ©crÃ©mentÃ©es si ennemi passe âœ…
Affichage Score / Vies rÃ©actif âœ…
Jeu se termine si vies <= 0 âœ…

# Bloc 10 â€” Partie 6 â€” Menu Pause, Victoire, DÃ©faite, Restart [ğŸŸ¢ Facile]
ğŸ“š Objectif immÃ©diat
Tu vas :

ImplÃ©menter un systÃ¨me d'Ã©tat de jeu (Running, Paused, GameOver, Victory),

Permettre de mettre le jeu en pause avec ECHAP,

Afficher Ã©crans de fin (gagnÃ© ou perdu),

Proposer un redÃ©marrage (Restart) sans relancer l'application.

ğŸ“‹ Ã‰tats du jeu
c
Copier
Modifier
typedef enum {
 STATE_RUNNING,
 STATE_PAUSED,
 STATE_GAMEOVER,
 STATE_VICTORY
} GameState;

GameState current_state = STATE_RUNNING;
ğŸ“‹ 1. GÃ©rer le pause avec ECHAP
Dans update_input() :

c
Copier
Modifier
```c
static int esc_last = GLFW_RELEASE;
int esc_now = glfwGetKey(window, GLFW_KEY_ESCAPE);

```
if (esc_now == GLFW_PRESS && esc_last == GLFW_RELEASE)
{
 if (current_state == STATE_RUNNING)
 current_state = STATE_PAUSED;
 else if (current_state == STATE_PAUSED)
 current_state = STATE_RUNNING;
}
esc_last = esc_now;
ğŸ“‹ 2. Afficher pause (version console ou plus tard graphique)
c
Copier
Modifier
if (current_state == STATE_PAUSED)
{
```c
 printf("\nâ¸ï¸ JEU EN PAUSE â€” Appuie sur [ECHAP] pour reprendre\n");
 return;
}
ğŸ“‹ 3. Passer en STATE_GAMEOVER
Dans ta boucle principale ou dans update_health() :

```
c
Copier
Modifier
PlayerStatus* status = get_player_status(player);
if (status && status->lives <= 0)
 current_state = STATE_GAMEOVER;
ğŸ“‹ 4. DÃ©tecter la victoire
Exemple: si score >= 500, tu gagnes :

c
Copier
Modifier
if (status->score >= 500)
 current_state = STATE_VICTORY;
ğŸ“‹ 5. Afficher Ã©cran de fin (console pour l'instant)
c
Copier
Modifier
if (current_state == STATE_GAMEOVER)
{
```c
 printf("\nğŸ’€ GAME OVER ! Score: %d\n", status->score);
 printf("Appuie sur [R] pour recommencer\n");
}

```
if (current_state == STATE_VICTORY)
{
```c
 printf("\nğŸ† VICTOIRE ! Score: %d\n", status->score);
 printf("Appuie sur [R] pour recommencer\n");
}
ğŸ“‹ 6. ImplÃ©menter Restart (R)
Dans update_input() :

```
c
Copier
Modifier
if ((current_state == STATE_GAMEOVER || current_state == STATE_VICTORY) &&
 glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS)
{
 reset_game();
 current_state = STATE_RUNNING;
}
Et dans reset_game() :

c
Copier
Modifier
void reset_game(void)
{
 destroy_all_entities(); // fonction Ã  Ã©crire

 current_wave = 0;
 create_player();
```c
 // RÃ©initialiser score, vies, vague, etc.
}
ğŸ“š RÃ©sultat attendu

```
Action RÃ©sultat
ECHAP â” met le jeu en pause ou le relance âœ…
0 vie â” GAME OVER avec message âœ…
Score max â” VICTOIRE avec message âœ…
Appuyer sur R â” tout recommence proprement âœ…
ğŸ¯ Mini plan d'action Bloc 10 Partie 6 [ğŸŸ¢ Facile]
ImplÃ©menter GameState global,

Ajouter pause, game over, victoire,

Afficher messages Ã  l'Ã©cran (console ou HUD),

Ajouter R pour recommencer le jeu.

ğŸ“‹ TDD minimal Bloc 10 Partie 6 [ğŸŸ¢ Facile]

Test Ce qui doit marcher
Pause / Reprise avec ECHAP âœ…
GAME OVER si lives == 0 âœ…
VICTOIRE si score >= X âœ…
RedÃ©marrage sans crash âœ…

# Bloc 10 â€” Partie 7 â€” Build Linux propre et Organisation du projet [ğŸŸ¢ Facile]
ğŸ“š Objectif immÃ©diat
Tu vas :

Structurer ton projet final,

CrÃ©er un Makefile solide,

Ajouter un script Bash pour compiler/lancer automatiquement (build_and_run.sh),

PrÃ©parer ton projet pour le test, la diffusion, ou l'Ã©volution future.

ğŸ“‹ 1. Arborescence finale du projet
plaintext
Copier
Modifier
game_project_zero/
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ engine/ # OpenGL, Render, Input, ECS
â”‚ â”œâ”€â”€ game/ # Player, Enemy, Bullet, HUD, Menu, State
â”œâ”€â”€ include/
â”‚ â”œâ”€â”€ engine/ # Headers moteur
â”‚ â”œâ”€â”€ game/ # Headers gameplay
â”œâ”€â”€ assets/
â”‚ â”œâ”€â”€ models/ # .obj
â”‚ â”œâ”€â”€ textures/ # .png, .jpg
â”‚ â”œâ”€â”€ shaders/ # .vert, .frag
â”‚ â”œâ”€â”€ sounds/ # effets audios
â”œâ”€â”€ build/ # Binaires et objets
â”œâ”€â”€ Makefile # Build principal
â”œâ”€â”€ build_and_run.sh # Script compilation + exÃ©cution
â”œâ”€â”€ README.md # Explication rapide
ğŸ“‹ 2. Makefile solide
Exemple de base :

Makefile
Copier
Modifier
NAME = project_zero

SRC_DIR = src
BUILD_DIR = build
INCLUDE_DIR = include

SRCS = $(shell find $(SRC_DIR) -name "*.c")
OBJS = $(SRCS:$(SRC_DIR)/%.c=$(BUILD_DIR)/%.o)

CC = gcc
CFLAGS = -Wall -Wextra -Werror -I$(INCLUDE_DIR) -g
LDFLAGS = -lglfw -lGL -ldl -lm -lpthread

all: $(NAME)

$(NAME): $(OBJS)
 $(CC) $(CFLAGS) $(OBJS) -o $(NAME) $(LDFLAGS)

$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c
 mkdir -p $(dir $@)
 $(CC) $(CFLAGS) -c $< -o $@

clean:
 rm -rf $(BUILD_DIR)

fclean: clean
 rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
ğŸ“‹ 3. Script Bash build_and_run.sh
CrÃ©e build_and_run.sh :

bash
Copier
Modifier
# !/bin/bash

echo "ğŸ› ï¸ Compilation du projet..."
make re

```c
if [ $? -eq 0 ]; then
 echo "ğŸš€ Lancement du jeu !"
 ./project_zero
else
 echo "âŒ Erreur de compilation."
fi
â” Donne-lui les droits d'exÃ©cution :

```
bash
Copier
Modifier
chmod +x build_and_run.sh
ğŸ“‹ 4. README.md minimal
markdown
Copier
Modifier
# Project Zero â€” Jeu Spatial 3D

ğŸ® Petit jeu de tir spatial en C/OpenGL 100% codÃ© Ã  la main.

## Compilation
```bash
./build_and_run.sh
Commandes
ZQSD: dÃ©placer le vaisseau

Espace: tirer

Ã‰chap: pause

R: restart si game over ou victoire

Objectifs
DÃ©truire un maximum d'ennemis sans perdre toutes ses vies !

Bon jeu ğŸš€

yaml
Copier
Modifier

---

# ğŸ“š RÃ©sultat attendu

| Action | RÃ©sultat |
|:---|:---|
| `./build_and_run.sh` compile et lance ton jeu | âœ… |
| Arborescence claire et modulaire | âœ… |
| Projet prÃªt Ã  Ãªtre compressÃ© et diffusÃ© | âœ… |
| Aucun warning / erreur de compilation | âœ… |

---

# ğŸ¯ Mini plan d'action Bloc 10 Partie 7 [ğŸŸ¢ Facile]

1. RÃ©organiser les fichiers,
2. CrÃ©er Makefile propre,
3. CrÃ©er script bash d'exÃ©cution,
4. Ã‰crire README minimal.

---

# ğŸ“‹ TDD minimal Bloc 10 Partie 7 [ğŸŸ¢ Facile]

| Test | Ce qui doit marcher |
|:---|:---|
| Compilation propre sans warning | âœ… |
| ExÃ©cution fonctionnelle via script | âœ… |
| Arborescence projet lisible | âœ… |

---

âœ… **Bloc 10 â€” Partie 7 terminÃ© proprement !**  [ğŸŸ¢ Facile]
Ton **premier vrai jeu en C sur moteur custom est officiellement terminÃ© et exportable** ğŸ¯ğŸš€

---

# ğŸ“¢ ğŸ–ï¸ Fin de Bloc 10 â€” RÃ©sumÃ© [ğŸŸ¢ Facile]

Tu as maintenant :
- Un moteur graphique OpenGL PBR HDR Instancing ğŸ¨
- Un moteur de jeu ECS propre et scalable ğŸ“¦
- Un vrai jeu interactif complet ğŸ›¸
- Des systÃ¨mes de score, vie, HUD, Ã©tats de jeu ğŸ§ 
- Un build final solide sous Linux / terminal ğŸ¯

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“‹ FEUILLE DE PROGRESSION PERSONNELLE - FORMAT PAPIER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Cette feuille est entiÃ¨rement facultative mais pensÃ©e pour motiver et suivre ta progression
durant la piscine et tout au long du cursus 42 personnel. Elle est faite pour Ãªtre imprimÃ©e
et remplie Ã  la main. Utilise-la comme carnet de route, checklist ou tableau de bord.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸŒ± PROGRESSION PAR NIVEAUX (symbolique et motivante)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

| Niveau | XP nÃ©cessaire  | Description                       |
|--------|----------------|-----------------------------------|
| 1      | 0              | DÃ©butant (Git/Linux)              |
| 2      | 100            | Makefile validÃ© et propre         |
| 3      | 250            | Pointeurs et malloc maÃ®trisÃ©s     |
| 4      | 500            | TDD utilisÃ© sur projets           |
| 5      | 800            | Shell/Compilateur rÃ©alisÃ©         |

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§© BADGES Ã€ COCHER - VERSION PAPIER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[ ] Makefile Master - CrÃ©er un Makefile multi-fichiers
[ ] Pointer Slayer - RÃ©ussir 10 exos avec double pointeurs
[ ] TDD Master - Projet complet testÃ© de A Ã  Z
[ ] Git Ninja - Branches, rebase, merge maÃ®trisÃ©s
[ ] Shell Warrior - Shell fonctionnel avec parsing complexe

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“˜ MODULES Ã€ SUIVRE - SUIVI MANUEL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

| Module              | Fait ? | Confiance (0-5) | Ã€ revoir ? |
|---------------------|--------|------------------|------------|
| Makefile            | [ ]    |                  | [ ]        |
| Git                 | [ ]    |                  | [ ]        |
| Pointeurs           | [ ]    |                  | [ ]        |
| TDD                 | [ ]    |                  | [ ]        |
| LibC avancÃ©e        | [ ]    |                  | [ ]        |
| GNL/Pipex/Minishell | [ ]    |                  | [ ]        |
| Graphisme/RÃ©seau    | [ ]    |                  | [ ]        |
| OS / Compilateurs   | [ ]    |                  | [ ]        |

Conseil: Imprime cette feuille Ã  la fin de chaque bloc ou mois de travail, coche ce que tu maÃ®trises,
et note ce que tu veux revoir plus tard. Tu peux aussi t'en servir pour planifier ta semaine.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ“š RÃ©fÃ©rences conseillÃ©es

Voici trois ouvrages que tu peux consulter tout au long de ton apprentissage pour approfondir chaque notion :

- **ğŸ“˜ Le guide complet du C â€” Claude Delannoy**  
  â¤ Une rÃ©fÃ©rence claire et progressive pour bien maÃ®triser le langage C, depuis les bases jusquâ€™aux pointeurs avancÃ©s.

- **ğŸ’» Programmation systÃ¨me en C sous Linux â€” Christophe Blaess**  
  â¤ Un excellent livre pour comprendre les appels systÃ¨mes, la gestion de processus, les fichiers, la mÃ©moire, etc., dans un environnement Linux.

- **ğŸ“— C in a Nutshell â€” Peter Prinz & Tony Crawford**  
  â¤ Une bible de rÃ©fÃ©rence technique, concise et bien structurÃ©e, idÃ©ale pour retrouver rapidement la syntaxe ou les fonctions de la libc.

---
##ğŸ“‘ Table des matiÃ¨res

###ğŸ“˜ Piscine BoostÃ©e â€“ Bloc 1 [ğŸŸ¢ Facile]
Partie 1/5 : Affichage & Premiers concepts
0.0.0) ft_putchar
0.0.1) ft_print_alphabet
0.0.2) ft_print_reverse_alphabet
0.0.3) ft_print_numbers
0.0.4) ft_is_negative
0.0.5) ft_print_comb
0.0.6) ft_print_comb2
0.0.7) ft_putnbr
0.0.8) ft_print_combn
(Module 1 â€” preprocessor/ â€” Fondamentaux du PrÃ©processeur C)
0.0.9) ft_ultimate_ft
Partie 2/5 : Pointeurs & chaÃ®nes
0.0.10) ft_swap
0.0.11) ft_div_mod
0.0.12) ft_ultimate_div_mod
0.0.13) ft_putstr
0.0.14) ft_strlen
0.0.15) ft_strcpy
0.0.16) ft_strncpy
0.0.17) ft_str_is_alpha
0.0.18) ft_str_is_numeric
0.0.19) ft_str_is_lowercase
Partie 3/5 : ChaÃ®nes & mÃ©moire
0.0.20) ft_str_is_uppercase
0.0.21) ft_str_is_printable
0.0.22) ft_strupcase
0.0.23) ft_strlowcase
0.0.24) ft_strcapitalize
0.0.25) ft_strlcpy
0.0.26) ft_putstr_non_printable
0.0.27) ft_print_memory (Partie 1)
Partie 4/5 : RÃ©cursivitÃ© & MathÃ©matiques
0.1.0) ft_recursive_factorial
0.1.1) ft_iterative_factorial
0.1.2) ft_recursive_power
0.1.3) ft_iterative_power
0.1.4) ft_fibonacci
0.1.5) ft_sqrt
0.1.6) ft_is_prime
0.1.7) ft_find_next_prime
Partie 5/5 : Bilan
Ce que tu as appris dans la Piscine

###ğŸ“¦ Bloc 2 â€” Libft++ BoostÃ©e [ğŸŸ¢ Facile]
Partie 1/7 : Fonctions de base
1.0) ft_strlen
1.1) ft_strcpy
1.2) ft_strdup
1.3) ft_strcmp
1.4) ft_strncpy
Partie 2/7 : Manipulation de mÃ©moire
2.0) ft_memset
2.1) ft_bzero
2.2) ft_memcpy
2.3) ft_memmove
2.4) ft_memchr
Partie 3/7 : Comparaison & recherche
3.0) ft_memcmp
3.1) ft_strchr
3.2) ft_strrchr
3.3) ft_strncmp
3.4) ft_strnstr
Partie 4/7 : Conversion & substr
4.0) ft_calloc
4.1) ft_strdup (Rappel amÃ©liorÃ©)
4.2) ft_atoi
4.3) ft_itoa
4.4) ft_substr
Partie 5/7 : ChaÃ®nes avancÃ©es
5.0) ft_strjoin
5.1) ft_strtrim
5.2) ft_split
5.3) ft_strmapi
5.4) ft_striteri
Partie 6/7 : Ã‰criture dans des fichiers
6.0) ft_putchar_fd
6.1) ft_putstr_fd
6.2) ft_putendl_fd
6.3) ft_putnbr_fd
Partie 7/7 : Listes chaÃ®nÃ©es
7.0) ft_lstnew
7.1) ft_lstadd_front
7.2) ft_lstsize
7.3) ft_lstlast
7.4) ft_lstadd_back
7.5) ft_lstdelone
7.6) ft_lstclear
7.7) ft_lstiter
7.8) ft_lstmap
Partie 8 : Bonus pro
8.0) CrÃ©er un Makefile Pro
8.1) TDD Complet
8.2) Automatiser les tests

###ğŸ”„ Bloc 3 â€” GNL++ BoostÃ©e [ğŸŸ¡ IntermÃ©diaire]
Partie 1 Ã  4 : Lecture ligne par ligne, stash, buffer, parsing
ft_strlen_gnl, ft_strchr_gnl, ft_strdup_gnl, ft_strjoin_gnl
Lecture en blocs (BUFFER_SIZE)
Extraction de lignes
Gestion de la mÃ©moire restante

###ğŸ§µ Bloc 4 â€” Pipex++ BoostÃ© [ğŸŸ¡ IntermÃ©diaire]
Partie 1 Ã  4 : Processus, redirections, exÃ©cutions
Argument parsing, pipes, forks, execve
ExÃ©cution des commandes et communication
Finalisation et gestion des erreurs

###ğŸš Bloc 5 â€” Minishell++ BoostÃ© [ğŸŸ  AvancÃ©]
Partie 1 Ã  9 : Shell, parsing, readline, signaux, pipes, logique
Modes avec et sans readline
ImplÃ©mentation pas Ã  pas dâ€™un shell POSIX
Gestion avancÃ©e des erreurs et signaux

###ğŸ§  Bloc 6 â€” Malloc++ BoostÃ© [ğŸŸ¡ Ã  ğŸ”´]
Partie 1 Ã  6 : Gestion mÃ©moire custom
Structures de blocs mÃ©moire
malloc, free, realloc
Fusion des blocs, affichage, debug, tests

###ğŸŒ Bloc 7 â€” Serveur RÃ©seau TCP [ğŸŸ¡ Ã  ğŸ”´]
Partie 1 Ã  8 : RÃ©seau bas niveau
Serveur mono-client, multi-client
Protocole TCP minimal
Commandes /msg, /who, broadcast
Client personnalisÃ©
ModularitÃ© et refactorisation

###ğŸ® Bloc 8 â€” Moteur 3D OpenGL [ğŸŸ  AvancÃ©]
Partie 1 Ã  9 : OpenGL, GLFW, CamÃ©ras, Shaders, Textures
FenÃªtre OpenGL, Skybox
ContrÃ´le FPS, ECS, Texturing
Lighting, PBR, Normal Mapping, Instancing

###ğŸ•¹ï¸ Bloc 9 â€” Renderer PBR & Shaders [ğŸ”´ TrÃ¨s avancÃ©]
Partie 1 Ã  10 : Physically Based Rendering, ECS, scÃ¨nes
MatÃ©riaux dynamiques
Lightmaps, HDR, Instancing, IBL
Architecture de scÃ¨nes orientÃ©e ECS

###ğŸš€ Bloc 10 â€” Jeu complet avec ton moteur [ğŸŸ¢ Facile]
Partie 1 Ã  7 : Joueur, ennemis, tirs, HUD
ContrÃ´le camÃ©ra, projectiles, collisions
Effets visuels, menus, HUD
Build final Linux, TDD complet

###ğŸŒŒ Project Zero â€” Jeu spatial 3D
Compilation, RÃ©sultats, Plan dâ€™action, TDD minimal

###ğŸ“¥ Annexe
Contenu additionnel (Bloc 1 fusionnÃ©)
Includes utiles (libft.h, stdio.h, etc.)