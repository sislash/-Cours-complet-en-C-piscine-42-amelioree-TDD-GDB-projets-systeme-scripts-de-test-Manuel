# 📘 Piscine Personnelle - Cursus complet

## Introduction:

Ce document n'est pas qu'un simple recueil d'exercices. Il représente une approche pédagogique complète pour maîtriser la programmation en C, inspirée du modèle de la Piscine de l'ecole 42, mais personnalisée pour un apprentissage approfondit.

Son originalité repose sur une combinaison de facteurs.

Structuré comme une formation professionnelle, Chaque bloc est conçu pour bâtir progressivement des compétences solides, allant des bases aux concepts les plus avancés.
Rédigé avec la bienveillance d’un mentor, Le ton se veut encourageant, clair et orienté vers la réussite de l'apprenant. Les explications sont détaillées mais accessibles, et le parcours est pensé pour minimiser la frustration.
Organisé comme un projet réel, La progression est logique et les compétences acquises sont directement applicables à des projets concrets, préparant ainsi l'apprenant aux défis du monde professionnel.

## 📄 Mentions légales & crédits

-   Auteur : **Megnoux Xavier**
-   Provenance : **belgique , liege**
-   Aide à la rédaction : **ChatGPT — Modèle GPT-4**
-   Document librement consultable et partageable à titre personnel.
-   📌 Non affilié à 42. Utilise des méthodes inspirées de l'école 42 (piscine, TDD, progression, réstriction).
-   Tous les exemples de code sont originaux et générés dans un but pédagogique. Aucun extrait propriétaire ou issu de tiers.

##📜 Licence Personnelle d’Utilisation
Nom du document : Cursus_C_10_ans
Auteur : Megnoux Xavier
Contact : [sckavens@gmail.com]
Date de création : [20-02-2024]
Dernière mise à jour : [08-07-2025]

##🟢 Utilisation autorisée
Ce document est librement utilisable à des fins personnelles, pédagogiques et non commerciales.
Tu peux :

- Le lire, l’étudier et le recopier pour ton apprentissage personnel.
- Le partager gratuitement avec d’autres personnes dans un cadre privé (amis, proches, groupe d’étude).
- L’imprimer pour un usage individuel.

##🔴 Utilisation professionnelle ou commerciale interdite sans autorisation
Toute utilisation professionnelle, académique ou commerciale du présent document est interdite sans l'accord explicite
de l'auteur.
Cela comprend notamment :

- Son usage dans une école, une formation payante, une entreprise ou un centre de formation.
- Toute forme d'intégration à une plateforme éducative, à un site web à but lucratif ou à un programme d’enseignement
    officiel.
- Toute vente, monétisation directe ou indirecte, ou reproduction dans des œuvres publiées.

##📬 Pour toute demande de licence professionnelle, partenariat ou usage élargi :
##➡️ Me contacter directement (voir contact ci-dessus).

##🛠️ Modifications et dérivés
Tu peux adapter le contenu pour ton usage personnel uniquement, mais toute modification ou dérivé destiné à être
partagé (même gratuitement) doit impérativement être soumis à validation préalable auprès de l’auteur.
Usage                                          |Autorisé ?
-----------------------------------------------|-------------------------------------
Amélioration pour soi : autorisée              | ✅ Oui
Modifier et diffuser à d'autres                | 🔒 Non, sans autorisation
Traduire ou inclure dans un projet             | 🔒 Non, sans autorisation

##💼 Mentions obligatoires
Lors de toute copie, adaptation, présentation ou diffusion autorisée du document original ou modifié, les éléments
suivants doivent obligatoirement être mentionnés :

- Le nom de l’auteur original : Megnoux Xavier
- Un lien vers le document source (si en ligne)
- L’indication : "Document original utilisé avec l'autorisation de son auteur"

##⚖️ Clause de respect moral
Le contenu de ce document est fourni dans un but pédagogique et personnel.
Il ne doit pas être dénaturé, détourné de son contexte, ni utilisé pour des pratiques contraires à l’éthique ou à la
bienveillance éducative.

##🔔 **À propos de ce document :**
Ce cursus n'est **pas un cours théorique complet du langage C**. Il repose sur l'idée que l'élève utilise **un ou plusieurs livres de référence** pour apprendre les notions fondamentales (syntaxe, structures, pointeurs, mémoire, etc.).

##🎯 Ce document sert de **guide pratique**, basé sur une approche progressive, rigoureuse, structurée par TDD.
**Chaque exercice introduit un concept du C par la pratique**, mais il ne le détaille pas toujours en profondeur.  

##📚 L'élève est invité à se référer à ses livres pour :
- Les boucles `while`, `for`
- Les conditions `if`, `else`
- La gestion de la mémoire (`malloc`, `free`)
- Les conversions ASCII ➝ int
- La manipulation des pointeurs
- Les structures, fonctions, etc.

##Exemples de livres compatibles :
- *Le langage C* – Brian W. Kernighan & Dennis M. Ritchie
- *Apprendre à programmer en C* – Claude Delannoy
- *C Programming: A Modern Approach* – K. N. King

##🧠 Le but ici est de **mettre en pratique immédiatement** ce que tu apprends dans ces ouvrages, grâce à une **progression claire**, une **structure TDD** et des **scripts de test automatisés**.

## 🎯 Objectif du document

Créer une formation autonome, progressive, et complète pour apprendre la programmation système en langage 'C', en partant de zéro jusqu'à des compétences de niveau master.

Ce cours intègre :

-   Le langage **C standard** + normes 42
-   Les outils professionnels : **Makefile**, **test.sh**, **Git**, **GDB**, **arborescence claire**
-   Des projets à long terme : **norminette**, **moulinette**, **jeu ASCII**,
    **reverseengineering**, **shell**, **mini-projet graphique**
-   Des exercices **corrigés**, **guidés**, et **annotés** (TDD, debug, réflexion)
-   Un chemin balisé (blocs + progression + fiches de suivi)
-   Des **bonus en assembleur et reverse engineering** pour approfondir le bas niveau

## 🔧 Préparation : outils nécessaires
Tu n’as besoin que d’un **terminal Unix/Linux** et d’un éditeur de texte. Aucun IDE.

### 🧰 Outils utilisés dans ce document
-   **`gcc`** : le compilateur C standard.
-   **`make`** : pour automatiser la compilation.
-   **`git`** : pour le contrôle de version.
-   **`gdb`** : le débogueur.
-   **`man`** : pour consulter les pages de manuel.
-   **`norminette`** (si tu suis les normes 42) : pour vérifier le style du code.

### ⚙️ Installation (Debian/Ubuntu)
```bash
sudo apt update
sudo apt install build-essential git manpages-dev
```

### 📁 Structure des fichiers
Chaque exercice suit une structure de répertoire précise pour faciliter le TDD (Test-Driven Development) et
l'organisation.

```bash
├──ex00/
│   ├── include/
│   │   └── ft_putchar.h
│   ├── src/
│   │   └── ft_putchar.c
│   └── test/
│         ├── expected.txt
│         ├── main.c
│         └── test.sh
├── ex01
│   ├── include
│   │   └── ft_print_alphabet.h
│   ├── src
│   │   └── ft_print_alphabet.c
│   └── test
│         ├── expected.txt
│         ├── main.c
│         └── test.sh
└── Makefile
```

- exXX/ : Un répertoire par exercice.
- exXX/include/ : Contient les fichiers d'en-tête (.h) pour les prototypes de fonctions.
- exXX/src/ : Contient les fichiers source (.c) de tes fonctions.
- exXX/test/ : Contient le code de test (main.c), le résultat attendu (expected.txt), et le script
  de test (test.sh).
- Makefile (à la racine) : Pour compiler tous les exercices.

## 🧭 Sommaire
1. 🚀 Bloc 1 [🟢 Facile]: Les Fondamentaux en C
2. 📦 Bloc 2 [🟢 Facile]: Libft++ et Fonctions standard
3. 🔄 Bloc 3 [🟡 Intermédiaire]: Get Next Line, Parsing et Buffers
4. 🧵 Bloc 4 [🟡 Intermédiaire]: Pipex et manipulation de processus
5. 🐚 Bloc 5 [🟠 Avancé]: Minishell & analyse syntaxique avancée
6. 🎨 Année 2 [🟠 Avancé]: Graphisme et réseau (Cub3D++, MiniRT++)
7. 💻 Année 3 [🔴 Très avancé]: Moteur, FS, Shell avancé
8. 🧠 Années 4-5 [🔴 Très avancé]: OS, compilateurs, sécurité
9. 🛠️ Années 6-10 [🔴🔴 Expert]: OS perso, automation, CI/CD, Norminette++

══════════════════════════════════════════════════════════════════════════
# Piscine Boostée - Bloc 1 (Partie 1/5) [🟢 Facile]
══════════════════════════════════════════════════════════════════════════

##Introduction :##
Bienvenue dans ta Piscine Boostée personnelle.
Tu dois :

- Réfléchis par toi-même.
- Ne pas recopier.
- Commencer doucement à tester ton code (TDD minimal).
- Respecter la norme stricte établie.
- Utiliser une structure de projet propre dès que possible.
- au-dessus de chaque fichiers .c et .h tu devras placer un header.

/* ***************************************************************************/
/*                                                                           */ 
/* nom_du_fichier.c                                                          */
/*                                                                           */
/* By: prenom.nom@email.com                                                  */
/*                                                                           */
/* Created: AAAA/MM/JJ HH:MM:SS by prenom.nom                                */
/* Updated: AAAA/MM/JJ HH:MM:SS by prenom.nom                                */
/*                                                                           */
/* ***************************************************************************/

[Rappel] important pour l'organisation de ton code
À respecter dès l'exercice 1 :

[Rappel] Structure des fichiers pour ex00
Chaque exercice suit une structure de répertoire précise pour faciliter le TDD (Test-Driven Development) et l'organisation.

```bash
├──ex00/
│   ├── include/
│   │   └── ft_putchar.h
│   ├── src/
│   │   └── ft_putchar.c
│   └── test/
│         ├── expected.txt
│         ├── main.c
│         └── test.sh
├── ex01
│   ├── include
│   │   └── ft_print_alphabet.h
│   ├── src
│   │   └── ft_print_alphabet.c
│   └── test
│         ├── expected.txt
│         ├── main.c
│         └── test.sh
└── Makefile
```

-------------------------------------------------
##exercice_test_environement - préparatoire — ft_success
-------------------------------------------------

###Objectif :###
Avant d’écrire la moindre fonction, tu vas :
- Vérifier que ton Makefile fonctionne
- Structurer correctement ton dossier
- Compiler un petit projet C simple
- Exécuter un script de test (test.sh)
- Apprendre la logique du TDD le plus basique possible
- C’est un test de préparation, comme un check système avant le vrai décollage.

Ce que tu dois avoir à la fin :
Une arborescence propre.

```css
ex00-preparatoire/
├── include/
│   └── ft_success.h
├── src/
│   └── ft_success.c
├── test/
│   ├── main.c
│   ├── expected.txt
│   └── test.sh
└── Makefile
```

Code source minimal :
include/ft_success.h

```c
#ifndef FT_SUCCESS_H
# define FT_SUCCESS_H

int ft_success(void);

#endif
```

src/ft_success.c

```c
int ft_success(void)
{
    return (0);
}
```

test/main.c

```c
#include "../include/ft_success.h"
#include <stdio.h>

int main(void)
{
    if (ft_success() == 0)
    {
        printf("SUCCESS\n");
        return (0);
    }
    else
    {
        printf("FAIL\n");
        return (1);
    }
}
```

test/expected.txt
```sh
SUCCESS
```

test/test.sh
```bash
#!/bin/bash

# Couleurs
GREEN="\033[0;32m"
RED="\033[0;31m"
NC="\033[0m" # No Color

# Compilation
gcc -Wall -Wextra -Werror -Iinclude src/ft_success.c test/main.c -o success_test

# Exécution
./success_test > test/output.txt

# Comparaison
if diff test/output.txt test/expected.txt > /dev/null; then
    echo -e "${GREEN} ft_success : Test réussi${NC}"
    rm -f test/output.txt success_test
    exit 0
else
    echo -e "${RED} ft_success : Échec du test${NC}"
    echo "Contenu obtenu :"
    cat test/output.txt
    echo "Attendu :"
    cat test/expected.txt
    rm -f test/output.txt success_test
    exit 1
fi
```

Makefile (version locale pour ex00-preparatoire uniquement)
```makefile
NAME = success_test

CC = gcc
CFLAGS = -Wall -Wextra -Werror

SRC = src/ft_success.c
TEST = test/main.c
INCLUDES = -Iinclude

all: $(NAME)

$(NAME): $(SRC) $(TEST)
	$(CC) $(CFLAGS) $(INCLUDES) $(SRC) $(TEST) -o $(NAME)

test: all
	@chmod +x test/test.sh
	@./test/test.sh

clean:
	rm -f $(NAME) test/output.txt

fclean: clean

re: fclean all

.PHONY: all clean fclean re test
```

###Bulle pédagogique :###
Avant d'apprendre à écrire une fonction, tu dois apprendre à écrire un projet propre.
Ce test est là pour te rassurer : tout fonctionne OK. Maintenant, tu peux y aller sereinement !

Petit conseil bonus.
Si tu as un message d'erreur pendant l'exécution :
- Vérifie tes droits sur test.sh (chmod +x test.sh)
- Vérifie les chemins (../include, ../src…)
- Lance `make test` à la racine du dossier

###Résultat attendu en lançant:###

```bash
make test
```

Tu dois voir :

ft_success : Test réussi

-------------------------------------------------
## 0.0.0) ex00: ft_putchar
-------------------------------------------------

###Le but :###  
Afficher un seul caractère sur la sortie standard.

C’est ton tout premier exercice en langage C.  
Tu vas apprendre à **parler directement à l’ordinateur** en lui envoyant une lettre à afficher.  
Ce sera le début de ta communication avec le système.

###prototype :###
include/ft_putchar.h

```c
#ifndef FT_PUTCHAR_H
# define FT_PUTCHAR_H

# include <unistd.h> // Nécessaire pour la déclaration de write() (man 2 write)

void ft_putchar(char c);

#endif // FT_PUTCHAR_H
```

src/ft_putchar.c

```c
#include <unistd.h>

void ft_putchar(char c)
{
    write(1, &c, 1);
}
```

###Explication :###
Tu dois écrire directement sur la sortie standard (l'écran) en utilisant une fonction système de bas niveau.

La fonction write() est un appel système (low-level) qui te permet d’écrire des données dans un fichier ou vers l’écran.

```c
write(1, &c, 1);
Élément	Signification
1	descripteur de sortie standard
&c	adresse du caractère à écrire
1	nombre d’octets à écrire (1)
```

Petit rappel sur les descripteurs de fichier.
Chaque programme en C (sous Unix/Linux) utilise 3 descripteurs standards dès son lancement :

```c
write(fd, &c, 1);
fd (file descriptor)	Utilisation par défaut
0	Entrée standard (clavier)
1	Sortie standard (écran)
2	Sortie d’erreur standard
```

Cela signifie que :
write(1, &c, 1); écrit à l’écran
write(2, &msg, len); affiche une erreur
read(0, &buf, n); lit depuis le clavier

###Interdictions :###
Interdit	           | Raison
-----------------------|-------------------------------------------------------------
- `printf`             | Fonction plus haut niveau, non autorisée ici.
- `puts`	           | Idem, elle ajoute un retour à la ligne automatiquement.
- `putchar`            | Tu es en train de la coder toi-même !

Tu dois uniquement utiliser write.

###Bulle d'ami :###
"Ton premier dialogue avec l'ordinateur : lui écrire un caractère directement. C’est brut, direct, efficace."

###Mini-TDD :###
Écris un test simple pour vérifier que ton ft_putchar affiche bien un caractère.

TDD — Qu'est-ce que c'est exactement ?
TDD signifie Test-Driven Development (Développement dirigé par les tests).

Principe :
- Écris un test qui échoue (car le code n’existe pas encore).
- Écris juste assez de code pour que le test passe OK.
- Améliore ton code si nécessaire (refactorisation), tout en gardant les tests verts.

Avantage	       |Explication
-------------------|----------------------------------------------------------------
Moins de bugs	   | Tu détectes immédiatement les erreurs
Code plus clair	   | Tu te concentres sur ce qui est attendu
Confiance	       | Tu sais que ton code fonctionne, même après une modif
Discipline	       | Tu avances petit à petit, de façon propre

###Exemple de test :###
test_putchar.c

```c
#include <unistd.h>

/*Déclaration de la fonction à tester*/

void ft_putchar(char c);

int main(void)
{
    // Test simple
    ft_putchar('A');
    write(1, "\n", 1); // Retour à la ligne

    // Test attendu : est-ce que 'A' s'affiche ?
    // (Pas automatique ici : c'est visuel, mais on peut capturer la sortie plus tard)

    return 0;
}
```

###Étapes TDD :###
1️. Lance le test ➜ Il échoue si ft_putchar n’est pas codée
2️. Implémente le code minimal pour que le test réussisse
3️. Relance le test ➜ Tu dois voir :

```txt
A
```

Bravo ! Test validé.

###Résumé rapide :###
Cycle du TDD Étape de ce que tu fais
Échec du test	Tu sais que tu dois coder
Succès du test	Ton implémentation est correcte
Refactorisation	Tu peux améliorer sans casser

###Remarque importante :###
Un "test", au début, c’est juste écrire un petit main.c qui vérifie le résultat attendu, sans framework compliqué.

Mini-TDD conseillé pour ft_putchar
Test	                | Attendu
------------------------|----------------------------------
ft_putchar('Z');	    | Affiche Z
ft_putchar('0');	    | Affiche 0
ft_putchar('\n');	    | Affiche un retour à la ligne

###Maintenant TDD un peu plus complexe ! :###
TDD (Test-Driven Development) en vrai
Le TDD consiste à écrire les tests avant le code.

1. Fichier de test — test/main.c

```c
#include "../include/ft_putchar.h" // Inclut ton fichier d'en-tête

int main(void) {
    ft_putchar('A');
    ft_putchar('\n'); // Ajout d'un retour à la ligne pour une meilleure visualisation
    return 0;
}
```

2. Fichier attendu — test/expected.txt

```txt
A
```

3. Script de test — test/test.sh

```bash
#!/bin/bash

# Compiler le programme de test
gcc -Wall -Wextra -Werror -Iinclude src/ft_putchar.c test/main.c -o ex00_test

# Exécuter le programme et rediriger sa sortie vers un fichier temporaire
./../ex00_test > test/output.txt

# Comparer la sortie avec le fichier attendu
diff test/output.txt test/expected.txt > /dev/null

# Vérifier le code de retour de diff
if [ $? -eq 0 ]; then
    echo "ex00: Test réussi"
else
    echo "ex00: Erreur - La sortie ne correspond pas à l'attendu"
fi

# Nettoyer les fichiers temporaires
rm -f ex00_test test/output.txt
```

###Exécution du test :###
Dans ton terminal :

```bash
cd ex00
./test/test.sh
```

###Compilation :###
Tu dois avoir un Makefile à la racine de ton projet pour gérer la compilation de tous tes exercices.

Makefile — racine du projet

```makefile
# Makefile
# Ce Makefile est à placer à la racine de ton projet (au même niveau que le répertoire ex00)

CC = gcc

NAME = piscine

# Liste de tous les répertoires d'exercice à compiler et tester
EXERCICES = ex00 ex01

SRC_ex00 = ft_putchar
SRC_ex01 = ft_print_alphabet

CFLAGS = -Wall -Wextra -Werror

# Option de debuggage
DEBUG = -g

# Fonction pour compiler un exercice donné
define compile_exercise
	@echo "Compiling $1..."
	$(CC) $(CFLAGS) -I$1/include $1/src/$(eval SRC_FILE := $(SRC_$1))$(SRC_FILE).c $1/test/main.c -o $1_test
endef

# Compilation de tous les exercices
all: $(EXERCICES)

# Compilation individuelle de chaque exercice
$(EXERCICES):
	$(call compile_exercise,$@)

# Nettoyage des exécutables et fichiers temporaires
clean:
	@echo "cleaning up..."
	rm -f $(EXERCICES:%=%_test)
	@find . -name "*.out" -delete
	@rm -f */test/output.txt
	@rm -f *.o

# Exécution de tous les tests
test: clean all
	@echo "Running all test..."
	@for dir in $(EXERCICES); do \
		if [ -f $$dir/test/test.sh ]; then \
			cd $$dir && ./test/test.sh && cd - > /dev/null; \
		else \
			echo "Skipping test for $$dir: test/test.sh not found."; \
		fi; \
	done

.PHONY: all clean test $(EXERCICES)
```

###Pour compiler ex00 :###
Depuis la racine de ton projet :

```bash
make ex00
```

Ceci créera un exécutable ex00_test.

Challenge complémentaire (si tu veux aller plus loin)
Affiche une ligne complète avec plusieurs appels à ft_putchar (ex : "HELLO\n")
Crée un test avec un caractère spécial ('\t', '\n', '@')
Essaie d'afficher un caractère à partir de son code ASCII :

```c
ft_putchar(65); // devrait afficher 'A'
```

###Petit quiz mental :###
Que va afficher ce code ?

```c
ft_putchar('A' + 1);
```

Réponse : Il affiche B, car 'A' + 1 donne le caractère suivant.

Voilà, tu viens de réussir ton premier programme C testable, structuré et propre.
C’est le premier bloc fondamental de ta progression. Bravo ! 

-------------------------------------------------
## 0.0.1) ex01: ft_print_alphabet
-------------------------------------------------

###Le but :###
Afficher toutes les lettres minuscules de l'alphabet en ordre croissant.

###Prototype :###

```c
void ft_print_alphabet(void);
```

###Explication :###
On utilise un caractère `char` initialisé à `'a'` et une boucle `while` ou `for` jusqu'à `'z'`.  
À chaque itération, on affiche la lettre courante avec `write(1, &c, 1)`, puis on incrémente le
caractère.

###Interdictions :###
- Pas de printf
- Pas de puts
- Pas de boucle interdite, mais pas de fonction de lib standard non plus.
- Utiliser uniquement write

###Bulle d'ami :###
"Apprends à répéter des actions simples pour construire de grands résultats."

###Mini-TDD :###
Crée un programme test qui appelle `ft_print_alphabet()` puis redirige la sortie dans un fichier.  
Compare-le avec un fichier attendu contenant :  

`abcdefghijklmnopqrstuvwxyz`

###Exemple de TDD complet :###
1️. Fichier de test (test/main.c)

test/main.c
```c

#include "../include/ft_print_alphabet.h"

int main(void)
{
  ft_print_alphabet();
  return 0;
}
```
2️. Fichier attendu (test/expected.txt)

abcdefghijklmnopqrstuvwxyz

3️. Script de test automatique (test/test.sh)

```bash
#!/bin/bash

# Compiler dans build.sh "astuce faite `watch -n 0.5 ./build.sh`, pour une compilation automatique".  
gcc -Wall -Wextra -Werror -Iinclude src/ft_print_alphabet.c test/main.c -o ex01_test

# Exécuter et rediriger la sortie
./ex01_test > test/output.txt

# Comparer
diff test/output.txt test/expected.txt > /dev/null

# Affichage résultat
if [ $? -eq 0 ]; then
    echo "ex01: Test réussi"
else
    echo "ex01: Test échoué"
fi

# Nettoyage
rm -f ex01_test test/output.txt
```

4️. Compilation avec Makefile
Ajoute dans ton Makefile à la racine :

```makefile
EXERCISES = ex00 ex01
SRC_ex01 = ft_print_alphabet
```

###Cycle TDD résumé :###
Étape Action
1. Écris un test test/main.c
2. Code minimal ft_print_alphabet.c
3. Test OK ?
4. Refacto si besoin  (par exemple : meilleur nom de variable, clarté)

###Bonus :###
Tester plusieurs fois d'affilée

```bash
cd ex01
./test/test.sh
```

###Ou depuis la racine :###
```bash
make ex01 && ./ex01_test
```

-------------------------------------------------
## 0.0.2) ex02: ft_print_reverse_alphabet
-------------------------------------------------

###Le but :###
Afficher l'alphabet minuscule en ordre décroissant.

###Prototype :###

```c
void ft_print_reverse_alphabet(void);
```

###Explication :###
On initialise un caractère `char c = 'z'`.  
Tant que `c >= 'a'`, on l'affiche avec `write(1, &c, 1)` puis on décrémente avec `c--`.

###Interdictions :###
- Pas de printf
- Seulement write

###Bulle d'ami :###
"Penser en arrière est parfois la meilleure façon d'avancer."

###Mini-TDD :###
Crée un test qui appelle la fonction, redirige la sortie standard dans un fichier,  
puis vérifie que ce fichier contient bien :  
`zyxwvutsrqponmlkjihgfedcba`

###TDD complet :###
pour ft_print_reverse_alphabet
1️. Fichier de test (test/main.c)

test/main.c
```c
#include "../include/ft_print_reverse_alphabet.h"

int main(void)
{
  ft_print_reverse_alphabet();
  return 0;
}
```

2️. Fichier attendu (test/expected.txt)

```txt
zyxwvutsrqponmlkjihgfedcba
```

3️. Script de test automatique (test/test.sh)

```bash
#!/bin/bash

# Compiler
gcc -Wall -Wextra -Werror -Iinclude src/ft_print_reverse_alphabet.c test/main.c -o ex02_test

# Exécuter et rediriger la sortie
./ex02_test > test/output.txt

# Comparer
diff test/output.txt test/expected.txt > /dev/null

# Résultat
if [ $? -eq 0 ]; then
    echo "ex02: Test réussi"
else
    echo "ex02: Test échoué"
fi

# Nettoyage
rm -f ex02_test test/output.txt
```

###Entrée dans le Makefile principal :###
Ajoute dans ton Makefile ce qu'il manque pour compiler.

###Tester manuellement :###

```bash
cd ex02
./test/test.sh
```

###Résumé TDD :###
Étape Description
1️. Écris le test (main.c)  Avant de coder
2️. Implémente la fonction  Code minimal
3️. Lancer test.sh  Valider comportement
4️. Refacto ou extension  Si besoin

-------------------------------------------------
## 0.0.3) ex03: ft_print_numbers
-------------------------------------------------

###Le but :###
Afficher tous les chiffres de 0 à 9.

###Prototype :###
```c
void ft_print_numbers(void);
```

###Explication :###
On initialise une variable `char c = '0'`.  
Tant que `c <= '9'`, on affiche chaque chiffre avec `write(1, &c, 1)` puis on incrémente `c`.
Chaque chiffre est un caractère affiché individuellement.

###Interdictions :###
- Pas de printf
- Seulement write

###Bulle d'ami :###
"Chaque chiffre est juste un petit caractère, pense en ASCII."

###Mini-TDD :###
Crée un fichier de test qui appelle `ft_print_numbers()` puis redirige la sortie standard vers un
fichier.
Compare ensuite ce fichier à un `expected.txt` contenant :  
`0123456789`

###TDD complet :###
pour ft_print_numbers

2️. Fichier attendu (test/expected.txt)

0123456789

3️. Script de test automatique (test/test.sh)

```bash
#!/bin/bash

# Compiler
gcc -Wall -Wextra -Werror -Iinclude src/ft_print_numbers.c test/main.c -o ex03_test

# Exécuter et rediriger la sortie
./ex03_test > test/output.txt

# Comparer
diff test/output.txt test/expected.txt > /dev/null

# Résultat
if [ $? -eq 0 ]; then
    echo "ex03: Test réussi"
else
    echo "ex03: Test échoué"
fi

# Nettoyage
rm -f ex03_test test/output.txt
```

###Entrée dans le Makefile principal :###
Ajoute dans ton Makefile ce qu'il manque pour compiler.

###Tester manuellement :###

```bash
cd ex03
./test/test.sh
```

###Résumé TDD :###
Étape Description
1️. Écris le test (main.c)  Avant d’implémenter
2️. Implémente la fonction  Boucle simple
3️. Exécute test.sh Vérifie le résultat
4️. Refacto possible  Si besoin

-------------------------------------------------
## 0.0.4) ex04: ft_is_negative
-------------------------------------------------

###Le but :###
Afficher 'N' si le nombre est négatif, sinon 'P' pour positif ou nul.

###Prototype :###

```c
void ft_is_negative(int n);
```

###Explication :###
Utiliser une simple condition pour tester la valeur du nombre.
Si la valeur n est inférieure à 0, on affiche 'N'.
Sinon (n ≥ 0), on affiche 'P'.
On utilise write(1, &c, 1) pour afficher un seul caractère.

###Interdictions :###
- Pas de printf
- Utiliser uniquement write

###Bulle d'ami :###
"Comparer, c'est trier le monde en deux: les positifs et les négatifs."

###Mini-TDD :###
Crée un programme de test qui appelle ft_is_negative() avec :
>un nombre négatif → affiche N
>zéro → affiche P
>un nombre positif → affiche P

###TDD complet :###
1️. Fichier de test (test/main.c)

// test/main.c
```c
#include "../include/ft_is_negative.h"

int main(void)
{
  ft_is_negative(-1);  // Devrait afficher N
  write(1, "\n", 1);
  ft_is_negative(0);   // Devrait afficher P
  write(1, "\n", 1);
  ft_is_negative(83);  // Devrait afficher P
  write(1, "\n", 1);
  return 0;
}
```
2. Fichier attendu (test/expected.txt)

```txt
N
P
P
```

3️. Script de test automatique (test/test.sh)
Oublie pas de créer le fichier et l'entrée dans le Makefile principal.

###Exécution du test :###

```bash
cd ex04
./test/test.sh
```

-------------------------------------------------
## 0.0.5) ex05: ft_print_comb
-------------------------------------------------

###Le but :###
Afficher toutes les combinaisons de 3 chiffres différents triés par ordre croissant.

###Prototype :###

```c
void ft_print_comb(void);
```

###Explication :###
Combiner trois chiffres en évitant les répétitions.
On utilise trois boucles imbriquées :
  >i de '0' à '7'
  >j de i + 1 à '8'
  >k de j + 1 à '9'
À chaque itération, on affiche les trois chiffres avec write,
suivis de ", " sauf pour la dernière combinaison 789.

###Interdictions :###
- Pas de printf
- write uniquement

###Bulle d'ami :###
"Chaque chiffre doit être plus grand que le précédent."

###Mini-TDD :###
- Crée un test qui redirige la sortie de ft_print_comb() vers un fichier,
- puis vérifie qu’il contient exactement 120 combinaisons dans l’ordre croissant,
- ex : 012, 013, ..., 789 (sans virgule finale).
- la comparaison diff est sensible aux espaces finaux et retours à la ligne
- certaines sorties peuvent être longues et doivent être tronquées dans expected.txt avec head -n 1 ou équivalent si
  besoin.

###TDD complet :###

1. Fichier attendu (test/expected.txt)
Contenu à générer automatiquement (ou copier manuellement depuis l'exécution correcte une fois) :

012, 013, 014, 015, 016, 017, 018, 019, 023, 024, 025, 026, 027, 028, 029, 034, 035, 036, 037, 038, 039, 045, 046, 047, 048, 049, 056, 057, 058, 059, 067, 068, 069, 078, 079, 089, 123, 124, 125, 126, 127, 128, 129, 134, 135, 136, 137, 138, 139, 145, 146, 147, 148, 149, 156, 157, 158, 159, 167, 168, 169, 178, 179, 189, 234, 235, 236, 237, 238, 239, 245, 246, 247, 248, 249, 256, 257, 258, 259, 267, 268, 269, 278, 279, 289, 345, 346, 347, 348, 349, 356, 357, 358, 359, 367, 368, 369, 378, 379, 389, 456, 457, 458, 459, 467, 468, 469, 478, 479, 489, 567, 568, 569, 578, 579, 589, 678, 679, 689, 789

(Pas de retour à la ligne à la fin si on veut comparer à l’identique)

Script de test.
Oublie pas le Makefile.

###Exécution du test :###

```bash
cd ex05
./test/test.sh
```

-------------------------------------------------
## 0.0.6) ex06: ft_print_comb2
-------------------------------------------------

###Le but :###
Afficher toutes les combinaisons possibles de deux nombres à deux chiffres (00 01 à 98 99), triées, séparées par ", " (sauf la dernière).

###Prototype :###

```c
void ft_print_comb2(void);
```

###Explication :###
Comparer deux nombres de 00 à 99 et afficher ceux dans le bon ordre.
On utilise deux boucles i et j allant de 0 à 99.
Pour chaque paire (i, j), si i < j, on affiche la combinaison avec le bon format (00 01).
Chaque nombre est affiché avec deux chiffres (ajouter '0' si nécessaire).
Chaque combinaison est séparée par ", " sauf la dernière (98 99).

###Interdictions :###
Pas de printf
write uniquement

###Bulle d'ami :###
"Chaque nombre est une paire, traite-les comme un duo inséparable."

###Mini-TDD :###
Crée un test qui redirige la sortie de ft_print_comb2() vers un fichier.
Le fichier doit contenir 4950 combinaisons allant de 00 01 à 98 99,
séparées par ", ", sans virgule finale à la fin.

###TDD :###

1. Fichier attendu (test/expected.txt)
Ce fichier contient une seule ligne générée avec :

test/expected.txt

00 01, 00 02, 00 03, 00 04, 00 05, 00 06, 00 07, 00 08, 00 09, 00 10, 00 11, 00 12, 00 13, 00 14, 00 15, 00 16, 00 17, 00 18, 00 19, 00 20, 00 21, 00 22, 00 23, 00 24, 00 25, 00 26, 00 27, 00 28, 00 29, 00 30, 00 31, 00 32, 00 33, 00 34, 00 35, 00 36, 00 37, 00 38, 00 39, 00 40, 00 41, 00 42, 00 43, 00 44, 00 45, 00 46, 00 47, 00 48, 00 49, 00 50, 00 51, 00 52, 00 53, 00 54, 00 55, 00 56, 00 57, 00 58, 00 59, 00 60, 00 61, 00 62, 00 63, 00 64, 00 65, 00 66, 00 67, 00 68, 00 69, 00 70, 00 71, 00 72, 00 73, 00 74, 00 75, 00 76, 00 77, 00 78, 00 79, 00 80, 00 81, 00 82, 00 83, 00 84, 00 85, 00 86, 00 87, 00 88, 00 89, 00 90, 00 91, 00 92, 00 93, 00 94, 00 95, 00 96, 00 97, 00 98, 00 99, 01 02, 01 03, 01 04, 01 05, 01 06, 01 07, 01 08, 01 09, 01 10, 01 11, 01 12, 01 13, 01 14, 01 15, 01 16, 01 17, 01 18, 01 19, 01 20, 01 21, 01 22, 01 23, 01 24, 01 25, 01 26, 01 27, 01 28, 01 29, 01 30, 01 31, 01 32, 01 33, 01 34, 01 35, 01 36, 01 37, 01 38, 01 39, 01 40, 01 41, 01 42, 01 43, 01 44, 01 45, 01 46, 01 47, 01 48, 01 49, 01 50, 01 51, 01 52, 01 53, 01 54, 01 55, 01 56, 01 57, 01 58, 01 59, 01 60, 01 61, 01 62, 01 63, 01 64, 01 65, 01 66, 01 67, 01 68, 01 69, 01 70, 01 71, 01 72, 01 73, 01 74, 01 75, 01 76, 01 77, 01 78, 01 79, 01 80, 01 81, 01 82, 01 83, 01 84, 01 85, 01 86, 01 87, 01 88, 01 89, 01 90, 01 91, 01 92, 01 93, 01 94, 01 95, 01 96, 01 97, 01 98, 01 99, 02 03, 02 04, 02 05, 02 06, 02 07, 02 08, 02 09, 02 10, 02 11, 02 12, 02 13, 02 14, 02 15, 02 16, 02 17, 02 18, 02 19, 02 20, 02 21, 02 22, 02 23, 02 24, 02 25, 02 26, 02 27, 02 28, 02 29, 02 30, 02 31, 02 32, 02 33, 02 34, 02 35, 02 36, 02 37, 02 38, 02 39, 02 40, 02 41, 02 42, 02 43, 02 44, 02 45, 02 46, 02 47, 02 48, 02 49, 02 50, 02 51, 02 52, 02 53, 02 54, 02 55, 02 56, 02 57, 02 58, 02 59, 02 60, 02 61, 02 62, 02 63, 02 64, 02 65, 02 66, 02 67, 02 68, 02 69, 02 70, 02 71, 02 72, 02 73, 02 74, 02 75, 02 76, 02 77, 02 78, 02 79, 02 80, 02 81, 02 82, 02 83, 02 84, 02 85, 02 86, 02 87, 02 88, 02 89, 02 90, 02 91, 02 92, 02 93, 02 94, 02 95, 02 96, 02 97, 02 98, 02 99, 03 04, 03 05, 03 06, 03 07, 03 08, 03 09, 03 10, 03 11, 03 12, 03 13, 03 14, 03 15, 03 16, 03 17, 03 18, 03 19, 03 20, 03 21, 03 22, 03 23, 03 24, 03 25, 03 26, 03 27, 03 28, 03 29, 03 30, 03 31, 03 32, 03 33, 03 34, 03 35, 03 36, 03 37, 03 38, 03 39, 03 40, 03 41, 03 42, 03 43, 03 44, 03 45, 03 46, 03 47, 03 48, 03 49, 03 50, 03 51, 03 52, 03 53, 03 54, 03 55, 03 56, 03 57, 03 58, 03 59, 03 60, 03 61, 03 62, 03 63, 03 64, 03 65, 03 66, 03 67, 03 68, 03 69, 03 70, 03 71, 03 72, 03 73, 03 74, 03 75, 03 76, 03 77, 03 78, 03 79, 03 80, 03 81, 03 82, 03 83, 03 84, 03 85, 03 86, 03 87, 03 88, 03 89, 03 90, 03 91, 03 92, 03 93, 03 94, 03 95, 03 96, 03 97, 03 98, 03 99, 04 05, 04 06, 04 07, 04 08, 04 09, 04 10, 04 11, 04 12, 04 13, 04 14, 04 15, 04 16, 04 17, 04 18, 04 19, 04 20, 04 21, 04 22, 04 23, 04 24, 04 25, 04 26, 04 27, 04 28, 04 29, 04 30, 04 31, 04 32, 04 33, 04 34, 04 35, 04 36, 04 37, 04 38, 04 39, 04 40, 04 41, 04 42, 04 43, 04 44, 04 45, 04 46, 04 47, 04 48, 04 49, 04 50, 04 51, 04 52, 04 53, 04 54, 04 55, 04 56, 04 57, 04 58, 04 59, 04 60, 04 61, 04 62, 04 63, 04 64, 04 65, 04 66, 04 67, 04 68, 04 69, 04 70, 04 71, 04 72, 04 73, 04 74, 04 75, 04 76, 04 77, 04 78, 04 79, 04 80, 04 81, 04 82, 04 83, 04 84, 04 85, 04 86, 04 87, 04 88, 04 89, 04 90, 04 91, 04 92, 04 93, 04 94, 04 95, 04 96, 04 97, 04 98, 04 99, 05 06, 05 07, 05 08, 05 09, 05 10, 05 11, 05 12, 05 13, 05 14, 05 15, 05 16, 05 17, 05 18, 05 19, 05 20, 05 21, 05 22, 05 23, 05 24, 05 25, 05 26, 05 27, 05 28, 05 29, 05 30, 05 31, 05 32, 05 33, 05 34, 05 35, 05 36, 05 37, 05 38, 05 39, 05 40, 05 41, 05 42, 05 43, 05 44, 05 45, 05 46, 05 47, 05 48, 05 49, 05 50, 05 51, 05 52, 05 53, 05 54, 05 55, 05 56, 05 57, 05 58, 05 59, 05 60, 05 61, 05 62, 05 63, 05 64, 05 65, 05 66, 05 67, 05 68, 05 69, 05 70, 05 71, 05 72, 05 73, 05 74, 05 75, 05 76, 05 77, 05 78, 05 79, 05 80, 05 81, 05 82, 05 83, 05 84, 05 85, 05 86, 05 87, 05 88, 05 89, 05 90, 05 91, 05 92, 05 93, 05 94, 05 95, 05 96, 05 97, 05 98, 05 99, 06 07, 06 08, 06 09, 06 10, 06 11, 06 12, 06 13, 06 14, 06 15, 06 16, 06 17, 06 18, 06 19, 06 20, 06 21, 06 22, 06 23, 06 24, 06 25, 06 26, 06 27, 06 28, 06 29, 06 30, 06 31, 06 32, 06 33, 06 34, 06 35, 06 36, 06 37, 06 38, 06 39, 06 40, 06 41, 06 42, 06 43, 06 44, 06 45, 06 46, 06 47, 06 48, 06 49, 06 50, 06 51, 06 52, 06 53, 06 54, 06 55, 06 56, 06 57, 06 58, 06 59, 06 60, 06 61, 06 62, 06 63, 06 64, 06 65, 06 66, 06 67, 06 68, 06 69, 06 70, 06 71, 06 72, 06 73, 06 74, 06 75, 06 76, 06 77, 06 78, 06 79, 06 80, 06 81, 06 82, 06 83, 06 84, 06 85, 06 86, 06 87, 06 88, 06 89, 06 90, 06 91, 06 92, 06 93, 06 94, 06 95, 06 96, 06 97, 06 98, 06 99, 07 08, 07 09, 07 10, 07 11, 07 12, 07 13, 07 14, 07 15, 07 16, 07 17, 07 18, 07 19, 07 20, 07 21, 07 22, 07 23, 07 24, 07 25, 07 26, 07 27, 07 28, 07 29, 07 30, 07 31, 07 32, 07 33, 07 34, 07 35, 07 36, 07 37, 07 38, 07 39, 07 40, 07 41, 07 42, 07 43, 07 44, 07 45, 07 46, 07 47, 07 48, 07 49, 07 50, 07 51, 07 52, 07 53, 07 54, 07 55, 07 56, 07 57, 07 58, 07 59, 07 60, 07 61, 07 62, 07 63, 07 64, 07 65, 07 66, 07 67, 07 68, 07 69, 07 70, 07 71, 07 72, 07 73, 07 74, 07 75, 07 76, 07 77, 07 78, 07 79, 07 80, 07 81, 07 82, 07 83, 07 84, 07 85, 07 86, 07 87, 07 88, 07 89, 07 90, 07 91, 07 92, 07 93, 07 94, 07 95, 07 96, 07 97, 07 98, 07 99, 08 09, 08 10, 08 11, 08 12, 08 13, 08 14, 08 15, 08 16, 08 17, 08 18, 08 19, 08 20, 08 21, 08 22, 08 23, 08 24, 08 25, 08 26, 08 27, 08 28, 08 29, 08 30, 08 31, 08 32, 08 33, 08 34, 08 35, 08 36, 08 37, 08 38, 08 39, 08 40, 08 41, 08 42, 08 43, 08 44, 08 45, 08 46, 08 47, 08 48, 08 49, 08 50, 08 51, 08 52, 08 53, 08 54, 08 55, 08 56, 08 57, 08 58, 08 59, 08 60, 08 61, 08 62, 08 63, 08 64, 08 65, 08 66, 08 67, 08 68, 08 69, 08 70, 08 71, 08 72, 08 73, 08 74, 08 75, 08 76, 08 77, 08 78, 08 79, 08 80, 08 81, 08 82, 08 83, 08 84, 08 85, 08 86, 08 87, 08 88, 08 89, 08 90, 08 91, 08 92, 08 93, 08 94, 08 95, 08 96, 08 97, 08 98, 08 99, 09 10, 09 11, 09 12, 09 13, 09 14, 09 15, 09 16, 09 17, 09 18, 09 19, 09 20, 09 21, 09 22, 09 23, 09 24, 09 25, 09 26, 09 27, 09 28, 09 29, 09 30, 09 31, 09 32, 09 33, 09 34, 09 35, 09 36, 09 37, 09 38, 09 39, 09 40, 09 41, 09 42, 09 43, 09 44, 09 45, 09 46, 09 47, 09 48, 09 49, 09 50, 09 51, 09 52, 09 53, 09 54, 09 55, 09 56, 09 57, 09 58, 09 59, 09 60, 09 61, 09 62, 09 63, 09 64, 09 65, 09 66, 09 67, 09 68, 09 69, 09 70, 09 71, 09 72, 09 73, 09 74, 09 75, 09 76, 09 77, 09 78, 09 79, 09 80, 09 81, 09 82, 09 83, 09 84, 09 85, 09 86, 09 87, 09 88, 09 89, 09 90, 09 91, 09 92, 09 93, 09 94, 09 95, 09 96, 09 97, 09 98, 09 99, 10 11, 10 12, 10 13, 10 14, 10 15, 10 16, 10 17, 10 18, 10 19, 10 20, 10 21, 10 22, 10 23, 10 24, 10 25, 10 26, 10 27, 10 28, 10 29, 10 30, 10 31, 10 32, 10 33, 10 34, 10 35, 10 36, 10 37, 10 38, 10 39, 10 40, 10 41, 10 42, 10 43, 10 44, 10 45, 10 46, 10 47, 10 48, 10 49, 10 50, 10 51, 10 52, 10 53, 10 54, 10 55, 10 56, 10 57, 10 58, 10 59, 10 60, 10 61, 10 62, 10 63, 10 64, 10 65, 10 66, 10 67, 10 68, 10 69, 10 70, 10 71, 10 72, 10 73, 10 74, 10 75, 10 76, 10 77, 10 78, 10 79, 10 80, 10 81, 10 82, 10 83, 10 84, 10 85, 10 86, 10 87, 10 88, 10 89, 10 90, 10 91, 10 92, 10 93, 10 94, 10 95, 10 96, 10 97, 10 98, 10 99, 11 12, 11 13, 11 14, 11 15, 11 16, 11 17, 11 18, 11 19, 11 20, 11 21, 11 22, 11 23, 11 24, 11 25, 11 26, 11 27, 11 28, 11 29, 11 30, 11 31, 11 32, 11 33, 11 34, 11 35, 11 36, 11 37, 11 38, 11 39, 11 40, 11 41, 11 42, 11 43, 11 44, 11 45, 11 46, 11 47, 11 48, 11 49, 11 50, 11 51, 11 52, 11 53, 11 54, 11 55, 11 56, 11 57, 11 58, 11 59, 11 60, 11 61, 11 62, 11 63, 11 64, 11 65, 11 66, 11 67, 11 68, 11 69, 11 70, 11 71, 11 72, 11 73, 11 74, 11 75, 11 76, 11 77, 11 78, 11 79, 11 80, 11 81, 11 82, 11 83, 11 84, 11 85, 11 86, 11 87, 11 88, 11 89, 11 90, 11 91, 11 92, 11 93, 11 94, 11 95, 11 96, 11 97, 11 98, 11 99, 12 13, 12 14, 12 15, 12 16, 12 17, 12 18, 12 19, 12 20, 12 21, 12 22, 12 23, 12 24, 12 25, 12 26, 12 27, 12 28, 12 29, 12 30, 12 31, 12 32, 12 33, 12 34, 12 35, 12 36, 12 37, 12 38, 12 39, 12 40, 12 41, 12 42, 12 43, 12 44, 12 45, 12 46, 12 47, 12 48, 12 49, 12 50, 12 51, 12 52, 12 53, 12 54, 12 55, 12 56, 12 57, 12 58, 12 59, 12 60, 12 61, 12 62, 12 63, 12 64, 12 65, 12 66, 12 67, 12 68, 12 69, 12 70, 12 71, 12 72, 12 73, 12 74, 12 75, 12 76, 12 77, 12 78, 12 79, 12 80, 12 81, 12 82, 12 83, 12 84, 12 85, 12 86, 12 87, 12 88, 12 89, 12 90, 12 91, 12 92, 12 93, 12 94, 12 95, 12 96, 12 97, 12 98, 12 99, 13 14, 13 15, 13 16, 13 17, 13 18, 13 19, 13 20, 13 21, 13 22, 13 23, 13 24, 13 25, 13 26, 13 27, 13 28, 13 29, 13 30, 13 31, 13 32, 13 33, 13 34, 13 35, 13 36, 13 37, 13 38, 13 39, 13 40, 13 41, 13 42, 13 43, 13 44, 13 45, 13 46, 13 47, 13 48, 13 49, 13 50, 13 51, 13 52, 13 53, 13 54, 13 55, 13 56, 13 57, 13 58, 13 59, 13 60, 13 61, 13 62, 13 63, 13 64, 13 65, 13 66, 13 67, 13 68, 13 69, 13 70, 13 71, 13 72, 13 73, 13 74, 13 75, 13 76, 13 77, 13 78, 13 79, 13 80, 13 81, 13 82, 13 83, 13 84, 13 85, 13 86, 13 87, 13 88, 13 89, 13 90, 13 91, 13 92, 13 93, 13 94, 13 95, 13 96, 13 97, 13 98, 13 99, 14 15, 14 16, 14 17, 14 18, 14 19, 14 20, 14 21, 14 22, 14 23, 14 24, 14 25, 14 26, 14 27, 14 28, 14 29, 14 30, 14 31, 14 32, 14 33, 14 34, 14 35, 14 36, 14 37, 14 38, 14 39, 14 40, 14 41, 14 42, 14 43, 14 44, 14 45, 14 46, 14 47, 14 48, 14 49, 14 50, 14 51, 14 52, 14 53, 14 54, 14 55, 14 56, 14 57, 14 58, 14 59, 14 60, 14 61, 14 62, 14 63, 14 64, 14 65, 14 66, 14 67, 14 68, 14 69, 14 70, 14 71, 14 72, 14 73, 14 74, 14 75, 14 76, 14 77, 14 78, 14 79, 14 80, 14 81, 14 82, 14 83, 14 84, 14 85, 14 86, 14 87, 14 88, 14 89, 14 90, 14 91, 14 92, 14 93, 14 94, 14 95, 14 96, 14 97, 14 98, 14 99, 15 16, 15 17, 15 18, 15 19, 15 20, 15 21, 15 22, 15 23, 15 24, 15 25, 15 26, 15 27, 15 28, 15 29, 15 30, 15 31, 15 32, 15 33, 15 34, 15 35, 15 36, 15 37, 15 38, 15 39, 15 40, 15 41, 15 42, 15 43, 15 44, 15 45, 15 46, 15 47, 15 48, 15 49, 15 50, 15 51, 15 52, 15 53, 15 54, 15 55, 15 56, 15 57, 15 58, 15 59, 15 60, 15 61, 15 62, 15 63, 15 64, 15 65, 15 66, 15 67, 15 68, 15 69, 15 70, 15 71, 15 72, 15 73, 15 74, 15 75, 15 76, 15 77, 15 78, 15 79, 15 80, 15 81, 15 82, 15 83, 15 84, 15 85, 15 86, 15 87, 15 88, 15 89, 15 90, 15 91, 15 92, 15 93, 15 94, 15 95, 15 96, 15 97, 15 98, 15 99, 16 17, 16 18, 16 19, 16 20, 16 21, 16 22, 16 23, 16 24, 16 25, 16 26, 16 27, 16 28, 16 29, 16 30, 16 31, 16 32, 16 33, 16 34, 16 35, 16 36, 16 37, 16 38, 16 39, 16 40, 16 41, 16 42, 16 43, 16 44, 16 45, 16 46, 16 47, 16 48, 16 49, 16 50, 16 51, 16 52, 16 53, 16 54, 16 55, 16 56, 16 57, 16 58, 16 59, 16 60, 16 61, 16 62, 16 63, 16 64, 16 65, 16 66, 16 67, 16 68, 16 69, 16 70, 16 71, 16 72, 16 73, 16 74, 16 75, 16 76, 16 77, 16 78, 16 79, 16 80, 16 81, 16 82, 16 83, 16 84, 16 85, 16 86, 16 87, 16 88, 16 89, 16 90, 16 91, 16 92, 16 93, 16 94, 16 95, 16 96, 16 97, 16 98, 16 99, 17 18, 17 19, 17 20, 17 21, 17 22, 17 23, 17 24, 17 25, 17 26, 17 27, 17 28, 17 29, 17 30, 17 31, 17 32, 17 33, 17 34, 17 35, 17 36, 17 37, 17 38, 17 39, 17 40, 17 41, 17 42, 17 43, 17 44, 17 45, 17 46, 17 47, 17 48, 17 49, 17 50, 17 51, 17 52, 17 53, 17 54, 17 55, 17 56, 17 57, 17 58, 17 59, 17 60, 17 61, 17 62, 17 63, 17 64, 17 65, 17 66, 17 67, 17 68, 17 69, 17 70, 17 71, 17 72, 17 73, 17 74, 17 75, 17 76, 17 77, 17 78, 17 79, 17 80, 17 81, 17 82, 17 83, 17 84, 17 85, 17 86, 17 87, 17 88, 17 89, 17 90, 17 91, 17 92, 17 93, 17 94, 17 95, 17 96, 17 97, 17 98, 17 99, 18 19, 18 20, 18 21, 18 22, 18 23, 18 24, 18 25, 18 26, 18 27, 18 28, 18 29, 18 30, 18 31, 18 32, 18 33, 18 34, 18 35, 18 36, 18 37, 18 38, 18 39, 18 40, 18 41, 18 42, 18 43, 18 44, 18 45, 18 46, 18 47, 18 48, 18 49, 18 50, 18 51, 18 52, 18 53, 18 54, 18 55, 18 56, 18 57, 18 58, 18 59, 18 60, 18 61, 18 62, 18 63, 18 64, 18 65, 18 66, 18 67, 18 68, 18 69, 18 70, 18 71, 18 72, 18 73, 18 74, 18 75, 18 76, 18 77, 18 78, 18 79, 18 80, 18 81, 18 82, 18 83, 18 84, 18 85, 18 86, 18 87, 18 88, 18 89, 18 90, 18 91, 18 92, 18 93, 18 94, 18 95, 18 96, 18 97, 18 98, 18 99, 19 20, 19 21, 19 22, 19 23, 19 24, 19 25, 19 26, 19 27, 19 28, 19 29, 19 30, 19 31, 19 32, 19 33, 19 34, 19 35, 19 36, 19 37, 19 38, 19 39, 19 40, 19 41, 19 42, 19 43, 19 44, 19 45, 19 46, 19 47, 19 48, 19 49, 19 50, 19 51, 19 52, 19 53, 19 54, 19 55, 19 56, 19 57, 19 58, 19 59, 19 60, 19 61, 19 62, 19 63, 19 64, 19 65, 19 66, 19 67, 19 68, 19 69, 19 70, 19 71, 19 72, 19 73, 19 74, 19 75, 19 76, 19 77, 19 78, 19 79, 19 80, 19 81, 19 82, 19 83, 19 84, 19 85, 19 86, 19 87, 19 88, 19 89, 19 90, 19 91, 19 92, 19 93, 19 94, 19 95, 19 96, 19 97, 19 98, 19 99, 20 21, 20 22, 20 23, 20 24, 20 25, 20 26, 20 27, 20 28, 20 29, 20 30, 20 31, 20 32, 20 33, 20 34, 20 35, 20 36, 20 37, 20 38, 20 39, 20 40, 20 41, 20 42, 20 43, 20 44, 20 45, 20 46, 20 47, 20 48, 20 49, 20 50, 20 51, 20 52, 20 53, 20 54, 20 55, 20 56, 20 57, 20 58, 20 59, 20 60, 20 61, 20 62, 20 63, 20 64, 20 65, 20 66, 20 67, 20 68, 20 69, 20 70, 20 71, 20 72, 20 73, 20 74, 20 75, 20 76, 20 77, 20 78, 20 79, 20 80, 20 81, 20 82, 20 83, 20 84, 20 85, 20 86, 20 87, 20 88, 20 89, 20 90, 20 91, 20 92, 20 93, 20 94, 20 95, 20 96, 20 97, 20 98, 20 99, 21 22, 21 23, 21 24, 21 25, 21 26, 21 27, 21 28, 21 29, 21 30, 21 31, 21 32, 21 33, 21 34, 21 35, 21 36, 21 37, 21 38, 21 39, 21 40, 21 41, 21 42, 21 43, 21 44, 21 45, 21 46, 21 47, 21 48, 21 49, 21 50, 21 51, 21 52, 21 53, 21 54, 21 55, 21 56, 21 57, 21 58, 21 59, 21 60, 21 61, 21 62, 21 63, 21 64, 21 65, 21 66, 21 67, 21 68, 21 69, 21 70, 21 71, 21 72, 21 73, 21 74, 21 75, 21 76, 21 77, 21 78, 21 79, 21 80, 21 81, 21 82, 21 83, 21 84, 21 85, 21 86, 21 87, 21 88, 21 89, 21 90, 21 91, 21 92, 21 93, 21 94, 21 95, 21 96, 21 97, 21 98, 21 99, 22 23, 22 24, 22 25, 22 26, 22 27, 22 28, 22 29, 22 30, 22 31, 22 32, 22 33, 22 34, 22 35, 22 36, 22 37, 22 38, 22 39, 22 40, 22 41, 22 42, 22 43, 22 44, 22 45, 22 46, 22 47, 22 48, 22 49, 22 50, 22 51, 22 52, 22 53, 22 54, 22 55, 22 56, 22 57, 22 58, 22 59, 22 60, 22 61, 22 62, 22 63, 22 64, 22 65, 22 66, 22 67, 22 68, 22 69, 22 70, 22 71, 22 72, 22 73, 22 74, 22 75, 22 76, 22 77, 22 78, 22 79, 22 80, 22 81, 22 82, 22 83, 22 84, 22 85, 22 86, 22 87, 22 88, 22 89, 22 90, 22 91, 22 92, 22 93, 22 94, 22 95, 22 96, 22 97, 22 98, 22 99, 23 24, 23 25, 23 26, 23 27, 23 28, 23 29, 23 30, 23 31, 23 32, 23 33, 23 34, 23 35, 23 36, 23 37, 23 38, 23 39, 23 40, 23 41, 23 42, 23 43, 23 44, 23 45, 23 46, 23 47, 23 48, 23 49, 23 50, 23 51, 23 52, 23 53, 23 54, 23 55, 23 56, 23 57, 23 58, 23 59, 23 60, 23 61, 23 62, 23 63, 23 64, 23 65, 23 66, 23 67, 23 68, 23 69, 23 70, 23 71, 23 72, 23 73, 23 74, 23 75, 23 76, 23 77, 23 78, 23 79, 23 80, 23 81, 23 82, 23 83, 23 84, 23 85, 23 86, 23 87, 23 88, 23 89, 23 90, 23 91, 23 92, 23 93, 23 94, 23 95, 23 96, 23 97, 23 98, 23 99, 24 25, 24 26, 24 27, 24 28, 24 29, 24 30, 24 31, 24 32, 24 33, 24 34, 24 35, 24 36, 24 37, 24 38, 24 39, 24 40, 24 41, 24 42, 24 43, 24 44, 24 45, 24 46, 24 47, 24 48, 24 49, 24 50, 24 51, 24 52, 24 53, 24 54, 24 55, 24 56, 24 57, 24 58, 24 59, 24 60, 24 61, 24 62, 24 63, 24 64, 24 65, 24 66, 24 67, 24 68, 24 69, 24 70, 24 71, 24 72, 24 73, 24 74, 24 75, 24 76, 24 77, 24 78, 24 79, 24 80, 24 81, 24 82, 24 83, 24 84, 24 85, 24 86, 24 87, 24 88, 24 89, 24 90, 24 91, 24 92, 24 93, 24 94, 24 95, 24 96, 24 97, 24 98, 24 99, 25 26, 25 27, 25 28, 25 29, 25 30, 25 31, 25 32, 25 33, 25 34, 25 35, 25 36, 25 37, 25 38, 25 39, 25 40, 25 41, 25 42, 25 43, 25 44, 25 45, 25 46, 25 47, 25 48, 25 49, 25 50, 25 51, 25 52, 25 53, 25 54, 25 55, 25 56, 25 57, 25 58, 25 59, 25 60, 25 61, 25 62, 25 63, 25 64, 25 65, 25 66, 25 67, 25 68, 25 69, 25 70, 25 71, 25 72, 25 73, 25 74, 25 75, 25 76, 25 77, 25 78, 25 79, 25 80, 25 81, 25 82, 25 83, 25 84, 25 85, 25 86, 25 87, 25 88, 25 89, 25 90, 25 91, 25 92, 25 93, 25 94, 25 95, 25 96, 25 97, 25 98, 25 99, 26 27, 26 28, 26 29, 26 30, 26 31, 26 32, 26 33, 26 34, 26 35, 26 36, 26 37, 26 38, 26 39, 26 40, 26 41, 26 42, 26 43, 26 44, 26 45, 26 46, 26 47, 26 48, 26 49, 26 50, 26 51, 26 52, 26 53, 26 54, 26 55, 26 56, 26 57, 26 58, 26 59, 26 60, 26 61, 26 62, 26 63, 26 64, 26 65, 26 66, 26 67, 26 68, 26 69, 26 70, 26 71, 26 72, 26 73, 26 74, 26 75, 26 76, 26 77, 26 78, 26 79, 26 80, 26 81, 26 82, 26 83, 26 84, 26 85, 26 86, 26 87, 26 88, 26 89, 26 90, 26 91, 26 92, 26 93, 26 94, 26 95, 26 96, 26 97, 26 98, 26 99, 27 28, 27 29, 27 30, 27 31, 27 32, 27 33, 27 34, 27 35, 27 36, 27 37, 27 38, 27 39, 27 40, 27 41, 27 42, 27 43, 27 44, 27 45, 27 46, 27 47, 27 48, 27 49, 27 50, 27 51, 27 52, 27 53, 27 54, 27 55, 27 56, 27 57, 27 58, 27 59, 27 60, 27 61, 27 62, 27 63, 27 64, 27 65, 27 66, 27 67, 27 68, 27 69, 27 70, 27 71, 27 72, 27 73, 27 74, 27 75, 27 76, 27 77, 27 78, 27 79, 27 80, 27 81, 27 82, 27 83, 27 84, 27 85, 27 86, 27 87, 27 88, 27 89, 27 90, 27 91, 27 92, 27 93, 27 94, 27 95, 27 96, 27 97, 27 98, 27 99, 28 29, 28 30, 28 31, 28 32, 28 33, 28 34, 28 35, 28 36, 28 37, 28 38, 28 39, 28 40, 28 41, 28 42, 28 43, 28 44, 28 45, 28 46, 28 47, 28 48, 28 49, 28 50, 28 51, 28 52, 28 53, 28 54, 28 55, 28 56, 28 57, 28 58, 28 59, 28 60, 28 61, 28 62, 28 63, 28 64, 28 65, 28 66, 28 67, 28 68, 28 69, 28 70, 28 71, 28 72, 28 73, 28 74, 28 75, 28 76, 28 77, 28 78, 28 79, 28 80, 28 81, 28 82, 28 83, 28 84, 28 85, 28 86, 28 87, 28 88, 28 89, 28 90, 28 91, 28 92, 28 93, 28 94, 28 95, 28 96, 28 97, 28 98, 28 99, 29 30, 29 31, 29 32, 29 33, 29 34, 29 35, 29 36, 29 37, 29 38, 29 39, 29 40, 29 41, 29 42, 29 43, 29 44, 29 45, 29 46, 29 47, 29 48, 29 49, 29 50, 29 51, 29 52, 29 53, 29 54, 29 55, 29 56, 29 57, 29 58, 29 59, 29 60, 29 61, 29 62, 29 63, 29 64, 29 65, 29 66, 29 67, 29 68, 29 69, 29 70, 29 71, 29 72, 29 73, 29 74, 29 75, 29 76, 29 77, 29 78, 29 79, 29 80, 29 81, 29 82, 29 83, 29 84, 29 85, 29 86, 29 87, 29 88, 29 89, 29 90, 29 91, 29 92, 29 93, 29 94, 29 95, 29 96, 29 97, 29 98, 29 99, 30 31, 30 32, 30 33, 30 34, 30 35, 30 36, 30 37, 30 38, 30 39, 30 40, 30 41, 30 42, 30 43, 30 44, 30 45, 30 46, 30 47, 30 48, 30 49, 30 50, 30 51, 30 52, 30 53, 30 54, 30 55, 30 56, 30 57, 30 58, 30 59, 30 60, 30 61, 30 62, 30 63, 30 64, 30 65, 30 66, 30 67, 30 68, 30 69, 30 70, 30 71, 30 72, 30 73, 30 74, 30 75, 30 76, 30 77, 30 78, 30 79, 30 80, 30 81, 30 82, 30 83, 30 84, 30 85, 30 86, 30 87, 30 88, 30 89, 30 90, 30 91, 30 92, 30 93, 30 94, 30 95, 30 96, 30 97, 30 98, 30 99, 31 32, 31 33, 31 34, 31 35, 31 36, 31 37, 31 38, 31 39, 31 40, 31 41, 31 42, 31 43, 31 44, 31 45, 31 46, 31 47, 31 48, 31 49, 31 50, 31 51, 31 52, 31 53, 31 54, 31 55, 31 56, 31 57, 31 58, 31 59, 31 60, 31 61, 31 62, 31 63, 31 64, 31 65, 31 66, 31 67, 31 68, 31 69, 31 70, 31 71, 31 72, 31 73, 31 74, 31 75, 31 76, 31 77, 31 78, 31 79, 31 80, 31 81, 31 82, 31 83, 31 84, 31 85, 31 86, 31 87, 31 88, 31 89, 31 90, 31 91, 31 92, 31 93, 31 94, 31 95, 31 96, 31 97, 31 98, 31 99, 32 33, 32 34, 32 35, 32 36, 32 37, 32 38, 32 39, 32 40, 32 41, 32 42, 32 43, 32 44, 32 45, 32 46, 32 47, 32 48, 32 49, 32 50, 32 51, 32 52, 32 53, 32 54, 32 55, 32 56, 32 57, 32 58, 32 59, 32 60, 32 61, 32 62, 32 63, 32 64, 32 65, 32 66, 32 67, 32 68, 32 69, 32 70, 32 71, 32 72, 32 73, 32 74, 32 75, 32 76, 32 77, 32 78, 32 79, 32 80, 32 81, 32 82, 32 83, 32 84, 32 85, 32 86, 32 87, 32 88, 32 89, 32 90, 32 91, 32 92, 32 93, 32 94, 32 95, 32 96, 32 97, 32 98, 32 99, 33 34, 33 35, 33 36, 33 37, 33 38, 33 39, 33 40, 33 41, 33 42, 33 43, 33 44, 33 45, 33 46, 33 47, 33 48, 33 49, 33 50, 33 51, 33 52, 33 53, 33 54, 33 55, 33 56, 33 57, 33 58, 33 59, 33 60, 33 61, 33 62, 33 63, 33 64, 33 65, 33 66, 33 67, 33 68, 33 69, 33 70, 33 71, 33 72, 33 73, 33 74, 33 75, 33 76, 33 77, 33 78, 33 79, 33 80, 33 81, 33 82, 33 83, 33 84, 33 85, 33 86, 33 87, 33 88, 33 89, 33 90, 33 91, 33 92, 33 93, 33 94, 33 95, 33 96, 33 97, 33 98, 33 99, 34 35, 34 36, 34 37, 34 38, 34 39, 34 40, 34 41, 34 42, 34 43, 34 44, 34 45, 34 46, 34 47, 34 48, 34 49, 34 50, 34 51, 34 52, 34 53, 34 54, 34 55, 34 56, 34 57, 34 58, 34 59, 34 60, 34 61, 34 62, 34 63, 34 64, 34 65, 34 66, 34 67, 34 68, 34 69, 34 70, 34 71, 34 72, 34 73, 34 74, 34 75, 34 76, 34 77, 34 78, 34 79, 34 80, 34 81, 34 82, 34 83, 34 84, 34 85, 34 86, 34 87, 34 88, 34 89, 34 90, 34 91, 34 92, 34 93, 34 94, 34 95, 34 96, 34 97, 34 98, 34 99, 35 36, 35 37, 35 38, 35 39, 35 40, 35 41, 35 42, 35 43, 35 44, 35 45, 35 46, 35 47, 35 48, 35 49, 35 50, 35 51, 35 52, 35 53, 35 54, 35 55, 35 56, 35 57, 35 58, 35 59, 35 60, 35 61, 35 62, 35 63, 35 64, 35 65, 35 66, 35 67, 35 68, 35 69, 35 70, 35 71, 35 72, 35 73, 35 74, 35 75, 35 76, 35 77, 35 78, 35 79, 35 80, 35 81, 35 82, 35 83, 35 84, 35 85, 35 86, 35 87, 35 88, 35 89, 35 90, 35 91, 35 92, 35 93, 35 94, 35 95, 35 96, 35 97, 35 98, 35 99, 36 37, 36 38, 36 39, 36 40, 36 41, 36 42, 36 43, 36 44, 36 45, 36 46, 36 47, 36 48, 36 49, 36 50, 36 51, 36 52, 36 53, 36 54, 36 55, 36 56, 36 57, 36 58, 36 59, 36 60, 36 61, 36 62, 36 63, 36 64, 36 65, 36 66, 36 67, 36 68, 36 69, 36 70, 36 71, 36 72, 36 73, 36 74, 36 75, 36 76, 36 77, 36 78, 36 79, 36 80, 36 81, 36 82, 36 83, 36 84, 36 85, 36 86, 36 87, 36 88, 36 89, 36 90, 36 91, 36 92, 36 93, 36 94, 36 95, 36 96, 36 97, 36 98, 36 99, 37 38, 37 39, 37 40, 37 41, 37 42, 37 43, 37 44, 37 45, 37 46, 37 47, 37 48, 37 49, 37 50, 37 51, 37 52, 37 53, 37 54, 37 55, 37 56, 37 57, 37 58, 37 59, 37 60, 37 61, 37 62, 37 63, 37 64, 37 65, 37 66, 37 67, 37 68, 37 69, 37 70, 37 71, 37 72, 37 73, 37 74, 37 75, 37 76, 37 77, 37 78, 37 79, 37 80, 37 81, 37 82, 37 83, 37 84, 37 85, 37 86, 37 87, 37 88, 37 89, 37 90, 37 91, 37 92, 37 93, 37 94, 37 95, 37 96, 37 97, 37 98, 37 99, 38 39, 38 40, 38 41, 38 42, 38 43, 38 44, 38 45, 38 46, 38 47, 38 48, 38 49, 38 50, 38 51, 38 52, 38 53, 38 54, 38 55, 38 56, 38 57, 38 58, 38 59, 38 60, 38 61, 38 62, 38 63, 38 64, 38 65, 38 66, 38 67, 38 68, 38 69, 38 70, 38 71, 38 72, 38 73, 38 74, 38 75, 38 76, 38 77, 38 78, 38 79, 38 80, 38 81, 38 82, 38 83, 38 84, 38 85, 38 86, 38 87, 38 88, 38 89, 38 90, 38 91, 38 92, 38 93, 38 94, 38 95, 38 96, 38 97, 38 98, 38 99, 39 40, 39 41, 39 42, 39 43, 39 44, 39 45, 39 46, 39 47, 39 48, 39 49, 39 50, 39 51, 39 52, 39 53, 39 54, 39 55, 39 56, 39 57, 39 58, 39 59, 39 60, 39 61, 39 62, 39 63, 39 64, 39 65, 39 66, 39 67, 39 68, 39 69, 39 70, 39 71, 39 72, 39 73, 39 74, 39 75, 39 76, 39 77, 39 78, 39 79, 39 80, 39 81, 39 82, 39 83, 39 84, 39 85, 39 86, 39 87, 39 88, 39 89, 39 90, 39 91, 39 92, 39 93, 39 94, 39 95, 39 96, 39 97, 39 98, 39 99, 40 41, 40 42, 40 43, 40 44, 40 45, 40 46, 40 47, 40 48, 40 49, 40 50, 40 51, 40 52, 40 53, 40 54, 40 55, 40 56, 40 57, 40 58, 40 59, 40 60, 40 61, 40 62, 40 63, 40 64, 40 65, 40 66, 40 67, 40 68, 40 69, 40 70, 40 71, 40 72, 40 73, 40 74, 40 75, 40 76, 40 77, 40 78, 40 79, 40 80, 40 81, 40 82, 40 83, 40 84, 40 85, 40 86, 40 87, 40 88, 40 89, 40 90, 40 91, 40 92, 40 93, 40 94, 40 95, 40 96, 40 97, 40 98, 40 99, 41 42, 41 43, 41 44, 41 45, 41 46, 41 47, 41 48, 41 49, 41 50, 41 51, 41 52, 41 53, 41 54, 41 55, 41 56, 41 57, 41 58, 41 59, 41 60, 41 61, 41 62, 41 63, 41 64, 41 65, 41 66, 41 67, 41 68, 41 69, 41 70, 41 71, 41 72, 41 73, 41 74, 41 75, 41 76, 41 77, 41 78, 41 79, 41 80, 41 81, 41 82, 41 83, 41 84, 41 85, 41 86, 41 87, 41 88, 41 89, 41 90, 41 91, 41 92, 41 93, 41 94, 41 95, 41 96, 41 97, 41 98, 41 99, 42 43, 42 44, 42 45, 42 46, 42 47, 42 48, 42 49, 42 50, 42 51, 42 52, 42 53, 42 54, 42 55, 42 56, 42 57, 42 58, 42 59, 42 60, 42 61, 42 62, 42 63, 42 64, 42 65, 42 66, 42 67, 42 68, 42 69, 42 70, 42 71, 42 72, 42 73, 42 74, 42 75, 42 76, 42 77, 42 78, 42 79, 42 80, 42 81, 42 82, 42 83, 42 84, 42 85, 42 86, 42 87, 42 88, 42 89, 42 90, 42 91, 42 92, 42 93, 42 94, 42 95, 42 96, 42 97, 42 98, 42 99, 43 44, 43 45, 43 46, 43 47, 43 48, 43 49, 43 50, 43 51, 43 52, 43 53, 43 54, 43 55, 43 56, 43 57, 43 58, 43 59, 43 60, 43 61, 43 62, 43 63, 43 64, 43 65, 43 66, 43 67, 43 68, 43 69, 43 70, 43 71, 43 72, 43 73, 43 74, 43 75, 43 76, 43 77, 43 78, 43 79, 43 80, 43 81, 43 82, 43 83, 43 84, 43 85, 43 86, 43 87, 43 88, 43 89, 43 90, 43 91, 43 92, 43 93, 43 94, 43 95, 43 96, 43 97, 43 98, 43 99, 44 45, 44 46, 44 47, 44 48, 44 49, 44 50, 44 51, 44 52, 44 53, 44 54, 44 55, 44 56, 44 57, 44 58, 44 59, 44 60, 44 61, 44 62, 44 63, 44 64, 44 65, 44 66, 44 67, 44 68, 44 69, 44 70, 44 71, 44 72, 44 73, 44 74, 44 75, 44 76, 44 77, 44 78, 44 79, 44 80, 44 81, 44 82, 44 83, 44 84, 44 85, 44 86, 44 87, 44 88, 44 89, 44 90, 44 91, 44 92, 44 93, 44 94, 44 95, 44 96, 44 97, 44 98, 44 99, 45 46, 45 47, 45 48, 45 49, 45 50, 45 51, 45 52, 45 53, 45 54, 45 55, 45 56, 45 57, 45 58, 45 59, 45 60, 45 61, 45 62, 45 63, 45 64, 45 65, 45 66, 45 67, 45 68, 45 69, 45 70, 45 71, 45 72, 45 73, 45 74, 45 75, 45 76, 45 77, 45 78, 45 79, 45 80, 45 81, 45 82, 45 83, 45 84, 45 85, 45 86, 45 87, 45 88, 45 89, 45 90, 45 91, 45 92, 45 93, 45 94, 45 95, 45 96, 45 97, 45 98, 45 99, 46 47, 46 48, 46 49, 46 50, 46 51, 46 52, 46 53, 46 54, 46 55, 46 56, 46 57, 46 58, 46 59, 46 60, 46 61, 46 62, 46 63, 46 64, 46 65, 46 66, 46 67, 46 68, 46 69, 46 70, 46 71, 46 72, 46 73, 46 74, 46 75, 46 76, 46 77, 46 78, 46 79, 46 80, 46 81, 46 82, 46 83, 46 84, 46 85, 46 86, 46 87, 46 88, 46 89, 46 90, 46 91, 46 92, 46 93, 46 94, 46 95, 46 96, 46 97, 46 98, 46 99, 47 48, 47 49, 47 50, 47 51, 47 52, 47 53, 47 54, 47 55, 47 56, 47 57, 47 58, 47 59, 47 60, 47 61, 47 62, 47 63, 47 64, 47 65, 47 66, 47 67, 47 68, 47 69, 47 70, 47 71, 47 72, 47 73, 47 74, 47 75, 47 76, 47 77, 47 78, 47 79, 47 80, 47 81, 47 82, 47 83, 47 84, 47 85, 47 86, 47 87, 47 88, 47 89, 47 90, 47 91, 47 92, 47 93, 47 94, 47 95, 47 96, 47 97, 47 98, 47 99, 48 49, 48 50, 48 51, 48 52, 48 53, 48 54, 48 55, 48 56, 48 57, 48 58, 48 59, 48 60, 48 61, 48 62, 48 63, 48 64, 48 65, 48 66, 48 67, 48 68, 48 69, 48 70, 48 71, 48 72, 48 73, 48 74, 48 75, 48 76, 48 77, 48 78, 48 79, 48 80, 48 81, 48 82, 48 83, 48 84, 48 85, 48 86, 48 87, 48 88, 48 89, 48 90, 48 91, 48 92, 48 93, 48 94, 48 95, 48 96, 48 97, 48 98, 48 99, 49 50, 49 51, 49 52, 49 53, 49 54, 49 55, 49 56, 49 57, 49 58, 49 59, 49 60, 49 61, 49 62, 49 63, 49 64, 49 65, 49 66, 49 67, 49 68, 49 69, 49 70, 49 71, 49 72, 49 73, 49 74, 49 75, 49 76, 49 77, 49 78, 49 79, 49 80, 49 81, 49 82, 49 83, 49 84, 49 85, 49 86, 49 87, 49 88, 49 89, 49 90, 49 91, 49 92, 49 93, 49 94, 49 95, 49 96, 49 97, 49 98, 49 99, 50 51, 50 52, 50 53, 50 54, 50 55, 50 56, 50 57, 50 58, 50 59, 50 60, 50 61, 50 62, 50 63, 50 64, 50 65, 50 66, 50 67, 50 68, 50 69, 50 70, 50 71, 50 72, 50 73, 50 74, 50 75, 50 76, 50 77, 50 78, 50 79, 50 80, 50 81, 50 82, 50 83, 50 84, 50 85, 50 86, 50 87, 50 88, 50 89, 50 90, 50 91, 50 92, 50 93, 50 94, 50 95, 50 96, 50 97, 50 98, 50 99, 51 52, 51 53, 51 54, 51 55, 51 56, 51 57, 51 58, 51 59, 51 60, 51 61, 51 62, 51 63, 51 64, 51 65, 51 66, 51 67, 51 68, 51 69, 51 70, 51 71, 51 72, 51 73, 51 74, 51 75, 51 76, 51 77, 51 78, 51 79, 51 80, 51 81, 51 82, 51 83, 51 84, 51 85, 51 86, 51 87, 51 88, 51 89, 51 90, 51 91, 51 92, 51 93, 51 94, 51 95, 51 96, 51 97, 51 98, 51 99, 52 53, 52 54, 52 55, 52 56, 52 57, 52 58, 52 59, 52 60, 52 61, 52 62, 52 63, 52 64, 52 65, 52 66, 52 67, 52 68, 52 69, 52 70, 52 71, 52 72, 52 73, 52 74, 52 75, 52 76, 52 77, 52 78, 52 79, 52 80, 52 81, 52 82, 52 83, 52 84, 52 85, 52 86, 52 87, 52 88, 52 89, 52 90, 52 91, 52 92, 52 93, 52 94, 52 95, 52 96, 52 97, 52 98, 52 99, 53 54, 53 55, 53 56, 53 57, 53 58, 53 59, 53 60, 53 61, 53 62, 53 63, 53 64, 53 65, 53 66, 53 67, 53 68, 53 69, 53 70, 53 71, 53 72, 53 73, 53 74, 53 75, 53 76, 53 77, 53 78, 53 79, 53 80, 53 81, 53 82, 53 83, 53 84, 53 85, 53 86, 53 87, 53 88, 53 89, 53 90, 53 91, 53 92, 53 93, 53 94, 53 95, 53 96, 53 97, 53 98, 53 99, 54 55, 54 56, 54 57, 54 58, 54 59, 54 60, 54 61, 54 62, 54 63, 54 64, 54 65, 54 66, 54 67, 54 68, 54 69, 54 70, 54 71, 54 72, 54 73, 54 74, 54 75, 54 76, 54 77, 54 78, 54 79, 54 80, 54 81, 54 82, 54 83, 54 84, 54 85, 54 86, 54 87, 54 88, 54 89, 54 90, 54 91, 54 92, 54 93, 54 94, 54 95, 54 96, 54 97, 54 98, 54 99, 55 56, 55 57, 55 58, 55 59, 55 60, 55 61, 55 62, 55 63, 55 64, 55 65, 55 66, 55 67, 55 68, 55 69, 55 70, 55 71, 55 72, 55 73, 55 74, 55 75, 55 76, 55 77, 55 78, 55 79, 55 80, 55 81, 55 82, 55 83, 55 84, 55 85, 55 86, 55 87, 55 88, 55 89, 55 90, 55 91, 55 92, 55 93, 55 94, 55 95, 55 96, 55 97, 55 98, 55 99, 56 57, 56 58, 56 59, 56 60, 56 61, 56 62, 56 63, 56 64, 56 65, 56 66, 56 67, 56 68, 56 69, 56 70, 56 71, 56 72, 56 73, 56 74, 56 75, 56 76, 56 77, 56 78, 56 79, 56 80, 56 81, 56 82, 56 83, 56 84, 56 85, 56 86, 56 87, 56 88, 56 89, 56 90, 56 91, 56 92, 56 93, 56 94, 56 95, 56 96, 56 97, 56 98, 56 99, 57 58, 57 59, 57 60, 57 61, 57 62, 57 63, 57 64, 57 65, 57 66, 57 67, 57 68, 57 69, 57 70, 57 71, 57 72, 57 73, 57 74, 57 75, 57 76, 57 77, 57 78, 57 79, 57 80, 57 81, 57 82, 57 83, 57 84, 57 85, 57 86, 57 87, 57 88, 57 89, 57 90, 57 91, 57 92, 57 93, 57 94, 57 95, 57 96, 57 97, 57 98, 57 99, 58 59, 58 60, 58 61, 58 62, 58 63, 58 64, 58 65, 58 66, 58 67, 58 68, 58 69, 58 70, 58 71, 58 72, 58 73, 58 74, 58 75, 58 76, 58 77, 58 78, 58 79, 58 80, 58 81, 58 82, 58 83, 58 84, 58 85, 58 86, 58 87, 58 88, 58 89, 58 90, 58 91, 58 92, 58 93, 58 94, 58 95, 58 96, 58 97, 58 98, 58 99, 59 60, 59 61, 59 62, 59 63, 59 64, 59 65, 59 66, 59 67, 59 68, 59 69, 59 70, 59 71, 59 72, 59 73, 59 74, 59 75, 59 76, 59 77, 59 78, 59 79, 59 80, 59 81, 59 82, 59 83, 59 84, 59 85, 59 86, 59 87, 59 88, 59 89, 59 90, 59 91, 59 92, 59 93, 59 94, 59 95, 59 96, 59 97, 59 98, 59 99, 60 61, 60 62, 60 63, 60 64, 60 65, 60 66, 60 67, 60 68, 60 69, 60 70, 60 71, 60 72, 60 73, 60 74, 60 75, 60 76, 60 77, 60 78, 60 79, 60 80, 60 81, 60 82, 60 83, 60 84, 60 85, 60 86, 60 87, 60 88, 60 89, 60 90, 60 91, 60 92, 60 93, 60 94, 60 95, 60 96, 60 97, 60 98, 60 99, 61 62, 61 63, 61 64, 61 65, 61 66, 61 67, 61 68, 61 69, 61 70, 61 71, 61 72, 61 73, 61 74, 61 75, 61 76, 61 77, 61 78, 61 79, 61 80, 61 81, 61 82, 61 83, 61 84, 61 85, 61 86, 61 87, 61 88, 61 89, 61 90, 61 91, 61 92, 61 93, 61 94, 61 95, 61 96, 61 97, 61 98, 61 99, 62 63, 62 64, 62 65, 62 66, 62 67, 62 68, 62 69, 62 70, 62 71, 62 72, 62 73, 62 74, 62 75, 62 76, 62 77, 62 78, 62 79, 62 80, 62 81, 62 82, 62 83, 62 84, 62 85, 62 86, 62 87, 62 88, 62 89, 62 90, 62 91, 62 92, 62 93, 62 94, 62 95, 62 96, 62 97, 62 98, 62 99, 63 64, 63 65, 63 66, 63 67, 63 68, 63 69, 63 70, 63 71, 63 72, 63 73, 63 74, 63 75, 63 76, 63 77, 63 78, 63 79, 63 80, 63 81, 63 82, 63 83, 63 84, 63 85, 63 86, 63 87, 63 88, 63 89, 63 90, 63 91, 63 92, 63 93, 63 94, 63 95, 63 96, 63 97, 63 98, 63 99, 64 65, 64 66, 64 67, 64 68, 64 69, 64 70, 64 71, 64 72, 64 73, 64 74, 64 75, 64 76, 64 77, 64 78, 64 79, 64 80, 64 81, 64 82, 64 83, 64 84, 64 85, 64 86, 64 87, 64 88, 64 89, 64 90, 64 91, 64 92, 64 93, 64 94, 64 95, 64 96, 64 97, 64 98, 64 99, 65 66, 65 67, 65 68, 65 69, 65 70, 65 71, 65 72, 65 73, 65 74, 65 75, 65 76, 65 77, 65 78, 65 79, 65 80, 65 81, 65 82, 65 83, 65 84, 65 85, 65 86, 65 87, 65 88, 65 89, 65 90, 65 91, 65 92, 65 93, 65 94, 65 95, 65 96, 65 97, 65 98, 65 99, 66 67, 66 68, 66 69, 66 70, 66 71, 66 72, 66 73, 66 74, 66 75, 66 76, 66 77, 66 78, 66 79, 66 80, 66 81, 66 82, 66 83, 66 84, 66 85, 66 86, 66 87, 66 88, 66 89, 66 90, 66 91, 66 92, 66 93, 66 94, 66 95, 66 96, 66 97, 66 98, 66 99, 67 68, 67 69, 67 70, 67 71, 67 72, 67 73, 67 74, 67 75, 67 76, 67 77, 67 78, 67 79, 67 80, 67 81, 67 82, 67 83, 67 84, 67 85, 67 86, 67 87, 67 88, 67 89, 67 90, 67 91, 67 92, 67 93, 67 94, 67 95, 67 96, 67 97, 67 98, 67 99, 68 69, 68 70, 68 71, 68 72, 68 73, 68 74, 68 75, 68 76, 68 77, 68 78, 68 79, 68 80, 68 81, 68 82, 68 83, 68 84, 68 85, 68 86, 68 87, 68 88, 68 89, 68 90, 68 91, 68 92, 68 93, 68 94, 68 95, 68 96, 68 97, 68 98, 68 99, 69 70, 69 71, 69 72, 69 73, 69 74, 69 75, 69 76, 69 77, 69 78, 69 79, 69 80, 69 81, 69 82, 69 83, 69 84, 69 85, 69 86, 69 87, 69 88, 69 89, 69 90, 69 91, 69 92, 69 93, 69 94, 69 95, 69 96, 69 97, 69 98, 69 99, 70 71, 70 72, 70 73, 70 74, 70 75, 70 76, 70 77, 70 78, 70 79, 70 80, 70 81, 70 82, 70 83, 70 84, 70 85, 70 86, 70 87, 70 88, 70 89, 70 90, 70 91, 70 92, 70 93, 70 94, 70 95, 70 96, 70 97, 70 98, 70 99, 71 72, 71 73, 71 74, 71 75, 71 76, 71 77, 71 78, 71 79, 71 80, 71 81, 71 82, 71 83, 71 84, 71 85, 71 86, 71 87, 71 88, 71 89, 71 90, 71 91, 71 92, 71 93, 71 94, 71 95, 71 96, 71 97, 71 98, 71 99, 72 73, 72 74, 72 75, 72 76, 72 77, 72 78, 72 79, 72 80, 72 81, 72 82, 72 83, 72 84, 72 85, 72 86, 72 87, 72 88, 72 89, 72 90, 72 91, 72 92, 72 93, 72 94, 72 95, 72 96, 72 97, 72 98, 72 99, 73 74, 73 75, 73 76, 73 77, 73 78, 73 79, 73 80, 73 81, 73 82, 73 83, 73 84, 73 85, 73 86, 73 87, 73 88, 73 89, 73 90, 73 91, 73 92, 73 93, 73 94, 73 95, 73 96, 73 97, 73 98, 73 99, 74 75, 74 76, 74 77, 74 78, 74 79, 74 80, 74 81, 74 82, 74 83, 74 84, 74 85, 74 86, 74 87, 74 88, 74 89, 74 90, 74 91, 74 92, 74 93, 74 94, 74 95, 74 96, 74 97, 74 98, 74 99, 75 76, 75 77, 75 78, 75 79, 75 80, 75 81, 75 82, 75 83, 75 84, 75 85, 75 86, 75 87, 75 88, 75 89, 75 90, 75 91, 75 92, 75 93, 75 94, 75 95, 75 96, 75 97, 75 98, 75 99, 76 77, 76 78, 76 79, 76 80, 76 81, 76 82, 76 83, 76 84, 76 85, 76 86, 76 87, 76 88, 76 89, 76 90, 76 91, 76 92, 76 93, 76 94, 76 95, 76 96, 76 97, 76 98, 76 99, 77 78, 77 79, 77 80, 77 81, 77 82, 77 83, 77 84, 77 85, 77 86, 77 87, 77 88, 77 89, 77 90, 77 91, 77 92, 77 93, 77 94, 77 95, 77 96, 77 97, 77 98, 77 99, 78 79, 78 80, 78 81, 78 82, 78 83, 78 84, 78 85, 78 86, 78 87, 78 88, 78 89, 78 90, 78 91, 78 92, 78 93, 78 94, 78 95, 78 96, 78 97, 78 98, 78 99, 79 80, 79 81, 79 82, 79 83, 79 84, 79 85, 79 86, 79 87, 79 88, 79 89, 79 90, 79 91, 79 92, 79 93, 79 94, 79 95, 79 96, 79 97, 79 98, 79 99, 80 81, 80 82, 80 83, 80 84, 80 85, 80 86, 80 87, 80 88, 80 89, 80 90, 80 91, 80 92, 80 93, 80 94, 80 95, 80 96, 80 97, 80 98, 80 99, 81 82, 81 83, 81 84, 81 85, 81 86, 81 87, 81 88, 81 89, 81 90, 81 91, 81 92, 81 93, 81 94, 81 95, 81 96, 81 97, 81 98, 81 99, 82 83, 82 84, 82 85, 82 86, 82 87, 82 88, 82 89, 82 90, 82 91, 82 92, 82 93, 82 94, 82 95, 82 96, 82 97, 82 98, 82 99, 83 84, 83 85, 83 86, 83 87, 83 88, 83 89, 83 90, 83 91, 83 92, 83 93, 83 94, 83 95, 83 96, 83 97, 83 98, 83 99, 84 85, 84 86, 84 87, 84 88, 84 89, 84 90, 84 91, 84 92, 84 93, 84 94, 84 95, 84 96, 84 97, 84 98, 84 99, 85 86, 85 87, 85 88, 85 89, 85 90, 85 91, 85 92, 85 93, 85 94, 85 95, 85 96, 85 97, 85 98, 85 99, 86 87, 86 88, 86 89, 86 90, 86 91, 86 92, 86 93, 86 94, 86 95, 86 96, 86 97, 86 98, 86 99, 87 88, 87 89, 87 90, 87 91, 87 92, 87 93, 87 94, 87 95, 87 96, 87 97, 87 98, 87 99, 88 89, 88 90, 88 91, 88 92, 88 93, 88 94, 88 95, 88 96, 88 97, 88 98, 88 99, 89 90, 89 91, 89 92, 89 93, 89 94, 89 95, 89 96, 89 97, 89 98, 89 99, 90 91, 90 92, 90 93, 90 94, 90 95, 90 96, 90 97, 90 98, 90 99, 91 92, 91 93, 91 94, 91 95, 91 96, 91 97, 91 98, 91 99, 92 93, 92 94, 92 95, 92 96, 92 97, 92 98, 92 99, 93 94, 93 95, 93 96, 93 97, 93 98, 93 99, 94 95, 94 96, 94 97, 94 98, 94 99, 95 96, 95 97, 95 98, 95 99, 96 97, 96 98, 96 99, 97 98, 97 99, 98 99

###Exécution du test :###

```bash
cd ex06
./test/test.sh
```

-------------------------------------------------
## 0.0.7) ex07: ft_putnbr
-------------------------------------------------

###Le but :###
Afficher un nombre entier (int) en toutes circonstances (positif, négatif, 0, INT_MIN).

###Structure recommandée###

```bash
ex07/
├── include/
│   └── ft_putnbr.h
├── src/
│   ├── ft_putnbr.c
│   └── ft_putchar.c
├── test/
│   ├── main.c
│   ├── expected.txt
│   └── test.sh
└── Makefile
```

###Prototype :###

```c
void ft_putnbr(int nb);
```

###Explication :###
On vérifie si le nombre est négatif. Si oui, on affiche '-' et on inverse le signe (attention à
INT_MIN).
Ensuite, on utilise une fonction récursive :
Si le nombre est supérieur ou égal à 10, on appelle ft_putnbr(nb / 10), puis on affiche le chiffre des unités: (nb % 10 + '0')et affiché avec write.

###Interdictions :###
- Pas de printf
- write uniquement

###Bulle d'ami :###
"Un nombre est juste une succession de chiffres à dérouler."

###Mini-TDD :###
Créer un main() de test pour afficher les valeurs suivantes avec ft_putnbr() :

>42
>-42
>0
>-2147483648

###TDD :###
Fichier de test : test/main.c

```c
#include "../include/ft_putnbr.h"

int main(void)
{
  ft_putnbr(83);
  ft_putchar('\n');
  ft_putnbr(-83);
  ft_putchar('\n');
  ft_putnbr(0);
  ft_putchar('\n');
  ft_putnbr(-2147483648);
  ft_putchar('\n');
  return 0;
}
```

Fichier : test.sh
```sh
diff test/output.txt test/expected.txt && echo "OK" || echo "FAIL" (à tester)
```

```sh
#!/bin/bash

# Compilation
gcc -Wall -Wextra -Werror -Iinclude src/*.c test/main.c -o ex07_test

# Exécution + redirection de sortie
./../ex07_test > test/output.txt

# Comparaison
diff test/output.txt test/expected.txt > /dev/null

if [ $? -eq 0 ]; then
  echo "ex07: Test réussi"
else
  echo "ex07: Erreur - La sortie ne correspond pas à expected.txt"
fi

# Nettoyage
rm -f ex07_test test/output.txt
```

Fichier : expected.txt

>83
>-83
>0
>-2147483648

Fichier : Makefile

```Makefile
SRC_ex07 = ft_putnbr ft_putchar

define compile_exercise
	@echo "Compiling $1..."
	$(CC) $(CFLAGS\) -I$1/include $(addprefix $1/src/, $(SRC_$1:=.c)) $1/test/main.c -o $1_test
endef
```

###Pour tester :###

```bash
cd ex07
./test/test.sh
```

###Résumé TDD :###
Étape Action
1️. Écris main.c pour tester 4 cas
2️. Crée expected.txt
3️. Implémente ft_putnbr.c
4️. Lance test.sh pour valider

-------------------------------------------------
## 0.0.8) ex08: ft_print_combn
-------------------------------------------------

###Le but :###
Afficher toutes les combinaisons possibles de n chiffres différents croissants.

###Prototype :###

```c
void ft_print_combn(int n);
```

###Explication :###
Créer un tableau de n chiffres allant de 0 à 9, en respectant l'ordre strictement croissant.
Incrémenter la combinaison actuelle tant que la dernière position n’a pas atteint sa limite.
À chaque affichage :
Pour n = 1 on affiche chaque chiffre 0, 1, ..., 9, .
On ajoute ", " sauf pour la dernière combinaison (n chiffres allant de 10 - n à 9).

Par exemple :
>pour n = 2, on affiche 01, 02, ..., 89.
>pour n = 3, on affiche 012, 013, ..., 789.
>Le cas n = 9 donne 012345678.

###Interdictions :###
- Pas de printf
- write uniquement

###Bulle d'ami :###
"Chaque choix ouvre la porte au suivant, comme un escalier numérique."

###Mini-TDD :###
Créer un test qui appelle ft_print_combn() avec 
>n = 1 → 0, 1, ..., 9
>n = 2 → 01, 02, ..., 89
>n = 3 → 012, ..., 789
>n = 4 → 0123, ..., 6789
>n = 9 → 012345678
et compare les sorties avec les résultats attendus.
Utilise diff avec un fichier expected.txt généré manuellement ou par script.

Fichier de test : test/main.c

```c
#include "../include/ft_print_combn.h"

int main(void)
{
  ft_print_combn(2);
  ft_putchar('\n');
  ft_print_combn(3);
  ft_putchar('\n');
  ft_print_combn(1);
  ft_putchar('\n');
  ft_print_combn(4);
  ft_putchar('\n');
  ft_print_combn(9);
  ft_putchar('\n');
  return 0;
}
```

Fichier attendu : test/expected.txt

```txt
01, 02, 03, ..., 89
012, 013, ..., 789
0, 1, ..., 9
0123, 0124, ..., 6789
012345678
```
-------------------------------------------------
#Module 1 — preprocessor/ — Fondamentaux du Préprocesseur C#
-------------------------------------------------

Module preprocessor/ — Fondamentaux du Préprocesseur [🔧 Niveau Facile à Moyen]

Objectif pédagogique
Le préprocesseur C est la toute première étape du processus de compilation. Il agit **avant même que le compilateur ne voie ton code** : il le **modifie**, le **réécrit** ou le **masque** selon des règles définies.

Ce module va t'apprendre à :

- Créer des macros simples et avancées  
- Utiliser des inclusions conditionnelles (`#ifdef`, `#ifndef`)  
- Exploiter les macros spéciales comme `__FILE__`, `__LINE__`, etc.  
- Comprendre la **portabilité** du code via les directives de compilation  
- Éviter les **pièges classiques** liés à des macros mal conçues

---

Outils utilisés

- `gcc -E` : affiche le code *préprocesseur* généré (avant compilation réelle)
- `gcc -DDEBUG` : permet de définir une macro à la compilation
- `man cpp` : le manuel de référence du préprocesseur C
- Aucune bibliothèque externe requise
- Utilisation stricte de `write()` (pas de `printf`)

---

Concepts abordés

1. Macros de substitution

```c
#define PI 3.14159
#define HELLO "Bonjour le monde !"
Les macros agissent comme un copier-coller aveugle dans le code.
Quand le compilateur voit PI, il remplace littéralement par 3.14159.

Astuce :

Pas de point-virgule (;) à la fin d’une macro !

Ce ne sont pas des variables, et n’occupent aucune mémoire.

2. Macros avec arguments
```c
#define SQUARE(x) ((x) * (x))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
```

Toujours protéger les arguments avec des parenthèses, sinon :

```c
#define BAD(x) x * x
int r = BAD(1+2); // devient => 1 + 2 * 1 + 2 = 5 au lieu de 9 ❌
```

Ce piège est célèbre. Il permet de comprendre que le préprocesseur ne comprend pas les priorités arithmétiques. Il fait un simple remplacement texte.

3. Inclusion conditionnelle

```c
#ifdef DEBUG
    write(1, "Mode debug activé\n", 18);
#endif
```

Cette directive permet d’exécuter un bloc uniquement si une macro est définie.
Très utilisé pour :
Désactiver des logs dans le binaire final
Séparer du code spécifique à une plateforme
Créer du code modulaire sans duplication

4. Inclusion unique (header guard)

```c
#ifndef MON_HEADER_H
#define MON_HEADER_H

// contenu...

#endif
```

Sans cette protection, un #include multiple du même fichier pourrait provoquer des doublons de définition, donc une erreur de compilation.
Règle pro : TOUS tes headers doivent être protégés. Toujours. Sans exception.

5. Macros spéciales
Ces macros sont automatiquement remplacées par des informations du contexte de compilation :

__FILE__ → nom du fichier courant
__LINE__ → numéro de ligne actuel
__DATE__ → date de compilation
__TIME__ → heure de compilation

Astuce bonus :

```c
#define TRACE write(1, __FILE__ ":" __DATE__ "\n", sizeof(__FILE__ ":" __DATE__ "\n") - 1)
```

Exercices
- preprocessor/ex00 — Macro SQUARE(x)
- Objectif : Créer une macro qui retourne le carré d’un entier.
- But pédagogique : Comprendre les effets de bord, les parenthèses obligatoires.

```c
#define SQUARE(x) ((x) * (x))
```

À tester :

SQUARE(4) → 16

SQUARE(1+2) → ✅ ((1+2)*(1+2)) = 9

BAD(1+2) → ❌ (voir piège ci-dessus)

Conseil : ajoute un fichier test.sh avec redirection > logs/output.txt
N’oublie pas que tu ne peux pas utiliser printf, alors remplace-le par write() + ft_putnbr().

preprocessor/ex01 — Afficher les métadonnées
Objectif : Afficher __FILE__, __LINE__, __DATE__, __TIME__

```c
#include <unistd.h>

void  ft_putnbr(int nb);
void  ft_putstr(char *str);

int main(void)
{
  ft_putstr("Fichier : ");
  ft_putstr(__FILE__); write(1, "\n", 1);

  ft_putstr("Ligne   : ");
  ft_putnbr(__LINE__); write(1, "\n", 1);

  ft_putstr("Date    : ");
  ft_putstr(__DATE__); write(1, "\n", 1);

  ft_putstr("Heure   : ");
  ft_putstr(__TIME__); write(1, "\n", 1);

  return 0;
}
```

Tu peux créer ta propre lib libft_print/ pour ft_putstr() et ft_putnbr(), réutilisable dans tout le projet.

preprocessor/ex02 — Activer ou désactiver le mode debug
Objectif : Utiliser #ifdef et -DDEBUG pour afficher un message


```c
#include <unistd.h>

int main(void) {
#ifdef DEBUG
    write(1, "Mode debug activé\n", 18);
#else
    write(1, "Mode normal\n", 12);
#endif
    return 0;
}
```

Compilation :

```bash
gcc -DDEBUG ex02.c -o ex02_debug
gcc ex02.c -o ex02_nodebug
```

Conseil : compare les deux binaires avec diff <(./ex02_debug) <(./ex02_nodebug)

preprocessor/ex03 — Message au moment de la compilation
Objectif : Utiliser #pragma message

```c
#pragma message("Compilation en cours — attention au code !")

int main(void) {
    return 0;
}
```

Ce message n’apparaît pas à l'exécution, mais dans le terminal au moment du gcc.

Utilité :
Laisser un avertissement visuel au compilateur
Éviter de commettre du code instable

Astuces bonus
Pour afficher le code généré après prétraitement :

```bash
gcc -E mon_programme.c > preprocessed.c
```

Tu verras comment le compilateur voit ton code après le passage du préprocesseur.
Exemple de fichier config.h global :

```c
#ifndef CONFIG_H
#define CONFIG_H

#define VERSION "1.0.0"
#define AUTHOR "Megnoux Xavier"
#define DEBUG_LEVEL 2

#endif
```

Tu peux inclure ce fichier dans tous tes projets pour avoir une signature claire.
Mini Makefile à utiliser

```makefile
# Makefile
NAME = ex02
SRC = ex02.c

debug:
  @gcc -Wall -Wextra -Werror -DDEBUG $(SRC) -o $(NAME)_debug
  @./$(NAME)_debug

nodebug:
  @gcc -Wall -Wextra -Werror $(SRC) -o $(NAME)_nodebug
  @./$(NAME)_nodebug
```

À retenir :
Les macros ne sont pas des fonctions.

Le préprocesseur est aveugle :
il ne comprend pas la sémantique, juste le texte.
Il ne faut jamais faire confiance à une macro sans parenthèses.
C’est un outil puissant pour la portabilité, la compilation conditionnelle et la gestion de la version.

Pourquoi c’est fondamental ?

Tu peux créer des logs temporaires sans polluer ton code final.
Tu protèges tous tes headers.
Tu écris du code plus propre, plus modulaire, et plus rapide à compiler.
C’est le premier pas vers des outils comme cmake, autoconf, etc.

Prochaine étape :
On retourne dans la piscine avec l’exercice ex09, en commençant à explorer les pointeurs, la mémoire, et des choses plus profondes.

-------------------------------------------------
##0.0.9) ex09 — ft_ultimate_ft : 9 niveaux de réalité !
-------------------------------------------------
###Objectif :###
Comprendre et manipuler plusieurs niveaux de pointeurs (jusqu’à 9) pour accéder à une valeur finale et la modifier. Cet exercice est symbolique : il démontre que peu importe le nombre de couches d’indirection, le principe reste identique.

###Prototype :###

```c
void ft_ultimate_ft(int *********nbr);
```

Explication mémoire :
Un pointeur est une boîte contenant l’adresse d’une autre boîte.
Cet exercice imbrique 9 boîtes jusqu’à la valeur finale.

Niveau  Type  Contenu
val int 0
p1  int*  adresse de val
p2  int** adresse de p1
... ... ...
p9  int*********  adresse de p8

Et donc :

```c
*********nbr = 42;
```

Cela modifie bien val à travers les 9 niveaux !

###Bulle d’ami :###
"Chaque * est une loupe : elle permet de descendre d’un niveau vers la réalité. Avec neuf loupes, tu peux toucher la vérité."

###Arborescence du projet :###

```bash
ex09/
├── include/
│   ├── ft_ultimate_ft.h
│   ├── ft_putnbr.h
│   └── ft_putstr.h
├── src/
│   ├── ft_ultimate_ft.c
│   ├── ft_putnbr.c
│   └── ft_putstr.c
├── test/
│   ├── main.c
│   ├── expected.txt
│   ├── output.txt
│   └── test.sh
└── Makefile
```

include/ft_ultimate_ft.h

```c
#ifndef FT_ULTIMATE_FT_H
# define FT_ULTIMATE_FT_H

void ft_ultimate_ft(int *********nbr);

#endif
```

src/ft_ultimate_ft.c

```c
#include "ft_ultimate_ft.h"

void ft_ultimate_ft(int *********nbr)
{
    *********nbr = 42;
}
```

include/ft_putnbr.h

```c
#ifndef FT_PUTNBR_H
# define FT_PUTNBR_H

void ft_putnbr(int nb);

#endif
```

src/ft_putnbr.c

```c
#include <unistd.h>
#include "ft_putnbr.h"

void ft_putchar(char c)
{
    write(1, &c, 1);
}

void ft_putnbr(int nb)
{
    if (nb == -2147483648)
    {
        write(1, "-2147483648", 11);
        return;
    }
    if (nb < 0)
    {
        ft_putchar('-');
        nb = -nb;
    }
    if (nb >= 10)
        ft_putnbr(nb / 10);
    ft_putchar(nb % 10 + '0');
}
```

include/ft_putstr.h

```c
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
```

src/ft_putstr.c

```c
#include <unistd.h>
#include "ft_putstr.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}
```

test/main.c

```c
#include "../include/ft_ultimate_ft.h"
#include "../include/ft_putnbr.h"
#include "../include/ft_putstr.h"
#include <unistd.h>

int main(void)
{
    int val = 0;
    int *p1 = &val;
    int **p2 = &p1;
    int ***p3 = &p2;
    int ****p4 = &p3;
    int *****p5 = &p4;
    int ******p6 = &p5;
    int *******p7 = &p6;
    int ********p8 = &p7;
    int *********p9 = &p8;

    ft_ultimate_ft(p9);

    ft_putstr("Résultat : ");
    ft_putnbr(val);
    write(1, "\n", 1); // Résultat attendu : 42

    return 0;
}
```

test/expected.txt

```txt
42
```

test/test.sh

```bash
#!/bin/bash

cd .. > /dev/null
make > /dev/null
./ex09 > test/output.txt

echo "Résultat attendu :"
cat test/expected.txt
echo "Résultat obtenu :"
cat test/output.txt
echo

diff test/output.txt test/expected.txt && echo "Test OK" || echo "Test FAIL"
```

###Makefile :###

```makefile
NAME = ex09
CC = gcc
CFLAGS = -Wall -Wextra -Werror
SRC = src/ft_ultimate_ft.c src/ft_putnbr.c src/ft_putstr.c test/main.c
INC = -Iinclude

all: $(NAME)

$(NAME):
  $(CC) $(CFLAGS) $(SRC) $(INC) -o $(NAME)

clean:
  rm -f $(NAME)
  rm -f test/output.txt

fclean: clean

re: fclean all
```

###Reverse Engineering :###

```bash
nm ex09 | grep ft_ultimate_ft
objdump -d ex09 | grep -A10 ft_ultimate_ft
```

Extrait ASM possible :

```asm
ft_ultimate_ft:
  mov    DWORD PTR [rdi], 0x2a    ; 42 en hexadécimal
  ret
```
À retenir
Concept Détail
Pointeurs imbriqués Chaque * descend d’un niveau
Accès par indirection Tu ne modifies pas la variable directement
Manipulation sécurisée  Pas de cast, pas d'artifice
Pureté C  Aucun outil non autorisé
Pédagogie mémoire Tu explores la pile de manière symbolique

Bonus Universitaire — Pour aller plus loin
Ajoute un affichage des adresses mémoire :

exemple avec stdio.h mai interdi donc ici, à faire avec write()

```c
#include <stdio.h>

printf("Adresse de val : %p\n", (void *)&val);
printf("Adresse de p1  : %p\n", (void *)&p1);
printf("Adresse de p9  : %p\n", (void *)p9);
```

Et visualise le déroutant mais magnifique labyrinthe de pointeurs.

Ce que tu apprends ici :
Base posée  Ce que tu sauras faire ensuite
Manipuler des structures imbriquées Structs, arbres, graphes
Passer des pointeurs à des fonctions  Tri, swap, double pointeurs
Ne plus avoir peur des étoiles *  Même dans char ***argv
Travailler proprement Avec fichiers séparés, Makefile et tests

-------------------------------------------------
# Piscine Boostée - Bloc 1 (Partie 2/5) [🟢 Facile]
-------------------------------------------------
## 0.0.10) ft_swap — [🟢 Facile] L’art de l’échange mémoire
-------------------------------------------------

###Objectif :###
Échanger les **valeurs de deux entiers** passés par **adresse mémoire** grâce à des pointeurs.

###Prototype :###

```c
void ft_swap(int *a, int *b);
```

###Explication pédagogique :###
Un pointeur (int *a) est une variable qui contient l'adresse mémoire d'une autre variable.
Lorsque tu passes &x à une fonction, tu transmets la référence de x.
Modifier *a dans la fonction revient à modifier directement x dans la fonction appelante.

Ce mécanisme est fondamental en C et sert dans :
les algorithmes de tri,
les structures de données,
la gestion dynamique de mémoire.

###Interdictions :###

Interdit                                |Raison pédagogique
----------------------------------------|----------------------------
printf, scanf, stdlib.h, stdio.h        | Non autorisés en piscine
Cast de type (ex : (int) ou (void *))   | Hors contexte
Retour de valeur                        | L’effet doit être visible par pointeur

Utilisation de plus d’un tampon On t’entraîne à être minimaliste et précis

###Obligatoire :###
Autorisé                                                     | Notes
-------------------------------------------------------------|----------------------------------------------------------
write(1, ...), ft_putchar, ft_putstr, ft_putnbr maison       | Pour l'affichage
Un seul int tmp;                                             | Pour stocker temporairement une valeur pendant l’échange
Pointeurs (*a, *b)                                           | Pour modifier directement la mémoire

###Bulle d’ami :###
"Un bon échange commence toujours par cacher une des deux valeurs dans une boîte temporaire."

###Visualisation mémoire (avant/après) :###
Avant :
  x = 5    y = 10

  &x → 0x100 → 5
  &y → 0x104 → 10

Après ft_swap(&x, &y) :
  x = 10   y = 5

####Arborescence du projet ex10/ :###

```bash
ex10/
├── include/
│   ├── ft_swap.h
│   ├── ft_putstr.h
│   ├── ft_putnbr.h
│   └── ft_putchar.h
├── src/
│   ├── ft_swap.c
│   ├── ft_putstr.c
│   ├── ft_putnbr.c
│   └── ft_putchar.c
├── test/
│   ├── main.c
│   ├── expected.txt
│   └── test.sh
└── Makefile
```

include/ft_swap.h

```c
#ifndef FT_SWAP_H
# define FT_SWAP_H

void ft_swap(int *a, int *b);

#endif
```

src/ft_swap.c

```c
#include "ft_swap.h"

void ft_swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}
```

include/ft_putstr.h

```c
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
```

src/ft_putstr.c

```c
#include <unistd.h>
#include "ft_putstr.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}
```

include/ft_putchar.h

```c
#ifndef FT_PUTCHAR_H
# define FT_PUTCHAR_H

void ft_putchar(char c);

#endif
```

src/ft_putchar.c

```c
#include <unistd.h>
#include "ft_putchar.h"

void ft_putchar(char c)
{
    write(1, &c, 1);
}
```

include/ft_putnbr.h

```c
#ifndef FT_PUTNBR_H
# define FT_PUTNBR_H

void ft_putnbr(int nb);

#endif
```

src/ft_putnbr.c

```c
#include "ft_putchar.h"
#include "ft_putnbr.h"

void ft_putnbr(int nb)
{
    if (nb == -2147483648)
    {
        write(1, "-2147483648", 11);
        return;
    }
    if (nb < 0)
    {
        ft_putchar('-');
        nb = -nb;
    }
    if (nb >= 10)
        ft_putnbr(nb / 10);
    ft_putchar(nb % 10 + '0');
}
```

test/main.c

```c

#include "../include/ft_swap.h"
#include "../include/ft_putstr.h"
#include "../include/ft_putnbr.h"
#include <unistd.h>

int main(void)
{
    int a = 5;
    int b = 10;

    ft_swap(&a, &b);

    ft_putstr("a = ");
    ft_putnbr(a);
    ft_putstr(", b = ");
    ft_putnbr(b);
    write(1, "\n", 1); // Résultat attendu : a = 10, b = 5

    return 0;
}
```

test/expected.txt

```txt
a = 10, b = 5
```

test/test.sh

```bash
#!/bin/bash

cd .. > /dev/null
make > /dev/null
./ex10 > test/output.txt

echo "Résultat attendu :"
cat test/expected.txt
echo "Résultat obtenu :"
cat test/output.txt
echo

diff test/output.txt test/expected.txt && echo "Test OK" || echo "Test FAIL"
```

###Makefile :###

```makefile
NAME = ex10
CC = gcc
CFLAGS = -Wall -Wextra -Werror
SRC = src/ft_swap.c src/ft_putstr.c src/ft_putnbr.c src/ft_putchar.c test/main.c
INC = -Iinclude

all: $(NAME)

$(NAME):
  $(CC) $(CFLAGS) $(SRC) $(INC) -o $(NAME)

clean:
  rm -f $(NAME)

fclean: clean
  rm -f test/output.txt

re: fclean all
```

###Reverse Engineering :###

nm :

```bash
nm ex10 | grep ft_swap
```

objdump :

```bash
objdump -d ex10 | grep -A20 ft_swap
```

Exemple ASM probable (x86_64) :

```asm
ft_swap:
    mov eax, DWORD PTR [rdi]   ; charger *a dans eax
    mov edx, DWORD PTR [rsi]   ; charger *b dans edx
    mov DWORD PTR [rdi], edx   ; *a = b
    mov DWORD PTR [rsi], eax   ; *b = a
    ret
```

À retenir :

Fait                                       |Description
-------------------------------------------|----------------------------
Pointeurs maîtrisés                        | Passage d’adresse = modification réelle
Sécurité mémoire                           | Pas de fuite, pas de cast, pas de malloc
Utilité future                             | Base de tous les tris : bubble sort, quick sort
Minimalisme                                | Pas de dépendance, pas de return, pas de macro

###Bonus pour plus tard :###
Créer une fonction générique d’échange :

```c
void swap(void *a, void *b, size_t size)
{
    unsigned char tmp;
    for (size_t i = 0; i < size; i++)
    {
        tmp = ((unsigned char *)a)[i];
        ((unsigned char *)a)[i] = ((unsigned char *)b)[i];
        ((unsigned char *)b)[i] = tmp;
    }
}
```

Mais tu l’utiliseras dans des algorithmes génériques (tri, tableaux, structures) plus tard.

-------------------------------------------------
## 0.0.11) ft_div_mod — [🟢 Facile] Deux sorties pour une entrée
-------------------------------------------------

🎯 Objectif :
Réaliser une division entière (`a / b`) et un modulo (`a % b`) sans utiliser `return`, uniquement avec des **pointeurs de sortie**.

---

📌 Prototype :
```c
void ft_div_mod(int a, int b, int *div, int *mod);
```
🧪 Explication pédagogique :
En C, une fonction ne peut retourner qu’une seule valeur directement avec return.
Mais si on veut renvoyer deux valeurs, on passe des pointeurs en arguments :

*div recevra a / b

*mod recevra a % b

C’est une technique classique pour contourner la limite du return.

🛑 Interdictions :

❌ Action interdite  💬 Raisons pédagogiques
return une structure  Trop avancé pour cet exercice
printf, scanf, stdlib.h Pas encore autorisés
Variables globales  Mauvaise pratique en C

✅ Obligatoire :
Utiliser les pointeurs pour écrire dans la mémoire du programme appelant.

💬 Bulle d’ami :
"Diviser, c’est partir à deux : un va droit, l’autre sort du chemin."

🧠 Cas pratique :

c
Copier
Modifier
int d = 0;
int m = 0;
ft_div_mod(10, 3, &d, &m);
// d = 3, m = 1
⚠️ À ne pas oublier :
Même si cet exercice ne le demande pas, penser à vérifier b != 0 dans des programmes réels pour éviter une division par zéro.

📁 Arborescence du projet ex11/ :

txt
Copier
Modifier
ex11/
├── include/
│   ├── ft_div_mod.h
│   ├── ft_putstr.h
│   ├── ft_putnbr.h
│   └── ft_putchar.h
├── src/
│   ├── ft_div_mod.c
│   ├── ft_putstr.c
│   ├── ft_putnbr.c
│   └── ft_putchar.c
├── test/
│   ├── main.c
│   ├── expected.txt
│   └── test.sh
└── Makefile
📦 include/ft_div_mod.h

c
Copier
Modifier
#ifndef FT_DIV_MOD_H
# define FT_DIV_MOD_H

void ft_div_mod(int a, int b, int *div, int *mod);

#endif
📦 src/ft_div_mod.c

c
Copier
Modifier
#include "ft_div_mod.h"

void ft_div_mod(int a, int b, int *div, int *mod)
{
    *div = a / b;
    *mod = a % b;
}
📦 include/ft_putstr.h

c
Copier
Modifier
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
📦 src/ft_putstr.c

c
Copier
Modifier
#include <unistd.h>
#include "ft_putstr.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}
📦 include/ft_putchar.h

c
Copier
Modifier
#ifndef FT_PUTCHAR_H
# define FT_PUTCHAR_H

void ft_putchar(char c);

#endif
📦 src/ft_putchar.c

c
Copier
Modifier
#include <unistd.h>
#include "ft_putchar.h"

void ft_putchar(char c)
{
    write(1, &c, 1);
}
📦 include/ft_putnbr.h

c
Copier
Modifier
#ifndef FT_PUTNBR_H
# define FT_PUTNBR_H

void ft_putnbr(int nb);

#endif
📦 src/ft_putnbr.c

c
Copier
Modifier
#include "ft_putchar.h"
#include "ft_putnbr.h"

void ft_putnbr(int nb)
{
    if (nb == -2147483648)
    {
        write(1, "-2147483648", 11);
        return;
    }
    if (nb < 0)
    {
        ft_putchar('-');
        nb = -nb;
    }
    if (nb >= 10)
        ft_putnbr(nb / 10);
    ft_putchar(nb % 10 + '0');
}
🧪 test/main.c

c
Copier
Modifier
#include "../include/ft_div_mod.h"
#include "../include/ft_putstr.h"
#include "../include/ft_putnbr.h"
#include <unistd.h>

int main(void)
{
    int d = 0;
    int m = 0;

    ft_div_mod(10, 3, &d, &m);

    ft_putstr("div = ");
    ft_putnbr(d);
    ft_putstr(", mod = ");
    ft_putnbr(m);
    write(1, "\n", 1); // Résultat attendu : div = 3, mod = 1

    return 0;
}
📄 test/expected.txt

ini
Copier
Modifier
div = 3, mod = 1
📄 test/test.sh

bash
Copier
Modifier
#!/bin/bash

cd .. > /dev/null
make > /dev/null
./ex11 > test/output.txt

echo "Résultat attendu :"
cat test/expected.txt
echo "Résultat obtenu :"
cat test/output.txt
echo

diff test/output.txt test/expected.txt && echo "✅ Test OK" || echo "❌ Test FAIL"
📄 Makefile

makefile
Copier
Modifier
NAME = ex11
CC = gcc
CFLAGS = -Wall -Wextra -Werror
SRC = src/ft_div_mod.c src/ft_putstr.c src/ft_putnbr.c src/ft_putchar.c test/main.c
INC = -Iinclude

all: $(NAME)

$(NAME):
  $(CC) $(CFLAGS) $(SRC) $(INC) -o $(NAME)

clean:
  rm -f $(NAME)

fclean: clean
  rm -f test/output.txt

re: fclean all
🔍 Reverse Engineering

📎 Analyse symbolique :

bash
Copier
Modifier
nm ex11 | grep ft_div_mod
📎 Désassemblage :

bash
Copier
Modifier
objdump -d ex11 | grep -A20 ft_div_mod
📎 Exemple d’ASM (x86_64) :

asm
Copier
Modifier
ft_div_mod:
    mov     eax, edi      ; a
    mov     ecx, esi      ; b
    cdq                  ; signe pour division
    idiv    ecx           ; edx:eax / ecx → eax = div, edx = mod
    mov     DWORD PTR [rdx], eax
    mov     DWORD PTR [r8], edx
📌 À retenir

🧠 Point clé Description
*div et *mod  Deux résultats simulés par pointeurs
Pas de return Simulation de multi-retour
Cas réel  Ce genre de fonction est courant en C bas-niveau
Sécurité  Toujours tester b != 0 dans des projets pro

🧠 Astuce finale :
Tu peux vérifier ta logique mathématique avec :

c
Copier
Modifier
assert((d * b + m) == a);
Cela garantit que la division et le modulo ont bien été effectués correctement.

-------------------------------------------------
## 0.0.12) ft_ultimate_div_mod — [🟢 Facile] Modification directe
-------------------------------------------------

🎯 Objectif :
Modifier directement deux entiers passés en pointeurs pour que :
- `*a` contienne le **résultat entier** de `a / b`
- `*b` contienne le **reste** de `a % b`

📌 Prototype :
```c
void ft_ultimate_div_mod(int *a, int *b);
🧪 Explication pédagogique :
Contrairement à l’exercice précédent (ft_div_mod) où on renvoyait les résultats dans deux pointeurs de sortie, ici on modifie les variables d’entrée elles-mêmes. C’est une technique de modification "in-place", typique dans les fonctions systèmes (ex : strtok, fgets, bzero...).

Exemple :

c
Copier
Modifier
int a = 10;
int b = 3;
ft_ultimate_div_mod(&a, &b);
// Résultat : a = 3, b = 1
🛑 Interdictions :

❌ Ne pas utiliser de return

❌ Ne pas créer de variables div ou mod externes au scope de la fonction

✅ Tout se fait en modifiant *a et *b uniquement

💬 Bulle d’ami :
"Quand deux amis partagent tout, chacun doit changer un peu pour l’autre."

⚠️ Bonnes pratiques :

Penser à tester que *b != 0 avant toute division pour éviter un crash

Ce genre de fonction est utile en bas niveau pour compresser des structures

📂 Arborescence du projet ex12/ :

txt
Copier
Modifier
ex12/
├── include/
│   ├── ft_ultimate_div_mod.h
│   ├── ft_putstr.h
│   ├── ft_putnbr.h
│   └── ft_putchar.h
├── src/
│   ├── ft_ultimate_div_mod.c
│   ├── ft_putstr.c
│   ├── ft_putnbr.c
│   └── ft_putchar.c
├── test/
│   ├── main.c
│   ├── expected.txt
│   └── test.sh
└── Makefile
📄 include/ft_ultimate_div_mod.h

c
Copier
Modifier
#ifndef FT_ULTIMATE_DIV_MOD_H
# define FT_ULTIMATE_DIV_MOD_H

void ft_ultimate_div_mod(int *a, int *b);

#endif
📄 src/ft_ultimate_div_mod.c

c
Copier
Modifier
#include "ft_ultimate_div_mod.h"

void ft_ultimate_div_mod(int *a, int *b)
{
    int temp_a = *a;
    *a = *a / *b;
    *b = temp_a % *b;
}
📄 include/ft_putstr.h

c
Copier
Modifier
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
📄 src/ft_putstr.c

c
Copier
Modifier
#include <unistd.h>
#include "ft_putstr.h"

void ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}
📄 include/ft_putnbr.h

c
Copier
Modifier
#ifndef FT_PUTNBR_H
# define FT_PUTNBR_H

void ft_putnbr(int nb);

#endif
📄 include/ft_putchar.h

c
Copier
Modifier
#ifndef FT_PUTCHAR_H
# define FT_PUTCHAR_H

void ft_putchar(char c);

#endif
📄 src/ft_putchar.c

c
Copier
Modifier
#include <unistd.h>
#include "ft_putchar.h"

void ft_putchar(char c)
{
    write(1, &c, 1);
}
📄 src/ft_putnbr.c

c
Copier
Modifier
#include "ft_putnbr.h"
#include "ft_putchar.h"

void ft_putnbr(int nb)
{
    if (nb == -2147483648)
    {
        write(1, "-2147483648", 11);
        return;
    }
    if (nb < 0)
    {
        ft_putchar('-');
        nb = -nb;
    }
    if (nb >= 10)
        ft_putnbr(nb / 10);
    ft_putchar(nb % 10 + '0');
}
🧪 test/main.c

c
Copier
Modifier
#include "../include/ft_ultimate_div_mod.h"
#include "../include/ft_putstr.h"
#include "../include/ft_putnbr.h"
#include <unistd.h>

int main(void)
{
    int a = 10;
    int b = 3;

    ft_ultimate_div_mod(&a, &b);

    ft_putstr("a = ");
    ft_putnbr(a);
    ft_putstr(", b = ");
    ft_putnbr(b);
    write(1, "\n", 1); // Attendu : a = 3, b = 1

    return 0;
}
📄 test/expected.txt

ini
Copier
Modifier
a = 3, b = 1
📄 test/test.sh

bash
Copier
Modifier
#!/bin/bash

cd .. > /dev/null
make > /dev/null
./ex12 > test/output.txt

echo "Résultat attendu :"
cat test/expected.txt
echo "Résultat obtenu :"
cat test/output.txt
echo

diff test/output.txt test/expected.txt && echo "✅ Test OK" || echo "❌ Test FAIL"
📄 Makefile

makefile
Copier
Modifier
NAME = ex12
CC = gcc
CFLAGS = -Wall -Wextra -Werror
SRC = src/ft_ultimate_div_mod.c src/ft_putstr.c src/ft_putnbr.c src/ft_putchar.c test/main.c
INC = -Iinclude

all: $(NAME)

$(NAME):
  $(CC) $(CFLAGS) $(SRC) $(INC) -o $(NAME)

clean:
  rm -f $(NAME)

fclean: clean
  rm -f test/output.txt

re: fclean all
🔍 Reverse Engineering (bonus avancé)

📎 Voir le symbole de la fonction :

bash
Copier
Modifier
nm ex12 | grep ft_ultimate_div_mod
📎 Désassembler la fonction :

bash
Copier
Modifier
objdump -d ex12 | grep -A20 ft_ultimate_div_mod
🔬 Exemple de code assembleur attendu :

asm
Copier
Modifier
ft_ultimate_div_mod:
  mov eax, DWORD PTR [rdi]     ; charger *a
  mov ecx, DWORD PTR [rsi]     ; charger *b
  mov edx, eax                 ; copier *a
  xor edx, edx
  div ecx                      ; eax = *a / *b, edx = *a % *b
  mov DWORD PTR [rdi], eax     ; écrire le résultat dans *a
  mov DWORD PTR [rsi], edx     ; écrire le modulo dans *b
📌 À retenir :

Concept Description
Pointeur int *a Permet d'accéder/modifier directement une variable
Pas de return Tout est en mémoire
div et mod combinés Optimisation classique
Sécurité : division par zéro ?  À vérifier dans des projets réels

🧠 Conseil final :
Cet exercice est un exemple parfait de passage par adresse et d’optimisation mémoire. Il t’oblige à réfléchir à l’état initial et final de tes variables, ce qui est la base du raisonnement fonctionnel et du TDD.

-------------------------------------------------
## 0.0.13) ft_putstr — [🟢 Facile] Affichage de chaînes
-------------------------------------------------

🎯 Objectif :
Afficher une chaîne de caractères, caractère par caractère, en utilisant uniquement `write`.

📌 Prototype :
```c
void ft_putstr(char *str);
🧪 Explication pédagogique :
Tu dois parcourir une chaîne de caractères (char *) jusqu’au caractère '\0', et écrire chaque caractère un par un à l’aide de write(1, &str[i], 1).

Cela te permet de comprendre comment fonctionne réellement une string en mémoire.

🛑 Interdictions :

❌ Pas de printf, puts, fputs, strlen

✅ Uniquement write() (appel système brut)

✅ Boucle manuelle while (*str) ou indexée

💬 Bulle d'ami :
"Une chaîne est comme un collier de perles : tu dois les enfiler une à une pour les voir briller."

🎯 Mini-TDD :

📂 test/main.c

c
Copier
Modifier
#include <unistd.h>

void ft_putstr(char *str);

int main(void)
{
    ft_putstr("Hello World!");
    write(1, "\n", 1); // Test visuel + ligne finale
    return 0;
}
📂 src/ft_putstr.c

c
Copier
Modifier
#include <unistd.h>

void ft_putstr(char *str)
{
    while (*str)
    {
        write(1, str, 1);
        str++;
    }
}
📂 include/ft_putstr.h

c
Copier
Modifier
#ifndef FT_PUTSTR_H
# define FT_PUTSTR_H

void ft_putstr(char *str);

#endif
🧱 Structure du projet :

bash
Copier
Modifier
ex13/
├── include/
│   └── ft_putstr.h
├── src/
│   └── ft_putstr.c
├── test/
│   ├── main.c
│   ├── expected.txt
│   └── test.sh
└── Makefile
✅ expected.txt

nginx
Copier
Modifier
Hello World!
✅ test/test.sh

bash
Copier
Modifier
#!/bin/bash

gcc -I ../include ../src/ft_putstr.c main.c -o test_putstr
./test_putstr > output.txt
diff output.txt expected.txt && echo "✅ OK" || echo "❌ FAIL"
✅ Makefile (à la racine ex13/)

makefile
Copier
Modifier
NAME = test_putstr
SRC = test/main.c src/ft_putstr.c
INC = -I include

all:
  gcc $(INC) $(SRC) -o $(NAME)

clean:
  rm -f $(NAME) test/output.txt

fclean: clean

re: fclean all
🔍 Reverse Engineering & Analyse ASM

📦 Objectif : comprendre comment ft_putstr se traduit dans le binaire final.

📎 nm
bash
Copier
Modifier
nm test_putstr | grep ft_putstr
Affiche l'adresse du symbole. Exemple :

r
Copier
Modifier
0000000000001149 T ft_putstr
🧠 objdump -d (désassemblage)
bash
Copier
Modifier
objdump -d test_putstr | grep -A20 ft_putstr
Tu verras quelque chose comme :

perl
Copier
Modifier
0000000000001149 <ft_putstr>:
 1149:   55                      push   %rbp
 114a:   48 89 e5                mov    %rsp,%rbp
 114d:   48 89 7d f8             mov    %rdi,-0x8(%rbp)
 1151:   eb 0f                   jmp    1162 <ft_putstr+0x19>
...
Cela montre que le compilateur transforme ta boucle while (*str) en un ensemble d’instructions bas niveau (mov, cmp, jmp, call).

📘 Bonus : ASM logique pédagogique
Voici une version symbolique de ce que fait ft_putstr :

asm
Copier
Modifier
ft_putstr:
    mov rsi, str        ; adresse de la chaîne
.loop:
    cmp byte ptr [rsi], 0 ; si str[i] == '\0'
    je .done
    mov dl, [rsi]       ; copie str[i]
    mov edi, 1          ; fd = 1 (stdout)
    call write
    inc rsi
    jmp .loop
.done:
    ret
📌 À retenir :

Commande  Rôle
nm  Voir les fonctions visibles dans le binaire
objdump -d  Voir les instructions assembleur
strings Affiche les chaînes présentes dans le binaire
readelf -s  Montre les symboles ELF

🧠 Note pédagogique finale :
Cet exercice est beaucoup plus profond qu’il n’y paraît : il pose les fondations pour comprendre comment fonctionne l’affichage dans un OS, et prépare aux fonctions plus complexes comme printf, ou aux interactions systèmes avancées.

-------------------------------------------------

## 0.0.14) ex14: ft_strlen

-------------------------------------------------

**Le but :**
Calculer la longueur d'une chaîne de caractères.

**Prototype :**

```c
int ft_strlen(char *str);
```
**Explication :**
>Parcourir la chaîne caractère par caractère.
>Compter jusqu'à rencontrer le caractère nul (\0).
>Retourner ce compteur.

**Interdictions :**

❌ Pas de strlen

✅ Parcourir manuellement

💬 Bulle d'ami :
"Le silence (\0) marque toujours la fin d'une belle histoire."

🎯 Mini-TDD :
Écris un test pour vérifier que "hello" retourne 5.

✅ main.c

```c
#include <unistd.h>

int ft_strlen(char *str);
void ft_putnbr(int nb);
void ft_putstr(char *str);

int main(void)
{
    int len = ft_strlen("hello");

    ft_putstr("Résultat : ");
    ft_putnbr(len);
    write(1, "\n", 1); // Résultat attendu : 5

    return 0;
}
```

✅ expected.txt

Résultat : 5

✅ Makefile
makefile

NAME = test_strlen
SRC = main.c ft_strlen.c ft_putstr.c ft_putnbr.c

all:
  gcc $(SRC) -o $(NAME)

clean:
  rm -f $(NAME)

✅ test.sh
bash

#!/bin/bash

gcc main.c ft_strlen.c ft_putstr.c ft_putnbr.c -o test_strlen
./test_strlen > output.txt
diff output.txt expected.txt && echo "OK" || echo "FAIL"

✅ Résultat attendu

Résultat : 5


-------------------------------------------------

## 0.0.15) ex15: ft_strcpy

-------------------------------------------------

**Le but :**
Copier une chaîne de caractères dans une autre.

**Prototype :**

```c
char *ft_strcpy(char *dest, char *src);
```
**Explication :**
Parcourir la chaîne source caractère par caractère,
et copier chaque caractère dans dest, y compris le caractère nul \0 final.

**Interdictions :**

❌ Pas de strcpy

✅ Tout à la main

💬 Bulle d'ami :
"Copier, c'est respecter jusqu'au dernier détail."

🎯 Mini-TDD :
Écris un test pour copier "abc" dans un tableau et vérifier.

📂 main.c :

```c

#include <unistd.h>

void ft_putstr(char *str);
char *ft_strcpy(char *dest, char *src);

int main(void)
{
  char src[] = "abc";
  char dest[10];

  ft_strcpy(dest, src);

  ft_putstr("Résultat : ");
  ft_putstr(dest);
  write(1, "\n", 1); // Résultat attendu : abc

  return 0;
}
```
✅ expected.txt :

Résultat : abc

✅ Makefile :
makefile

NAME = test_strcpy
SRC = main.c

all:
  gcc $(SRC) -o $(NAME)

clean:
  rm -f $(NAME)

✅ test.sh :
bash

#!/bin/bash

gcc main.c -o test_strcpy
./test_strcpy > output.txt
diff output.txt expected.txt && echo "OK" || echo "FAIL"

🧪 Résultat attendu si tout est correct :
nginx

OK

-------------------------------------------------

## 0.0.16) ex16: ft_strncpy

-------------------------------------------------

**Le but :**
Copier jusqu'à n caractères d'une chaîne source vers une destination.

**Prototype :**

```c
char *ft_strncpy(char *dest, char *src, unsigned int n);
```
**Explication :**
>Parcourt la chaîne `src` et copie caractère par caractère jusqu’à `n` caractères.
>Si `src` est plus court que `n`, le reste de `dest` est rempli de `\0`.

**Interdictions :**

❌ Pas de strncpy

✅ Tout écrire toi-même

💬 Bulle d'ami :
"Quand tu copies avec soin, même ce qui reste doit être propre."

🎯 Mini-TDD :
Écris un test pour copier "test" avec n = 6, et vérifie que dest contient :
  >'t', 'e', 's', 't', '\0', '\0'

📂 main.c :

```c
#include <unistd.h>

char *ft_strncpy(char *dest, char *src, unsigned int n);
// Affiche un tableau de caractères sous forme brute (octets)
void print_buffer(char *str, unsigned int n);

int main(void)
{
    char dest[10] = "xxxxxxxxx";
    ft_strncpy(dest, "test", 6); // on copie "test" dans dest avec n = 6
    print_buffer(dest, 6);       // attendu : test.. (avec deux \0)
    return 0;
}
```

✅ expected.txt
bash

test..

✅ Makefile
makefile

# Makefile
NAME = test_strncpy
SRC = main.c

all:
  gcc $(SRC) -o $(NAME)

clean:
  rm -f $(NAME)

✅ test.sh
sh

#!/bin/bash

gcc main.c -o test_strncpy
./test_strncpy > output.txt
diff output.txt expected.txt && echo "OK" || echo "FAIL"

-------------------------------------------------

## 0.0.17) ex17: ft_str_is_alpha

-------------------------------------------------

**Le but :**
Vérifier si une chaîne ne contient que des lettres.

**Prototype :**

c
Copier ou Modifier

```c
int ft_str_is_alpha(char *str);
```
**Explication :**
Parcourir et tester chaque caractère.

**Interdictions :**

❌ Pas de fonctions toutes faites

✅ Comparer manuellement

💬 Bulle d'ami :
"Chaque mot est fait uniquement de lettres... ou pas."

🎯 Mini-TDD :
Écris un test pour vérifier "Hello" (ok) et "Hello83" (pas ok).

✅ Programme de test (main.c) :
```c
#include <unistd.h>

int ft_str_is_alpha(char *str);
// Affichage d'un entier
void ft_putnbr(int nb);
// Affichage d'une chaîne
void ft_putstr(char *str);


int main(void)
{
    int r1 = ft_str_is_alpha("Hello");
    int r2 = ft_str_is_alpha("Hello83");

    ft_putstr("Test 1 (\"Hello\") : ");
    ft_putnbr(r1);
    write(1, "\n", 1);

    ft_putstr("Test 2 (\"Hello42\") : ");
    ft_putnbr(r2);
    write(1, "\n", 1);

    return 0;
}
```

✅ expected.txt :
nginx

Test 1 ("Hello") : 1
Test 2 ("Hello83") : 0

✅ Makefile :
makefile

NAME = test_str_is_alpha
SRC = main.c ft_str_is_alpha.c

all:
  gcc $(SRC) -o $(NAME)

clean:
  rm -f $(NAME)

✅ test.sh :
bash

#!/bin/bash

gcc main.c ft_str_is_alpha.c -o test_str_is_alpha
./test_str_is_alpha > output.txt
diff output.txt expected.txt && echo "OK" || echo "FAIL"

-------------------------------------------------

## 0.0.18) ex18: ft_str_is_numeric

-------------------------------------------------

**Le but :**
Vérifier si une chaîne ne contient que des chiffres.

**Prototype :**

```c
int ft_str_is_numeric(char *str);
```
**Explication :**
Tester si chaque caractère est entre '0' et '9'.

**Interdictions :**

❌ Pas de isdigit

✅ Comparer manuellement

💬 Bulle d'ami :
"Un code secret n'est fait que de chiffres."

🎯 Mini-TDD :
Écris un test pour vérifier "123456" (ok) et "123abc" (pas ok).

💡 Une chaîne vide est considérée comme valide (retourne 1).

-------------------------------------------------

## 0.0.19) ex19: ft_str_is_lowercase

-------------------------------------------------

**Le but :**
Vérifier si une chaîne ne contient que des minuscules.

**Prototype :**

c
Copier ou Modifier

```c
int ft_str_is_lowercase(char *str);
```
**Explication :**
Vérifier si chaque caractère est entre 'a' et 'z'.

**Interdictions :**

❌ Pas de fonction externe

✅ Utiliser uniquement des comparaisons

💬 Bulle d'ami :
"Les minuscules murmurent, mais elles sont fidèles."

🎯 Mini-TDD :
Écris un test pour vérifier "bonjour" (ok) et "BonJour" (pas ok).

-------------------------------------------------

# Piscine Boostée - Bloc 1 (Partie 3/5) — Nouveau Format [🟢 Facile]

-------------------------------------------------

## 0.0.20) ex20: ft_str_is_uppercase

-------------------------------------------------

**Le but :**
Vérifier si une chaîne ne contient que des majuscules.

**Prototype :**

```c
int ft_str_is_uppercase(char *str);
```
**Explication :**
Vérifier chaque caractère entre 'A' et 'Z'.

**Interdictions :**

❌ Pas de isupper

✅ Comparaison directe obligatoire

💬 Bulle d'ami :
"Les majuscules hurlent pour se faire remarquer."

🎯 Mini-TDD :
Écris un test pour "HELLO" (ok) et "Hello" (pas ok).
🔁 Bonus : que renvoie " " (vide) ? Devrait-il être considéré comme valide ?
🔎 Indice : utilise une boucle et vérifie si chaque caractère est entre 'A' et 'Z'.

-------------------------------------------------

## 0.0.21) ex21: ft_str_is_printable

-------------------------------------------------

**Le but :**
Vérifier si une chaîne ne contient que des caractères imprimables.

**Prototype :**

```c
int ft_str_is_printable(char *str);
```
**Explication :**
Tester que chaque caractère est dans la plage ASCII imprimable.

**Interdictions :**

❌ Pas de fonction toute faite

✅ Comparaison avec les codes ASCII

💬 Bulle d'ami :
"Ce qu'on ne voit pas peut cacher des erreurs."

🎯 Mini-TDD :
Écris un test pour vérifier "test" (ok) et une chaîne avec \n (pas ok).
🔁 Bonus : que fait une chaîne vide ? Est-elle "imprimable" ?
🔎 Indice : la plage ASCII imprimable va de 32 à 126 inclus.

-------------------------------------------------

## 0.0.22) ex22: ft_strupcase

-------------------------------------------------

**Le but :**
Transformer tous les caractères minuscules d'une chaîne en majuscules.

**Prototype :**

```c
char *ft_strupcase(char *str);
```
**Explication :**
Détecter les minuscules et les transformer en majuscules ASCII.

**Interdictions :**

❌ Pas d'appel à toupper

✅ Travail ASCII manuel

💬 Bulle d'ami :
"Quand tu cries plus fort, tu passes en majuscule."

🎯 Mini-TDD :
Écris un test sur `"hello"` pour obtenir `"HELLO"`.
🔁 Bonus : Essaie avec `"HeLlo83!"` pour vérifier que les chiffres et majuscules sont conservés.
🔎 Indice : la conversion se fait en soustrayant 32 du code ASCII.

-------------------------------------------------

## 0.0.23) ex23: ft_strlowcase

-------------------------------------------------

**Le but :**
Transformer tous les caractères majuscules d'une chaîne en minuscules.

**Prototype :**

```c
char *ft_strlowcase(char *str);
```
**Explication :**
Détecter les majuscules et les transformer en minuscules ASCII.

**Interdictions :**

❌ Pas d'appel à tolower

✅ Travail ASCII obligatoire

💬 Bulle d'ami :
"Descendre le ton, c'est passer de majuscule à minuscule."

🎯 Mini-TDD :
Tester `"HELLO"` et obtenir `"hello"`.
🔁 Bonus : Essaie avec `"HEllO42!"` → `"hello42!"` pour vérifier que les chiffres et minuscules sont conservés.
🔎 Indice : en ASCII, tu peux transformer une majuscule en minuscule en ajoutant 32.

-------------------------------------------------

## 0.0.24) ex24: ft_strcapitalize

-------------------------------------------------

**Le but :**
Mettre la première lettre de chaque mot en majuscule et les autres en minuscules.

**Prototype :**

```c
char *ft_strcapitalize(char *str);
```
**Explication :**
Détecter les débuts de mots et ajuster les majuscules/minuscules.

**Interdictions :**

❌ Pas de fonction externe

✅ Gérer tout toi-même

💬 Bulle d'ami :
"Chaque début est important, le reste suit doucement."

🎯 Mini-TDD :
Tester `"salut, comment tu vas ?"` → `"Salut, Comment Tu Vas ?"`
🔁 Bonus : Essaie aussi avec `"sALUT, 42mOtS tEst!"` → `"Salut, 42mots Test!"`
🔎 Rappel : un mot commence après un caractère non-alphanumérique.

💡 Indice ASCII : 
- majuscule → minuscule : `+32` si entre 'A' et 'Z'
- minuscule → majuscule : `-32` si entre 'a' et 'z'

-------------------------------------------------

## 0.0.25) ex25: ft_strlcpy

-------------------------------------------------

**Le but :**
Copier une chaîne dans une autre avec gestion du buffer size.

**Prototype :**

```c
unsigned int ft_strlcpy(char *dest, char *src, unsigned int size);
```
**Explication :**
Copier jusqu'à size-1 caractères et terminer par \0.

**Interdictions :**

❌ Pas de strlcpy

✅ Faire tout manuellement

💬 Bulle d'ami :
"Protéger la taille, c'est respecter la mémoire."

🎯 Mini-TDD :
Tester la copie de "hello" avec size = 3 → dest doit contenir "he\0"
🔎 Rappel : la fonction retourne la longueur de src, même si la copie est tronquée.
🔁 Bonus : Tester avec size = 0 → dest ne doit pas être modifié, retour = 5

-------------------------------------------------

## 0.0.26) ex26: ft_putstr_non_printable

-------------------------------------------------

**Le but :**
Afficher une chaîne, remplacer les caractères non imprimables par leur valeur hexadécimale.

**Prototype :**
```c
void ft_putstr_non_printable(char *str);
```

**Explication :**
Si un caractère n'est pas imprimable, afficher \ suivi de son code hexadécimal.

**Interdictions :**

❌ Pas d'utilisation de printf/hex fonctions automatiques

✅ Construction manuelle

💬 Bulle d'ami :
"Si tu ne peux pas le lire, écris son nom secret."

ℹ️ Un caractère est considéré comme non imprimable s’il est hors de la plage ASCII 32 à 126.

🎯 Mini-TDD :
Tester "Coucou\ntu vas bien ?" et vérifier l'affichage.
🔁 Bonus : Tester une chaîne contenant \a, \t, \v et \x7F pour explorer plus de cas non imprimables.
🧩 Astuce : Pour convertir un octet en hexadécimal, divise par 16 pour obtenir le premier chiffre, puis le modulo pour le second.

-------------------------------------------------
## 0.0.27) ex27: ft_print_memory (Partie 1)
-------------------------------------------------
Le but :
Afficher l'état brut de la mémoire d'une chaîne.

**Prototype :**
```c
void *ft_print_memory(void *addr, unsigned int size);
```
**Explication :**
Afficher l'adresse mémoire suivie de 16 octets imprimables ou représentés en hexadécimal.

🔍 Pour chaque ligne :
- Afficher l’adresse mémoire (en hexadécimal sur 16 caractères).
- Afficher les 16 octets en hexadécimal, séparés deux à deux.
- Afficher les 16 caractères ASCII imprimables ou `.` pour les autres.

💡 Ce type d’affichage est similaire à la commande `hexdump`.

**Interdictions :**

❌ Pas de bibliothèque externe

✅ Respecter l'affichage proprement

💬 Bulle d'ami :
>"La mémoire est une histoire invisible qu'il faut écrire ligne par ligne."
>Astuce : Tu as déjà converti des caractères non imprimables en hexadécimal dans ex26. Ici, tu le fais de manière systématique, avec l'adresse comme bonus.

🎯 Mini-TDD :
Créer un petit tableau de caractères et tester ft_print_memory.

```c
char data[] = "Hello World! 83 \n";

ft_print_memory(data, sizeof(data));
```
Exemple de ligne à produire (format indicatif) :
0x0000000000abc000: 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 20 38 33 0a  Hello World! 83.

-------------------------------------------------
# Piscine Boostée - Bloc 1 (Partie 4/5) — Nouveau Format [🟢 Facile]
-------------------------------------------------
📚 Exercices BONUS spéciaux — Piscine Boostée
-------------------------------------------------
## 0.1.0) ex28: ft_recursive_factorial
-------------------------------------------------
Le but :
Calculer la factorielle d'un nombre (n!) en utilisant la récursion.

**Prototype :**

```c
int ft_recursive_factorial(int nb);
```
**Explication :**
Utiliser une fonction qui s'appelle elle-même pour multiplier les nombres de n à 1.

**Interdictions :**

❌ Pas de boucles (for, while)

✅ Récursion obligatoire

💬 Bulle d'ami :
"Parfois, pour aller au sommet, il faut redescendre chaque marche."

🎯 Mini-TDD :
Tester ft_recursive_factorial(5) ➔ résultat attendu: 120.

💡 Et si nb vaut 0 ? Ou un nombre négatif ? Penses-y !

-------------------------------------------------
## 0.1.1) ex29: ft_iterative_factorial
-------------------------------------------------
Le but :
Calculer la factorielle d'un nombre (n!) en utilisant des boucles.

**Prototype :**

```c
int ft_iterative_factorial(int nb)
```
**Explication :**
Utiliser une boucle pour multiplier les nombres jusqu'à n.

**Interdictions :**

❌ Pas de récursion

✅ Boucles uniquement

💬 Bulle d'ami :
"Pas besoin de creuser, avance pas à pas jusqu'au sommet."

🎯 Mini-TDD :
Tester ft_iterative_factorial(4) ➔ résultat attendu: 24.

💡 Et si nb vaut 0 ou moins ? Ton algorithme devrait-il le gérer ?

-------------------------------------------------
## 0.1.2) ex30: ft_recursive_power
-------------------------------------------------
Le but :
Calculer la puissance d'un nombre nb exposant power par récursion.

**Prototype :**
```c
int ft_recursive_power(int nb, int power);
```
**Explication :**
Utiliser une fonction récursive pour multiplier plusieurs fois.

**Interdictions :**

❌ Pas de boucle

✅ Récursion uniquement

💬 Bulle d'ami :
"Chaque pas en avant double ta force."

🎯 Mini-TDD :
Tester ft_recursive_power(2, 3) ➔ résultat attendu: 8.

💡 Et si la puissance est négative ? Que doit-on faire ?
💡 Variante : après avoir exploré la récursion, voyons maintenant comment le même problème peut se résoudre sans appel récursif, avec des boucles uniquement.

-------------------------------------------------
## 0.1.3) ex31: ft_iterative_power
-------------------------------------------------
Le but :
Calculer la puissance d'un nombre par itération.

**Prototype :**

```c
int ft_iterative_power(int nb, int power);
```
**Explication :**
Utiliser une boucle pour multiplier successivement.

**Interdictions :**

❌ Pas de récursion

✅ Utiliser uniquement des boucles

💬 Bulle d'ami :
"Les petits pas répétés construisent des montagnes."

🎯 Mini-TDD :
Tester ft_iterative_power(3, 2) ➔ résultat attendu: 9.

-------------------------------------------------
## 0.1.4) ex32: ft_fibonacci
-------------------------------------------------
Le but :
Trouver le n-ième nombre de la suite de Fibonacci.

**Prototype :**
```c
int ft_fibonacci(int index);
```
**Explication :**
La suite commence par 0, 1, et chaque nombre est la somme des deux précédents.

**Interdictions :**

❌ Pas d'itération

✅ Récursion obligatoire

💬 Bulle d'ami :
"La nature pousse en Fibonacci, doucement mais sûrement."

🎯 Mini-TDD :
Tester ft_fibonacci(7) ➔ résultat attendu: 13.

🧠 Remarque : Cette version est correcte mais peu efficace pour de grands index. On verra plus tard comment améliorer cela avec des techniques comme la mémoïsation.

-------------------------------------------------
## 0.1.5) ex33: ft_sqrt
-------------------------------------------------

Le but :
Calculer la racine carrée entière d'un nombre.

**Prototype :**

```c
int ft_sqrt(int nb);
```
**Explication :**
Trouver un entier qui multiplié par lui-même donne nb.

**Interdictions :**

❌ Pas d'utilisation de sqrt de math.h

✅ Boucle ou approche progressive obligatoire

💬 Bulle d'ami :
"Trouver la racine, c'est creuser jusqu'à tomber juste."

🧠 Remarque : Pense à tester pour nb = 0, 1, 2, et les grands nombres pour bien gérer les bornes.

🎯 Mini-TDD :
Tester ft_sqrt(16) ➔ résultat attendu: 4.
Tester ft_sqrt(20) ➔ résultat attendu: 0 (car 20 n’a pas de racine carrée entière).

-------------------------------------------------
## 0.1.6) ex34: ft_is_prime
-------------------------------------------------

Le but :
Déterminer si un nombre est premier.

**Prototype :**

```c
int ft_is_prime(int nb);
```
**Explication :**
Tester si un nombre n'a pas de diviseur autre que 1 et lui-même.


**Interdictions :**

❌ Pas de bibliothèque mathématique

✅ Boucles autorisées

💬 Bulle d'ami :
"Un nombre premier est un solitaire, il ne se laisse diviser par personne."

🧠 Pense à tester aussi les cas limites comme 0, 1, 2, ou les grands nombres.

🎯 Mini-TDD :
Tester ft_is_prime(13) ➔ attendu: 1 (vrai).
Tester ft_is_prime(12) ➔ attendu: 0 (faux).

-------------------------------------------------
## 0.1.7) ex35: ft_find_next_prime
-------------------------------------------------
Le but :
Trouver le nombre premier suivant ou égal à un nombre donné.

**Prototype :**

```c
int ft_find_next_prime(int nb);
```
**Explication :**
Avancer jusqu'à trouver un nombre premier supérieur ou égal.

**Interdictions :**

❌ Utiliser seulement ce que tu sais

✅ Boucle + appel de ft_is_prime possible

💬 Bulle d'ami :
"Si ton chemin est barré, avance jusqu'à trouver la voie royale."

🧠 Astuce :
N’oublie pas de gérer les cas < 2 (il n’y a pas de nombre premier < 2).

🎯 Mini-TDD :
Tester ft_find_next_prime(14) ➔ attendu : 17  
Pense aussi à vérifier ft_find_next_prime(17) ➔ attendu : 17

-------------------------------------------------
# Piscine Boostée - Bloc 1 (Partie 5/5) — Nouveau Format [🟢 Facile]
-------------------------------------------------

📚 Explications générales de fin de Piscine Boostée

-------------------------------------------------
## 📋 Ce que tu as appris dans la Piscine
-------------------------------------------------
Maîtriser les boucles (while, for),

Utiliser les pointeurs,

Manipuler la mémoire,

Créer des chaînes de caractères manuellement,

Commencer à penser en récursion,

Tester ton code (TDD minimal),

Respecter une structure de projet claire.

🚀 Introduction au TDD (Test Driven Development)
À partir de maintenant, tu dois appliquer TDD dès que possible !

📢 Comment faire ton TDD minimal ?

Voici une méthode simple, efficace et réutilisable :

| Étape | Action à effectuer                                      |
|-------|---------------------------------------------------------|
| 1️⃣     | Avant de coder ta fonction, écris une fonction de test. |
| 2️⃣     | Vérifie que ta fonction retourne bien le bon résultat.  |
| 3️⃣     | Si ton test échoue ➔ tu corriges ta fonction.          |
| 4️⃣     | Si ton test passe ➔ tu peux passer à l'étape suivante. |

-------------------------------------------------
📋 Exemples de TDD minimal pour Piscine

-------------------------------------------------
Tester ft_putchar :

```c
// Test minimal
void test_ft_putchar(void)
{
 ft_putchar('A');
}
(Vérifier que 'A' s'affiche.)

```
Tester ft_strlen :

```c
void test_ft_strlen(void)
{

 int len = ft_strlen("hello");
 // À vérifier en lisant la valeur (dans de vrais tests, tu pourrais afficher avec printf temporairement)
}
```

📌 Conseil final :

N'oublie pas : ce que tu testes te protège.
Un bon test, même petit, t’évitera des erreurs plus tard.

-------------------------------------------------
📋 Petit guide pour ton projet Piscine

-------------------------------------------------
📚 Structure obligatoire dès maintenant

-------------------------------------------------
>À partir des prochains exercices (et dès Libft++), tu devrass structurer chaque projet ainsi :

```sh

projet/
├── Makefile
├── src/
│ ├── main.c
│ ├── fonctions.c
│ ├── ...
├── include/
│ ├── projet.h
├── tests/
│ ├── tests_main.c
│ ├── tests_fonctions.c
│ ├── ...
├── bonus/ (facultatif pour exercices bonus)
```
>src/ ➔ tout ton code principal .c
>include/ ➔ tous tes headers .h
>tests/ ➔ tes fichiers de tests pour TDD
>bonus/ ➔ uniquement pour des extensions si demandé

📋 Attention sur la norme 42

**Rappel obligatoire :**

| Règle                        | Détail                               |
|------------------------------|--------------------------------------|
| Longueur max d'une fonction  | 25 lignes maximum                    |
| Indentation                  | 1 tabulation = 4 espaces             |
| Nom des fichiers             | `ft_nom.c`, `ft_nom.h`, etc.         |
| Structures de boucle         | Pas de `for`, pas de `do...while`    |
| Style des variables          | minuscules uniquement (`int ok;`)    |

📦 Exemple de projet structuré

```sh
ft_strlen/
├── Makefile
├── src/
│   └── ft_strlen.c
├── include/
│   └── ft_strlen.h
├── tests/
│   └── test_ft_strlen.c
```

📚 Glossaire rapide pour t'aider

Mot Définition
Pointeur     = Une variable qui contient une adresse mémoire
Récursion    = Une fonction qui s'appelle elle-même
TDD          = Test Driven Development: tester ton code avant de le terminer
Modularité   = Organiser ton code proprement par modules/fichiers
Arborescence = La structure des dossiers de ton projet
Norme        =Ensemble de règles strictes de codage (indentation, lignes max, etc.)

🎯 Résumé de la Piscine Boostée

Tu sais faire maintenant Résultat
Manipuler des caractères, chiffres, chaînes ✅ Oui
Utiliser write, pointeurs, boucles, récursion ✅ Oui
Commencer à tester ton code sérieusement ✅ Oui
Suivre une structure de projet propre ✅ Oui
📢 Et maintenant ?
✅ Bloc 1 (Piscine Boostée complète) terminé, [🟢 Facile]
✅ Tu es prêt à attaquer Bloc 2 ➔ Libft++ et projets plus sérieux, [🟢 Facile]
✅ Avec TDD qui va devenir progressivement plus costaud.

📢🛡️ Fin du Bloc 1 Boosté — Félicitations ! [🟢 Facile]

🧠 Tu viens de franchir une première montagne.
La suite sera plus exigeante, mais tu as déjà les outils pour créer, tester, et structurer comme un(e) vrai(e) développeur(se).

Bienvenue dans le monde des vrais projets.

══════════════════════════════════════════════════════════════════════════
# Bloc 2 — Libft++ Boostée — Partie 1/? [🟢 Facile]
══════════════════════════════════════════════════════════════════════════
📚 Introduction — Libft++ Partie 1

Dans cette nouvelle étape, tu vas commencer à recréer toi-même **les fonctions essentielles du langage C**, sans utiliser aucune fonction de la librairie standard.

🎯 Objectifs :

- Comprendre précisément le comportement bas niveau de chaque fonction.
- Gérer correctement la mémoire, les pointeurs et les chaînes.
- Structurer ton code comme une véritable **librairie réutilisable**.
- Appliquer le **TDD (Test Driven Development)** pour fiabiliser ton code.

🚀 Arborescence obligatoire pour Libft++
```sh
libft/
├── Makefile
├── src/
│ ├── ft_strlen.c
│ ├── ft_strcpy.c
│ ├── ...
├── include/
│ ├── libft.h
├── tests/
│ ├── tests_ft_strlen.c
│ ├── tests_ft_strcpy.c
│ ├── ...
```

🧪 Règle :
- Chaque fonction .c doit avoir son fichier de test correspondant dans le dossier tests/.
  Exemple :

  - ft_strlen.c → tests/tests_ft_strlen.c
  - ft_strcpy.c → tests/tests_ft_strcpy.c

💡 Compilation type :

```bash
make && ./tests/tests_ft_strlen
```
📢 Astuce :

- Tu peux commencer avec des tests simples (affichage ou retour de valeur), puis les enrichir au fur et à mesure avec
  des cas limites, des valeurs incorrectes, et des scénarios plus exigeants.

✨ “Créer ta propre libft, c’est poser les fondations de ton propre standard de code.”

-------------------------------------------------
## 1.0) ft_strlen
-------------------------------------------------
**🧠 Le but :**
- Calculer la longueur d'une chaîne de caractères.

**📌 Prototype :**

```c
size_t ft_strlen(const char *str);
```
**🧪 Explication :**
Parcourir la chaîne caractère par caractère jusqu'à trouver \0 (fin de chaîne).
- Ta fonction doit :
  - Lire chaque caractère de la chaîne str.
  - Compter chaque caractère tant que ce n’est pas \0.
  - Retourner le nombre total.

**🛑 Interdictions :**
- ❌ strlen
- ❌ Toute fonction de <string.h>

**✅ Tu dois :**
- Utiliser une boucle simple (while)
- Manipuler les pointeurs ou indices à la main

💬 Bulle d'ami :
"Une chaîne prend fin dans le silence (\0), le souffle final que personne n’entend."

🎯 Mini-TDD :
Testez "hello" (devrait retourner 5) et "" (devrait retourner 0).
Crée un fichier de test simple :

```c
#include <unistd.h>
#include "libft.h" // si tu es dans un vrai projet

int main(void)
{
  ...
}
```

🧪 Comment tester automatiquement ?
Par exemple, un fichier test.sh pour chaque fonction :

```sh
#!/bin/bash
gcc -g -Iinclude -o test_ft_strdup tests/tests_ft_strdup.c src/ft_strdup.c src/ft_strcpy.c src/ft_strlen.c
./test_ft_strdup
```

🧱 Structure recommandée :

```sh
libft/
├── Makefile
├── src/
│   └── ft_strlen.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_strlen.c
```
💡 Conseils :

- Utilise un compteur (size_t i = 0) et incrémente-le dans la boucle.
- Ne pas oublier le #include <stddef.h> pour size_t.

🧪 Bonus pour TDD plus poussé :

- Ajoute un test sur une chaîne très longue.
- Ajoute un test sur une chaîne avec des caractères spéciaux.

📦 [Nouveau] Ton Arsenal de Développeur Commence ici 🧠

🛠️ Premiers outils de Développeur Pro : Git, GDB, RE
🧬 Git — Suivre ton travail
💡 Crée un dépôt Git pour ta libft++ :

```bash
cd libft
git init
git add .
git add test.sh
git commit -m "[test] Script de test automatique pour ft_strdup"
git commit -m "Ajout de ft_strlen avec TDD"
```
But : apprendre à faire des commits propres à chaque étape importante.

➡️ Utilise un commit pour chaque fonction terminée (et testée).

🐞 GDB — Premier pas vers le débogage
💡 Compile ton test avec les symboles de debug :

```bash
gcc -g -Iinclude -o test_strlen tests/tests_ft_strlen.c src/ft_strlen.c
```
💡 Lance GDB :

```bash
gdb ./test_strlen
```
Puis tape :

```gdb
break ft_strlen
run
step
print str
```
📚 Ce que tu apprends : comprendre ce que fait réellement ta fonction ligne par ligne, et voir ce que contient chaque variable.

🔍 Reverse Engineering (RE) — Lecture du code machine
💡 Pour observer le code assembleur de ta fonction :

```bash
objdump -d ./test_strlen | less
```
➡️ Cherche la partie correspondant à ft_strlen pour voir comment elle est compilée.

💡 Ou bien utilise :

```bash
nm ./test_strlen | grep ft_strlen
```
➡️ Cela te donne l’adresse de ta fonction. Tu peux la croiser avec objdump.

🎓 Résumé
- Outil À quoi il sert ?
- git Sauvegarder et suivre l'évolution de ton code
- gdb Déboguer pas à pas, inspecter les variables
- objdump, nm Voir ce que ton code devient après compilation (niveau système)

-------------------------------------------------
## 1.1) ft_strcpy
-------------------------------------------------
**🧠 Le but :**
- Copier une chaîne de caractères (`src`) dans une autre (`dest`), y compris le `\0` final.

**📌 Prototype :**
```c
char *ft_strcpy(char *dest, const char *src);
```
🧪 Explication :

Lire chaque caractère de src.

Le copier dans dest, un par un.

Terminer la copie par le caractère nul \0.

Retourner le pointeur dest.

🛑 Interdictions :
- ❌ strcpy
- ❌ Toute fonction de <string.h>

✅ Tu dois :
- Utiliser une boucle while.
- Travailler sur chaque caractère.
- Gérer le \0 correctement.

💬 Bulle d'ami :

"Copier, c'est comme suivre fidèlement une partition de musique, sans se tromper de note."

🎯 Mini-TDD : tests minimalistes

Crée un fichier tests/tests_ft_strcpy.c :

💡 Crée toi-même un test pour vérifier que ft_strcpy("Hello") fonctionne. N'oublie pas le test avec une chaîne vide.
2. Ajout d’un tableau de cas limites à compléter par l’élève :
Cas de test                     Résultat attendu                       À faire ?
Chaîne normale"Test"                "Test"                               🔲
Chaîne vide                         ""  ""                               🔲
Chaîne très longue                    ???                                🔲
src et dest sont égaux ?              ???                                🔲
src contient des caractères spéciaux  ???                                🔲

💡 Bonus pédagogique : demande à l'élève de remplir ce tableau avant de coder la fonction, pour lui apprendre à penser comme un testeur.

🧱 Structure recommandée :

```sh
libft/
├── Makefile
├── src/
│   └── ft_strcpy.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_strcpy.c
```
💡 Conseils :
- Utilise une variable int i = 0 pour parcourir src.
- Copie src[i] dans dest[i] jusqu’à \0.
- N’oublie pas de copier le \0 final.

📦 Ajout Git obligatoire :

```bash
git add src/ft_strcpy.c tests/tests_ft_strcpy.c include/libft.h
git commit -m "Ajout de ft_strcpy avec tests TDD"
git commit -m "[feat] ft_strcpy: copie manuelle de chaîne avec TDD minimal"
```

🧩 Convention Git pro : [feat], [fix], [refactor], [test], [doc], [chore]

🔍 Détail des balises :
Balise  Signification Exemple de message de commit
- [feat]  Nouvelle fonctionnalité [feat] ft_strcpy: copie manuelle de chaîne
- [fix] Correction de bug [fix] ft_strlen: corrige le comptage avec NULL
- [test]  Ajout ou modification de tests  [test] Ajoute des cas limites pour ft_strdup
- [refactor]  Refactorisation sans changer le comportement  [refactor] simplifie la boucle dans ft_strcmp
- [doc] Documentation, commentaires, README [doc] Ajoute explication dans README pour ft_strcpy
- [chore] Tâche annexe (Makefile, structure, config)  [chore] Init projet + structure dossiers

📘 Exemple réel dans ton projet
````bash
git commit -m "[feat] ft_strdup: duplication dynamique avec malloc"
git commit -m "[test] ft_strdup: ajoute tests avec chaînes longues"
git commit -m "[doc] ft_strdup: ajoute explication dans README.md"
git commit -m "[refactor] ft_strcpy: simplifie copie caractère par caractère"
```
✨ Bonus : format complet recommandé
```bash
[type] nom_fichier: action courte au présent
```
Tu peux ajouter une description plus longue avec git commit sans -m, dans un éditeur.

📌 À retenir :
🔧 [feat] = nouvelle capacité
🛠 [fix] = réparation
🔬 [test] = ajout de tests
🧹 [refactor] = nettoyage sans effet externe
📖 [doc] = changement de documentation
🧱 [chore] = tout le reste (infra, config, etc.)

🐞 GDB – Débogage :
Compile ton test avec symboles debug :

```bash
gcc -g -Iinclude -o test_strcpy tests/tests_ft_strcpy.c src/ft_strcpy.c
```
Lance GDB :

```bash
gdb ./test_strcpy
```
Dans GDB :

```gdb
break ft_strcpy
run
step
print i
print dest
print src
continue
```
🔍 Reverse Engineering – objdump + nm :
Afficher le code assembleur de ft_strcpy :

```bash
nm ./test_strcpy | grep ft_strcpy
# Exemple de sortie : 0000000000001139 T ft_strcpy

objdump -d ./test_strcpy | less
# Va à l'adresse 0x1139 pour lire le code machine de ta fonction
```
ou via GDB :

✅ Lire le code machine dans GDB (désassemblage)
Lance ton programme dans GDB :

```bash
gdb ./test_strcpy
```
Trouve l'adresse de la fonction ft_strcpy :

```gdb
info functions ft_strcpy
```
ou directement :

```gdb
disassemble ft_strcpy
```
💡 Cela te montre le code assembleur généré par le compilateur pour la fonction ft_strcpy.

📌 Exemple d'utilisation :
```bash
(gdb) break ft_strcpy
(gdb) run
(gdb) disassemble ft_strcpy
```
Tu verras une sortie comme :

```perl

Dump of assembler code for function ft_strcpy:
   0x0000000000001139 <+0>:   push   %rbp
   0x000000000000113a <+1>:   mov    %rsp,%rbp
   ...
End of assembler dump.
```
🔎 Bonus : Voir ligne par ligne l'exécution
Après le break et run :

```bash
(gdb) layout asm
````
Cela te donne une vue interactive du code assembleur dans certains GDB (notamment gdb-tui).

📘 README (optionnel mais pro) :
Ajoute un bloc dans README.md :

```md
### ft_strcpy

- But : Copier une chaîne dans une autre (char * -> char *).
- Cas limites testés :
  - Chaîne vide
  - Chaîne longue
- Commandes utilisées :
  - `gdb`, `objdump`, `nm`, `git`
- Complexité : O(n)
```
📌 À retenir de cet exercice

- Chaque caractère est une donnée à part entière.
- Ne jamais oublier le \0 dans une chaîne C.
- GDB peut te montrer **exactement** ce que ta boucle fait.
- Le code machine révèle comment ton code est traduit.
- Un bon test = un développeur serein.

**🧠 Le but :**
- Allouer une nouvelle chaîne de caractères en mémoire dynamique et y copier le contenu de `src`.

**📌 Prototype :**
```c
char *ft_strdup(const char *src);
```
🧪 Explication :

Calculer la longueur de src avec ft_strlen.
Allouer dynamiquement assez de mémoire (malloc) pour y copier src (n caractères + 1 pour \0).
Copier src dans le nouvel espace mémoire avec ft_strcpy.
Retourner le pointeur vers la nouvelle chaîne.

🛑 Interdictions :

❌ strdup
❌ Toute fonction de <string.h>
❌ strlen, strcpy (sauf ft_ versions maison)

✅ Tu dois :

Utiliser malloc
Appeler ft_strlen et ft_strcpy
Vérifier que malloc ne retourne pas NULL
Libérer la mémoire dans tes tests après usage

💬 Bulle d'ami :

"Dupliquer, c'est offrir un clone fidèle, pas juste une imitation."

🎯 Mini-TDD – Test de base :

Crée un fichier tests/tests_ft_strdup.c :

```c
#include <unistd.h>
#include "libft.h"

int main(void)
{
  ...
}
```
🧪 Tableau de Cas Limites – À compléter par toi-même :

Cas de test Résultat attendu  À faire ?
src = "Hello" "Hello", nouvelle adresse 🔲
src = ""  "", nouvelle adresse  🔲
src avec caractères spéciaux  identique 🔲
src très long identique, pas de segfault  🔲
malloc échoue (cas théorique) NULL  🔲

📦 Ajout Git recommandé :

```bash
git add src/ft_strdup.c tests/tests_ft_strdup.c include/libft.h
git commit -m "[feat] ft_strdup: duplication dynamique de chaîne"
```

🐞 GDB – Debug pas à pas :

```bash
gcc -g -Iinclude -o test_strdup tests/tests_ft_strdup.c src/ft_strdup.c src/ft_strlen.c src/ft_strcpy.c
gdb ./test_strdup
```

```gdb
break ft_strdup
run
step
print src
print dest
continue
````
🔍 Reverse Engineering – objdump + nm :

```bash
nm ./test_strdup | grep ft_strdup
objdump -d ./test_strdup | less
```
Ou directement dans GDB :

```gdb
disassemble ft_strdup
```
📘 README.md (optionnel mais pro) :

```md
### ft_strdup

- But : Dupliquer une chaîne en mémoire dynamique.
- Cas limites testés :
  - Chaîne vide
  - Chaîne longue
  - Contenu binaire ou caractères spéciaux
- Commandes utilisées :
  - `gdb`, `objdump`, `nm`, `git`
- Complexité : O(n)
- Mémoire : Utilise `malloc`, penser à `free`
```
📌 À retenir de cet exercice :

Une copie dynamique signifie un nouvel emplacement mémoire.
Il est essentiel de libérer ce que malloc réserve.
ft_strdup t’oblige à penser gestion mémoire + modularité (ft_strlen, ft_strcpy).
Observer l’assembleur de ft_strdup te montre le chemin du malloc → boucle de copie → retour.

-------------------------------------------------
## 1.3) ft_strcmp
-------------------------------------------------

**🧠 Le but :**
- Comparer deux chaînes de caractères (`s1` et `s2`) caractère par caractère.
- Retourner :
  - `0` si elles sont égales,
  - Un **entier positif** si `s1 > s2`,
  - Un **entier négatif** si `s1 < s2`.

**📌 Prototype :**
```c
int ft_strcmp(const char *s1, const char *s2);
```
🧪 Explication pédagogique :

On compare les caractères à la même position dans chaque chaîne :

Si les caractères sont identiques, on continue.

Si un caractère diffère, on retourne la différence s1[i] - s2[i].

Si on atteint \0 sans différence : les chaînes sont égales → on retourne 0.

🛑 Interdictions :

❌ strcmp (stdlib)

❌ Toute fonction de <string.h>

✅ Tu dois :

Utiliser une boucle while.

Comparer caractère par caractère.

Ne pas oublier le \0.

💬 Bulle d'ami :

"Comparer, c'est lire attentivement jusqu'à voir une différence."

🎯 Mini-TDD — tests de base :

Crée ce fichier :

```bash
tests/tests_ft_strcmp.c
```
🧪 TDD Étendu — à compléter toi-même :

Cas de test Résultat attendu  À faire ?
- "abc", "abc"  0 🔲
- "abc", "abd"  négatif 🔲
- "abc", "ab" positif 🔲
- "", ""  0 🔲
- "Hello", "Hellp"  négatif 🔲
- "test", ""  positif 🔲
- "AB", "ab"  négatif (ASCII) 🔲

🧱 Structure recommandée :

```bash
libft/
├── Makefile
├── src/
│   └── ft_strcmp.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_strcmp.c
│   └── test_ft_strcmp.sh
```
🧪 Script de test automatisé – test_ft_strcmp.sh

```bash
#!/bin/bash
echo "🔎 Compilation de ft_strcmp..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strcmp tests/tests_ft_strcmp.c src/ft_strcmp.c
if [ $? -ne 0 ]; then
    echo "❌ Compilation échouée."
    exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_strcmp
```
💡 Rends-le exécutable :

```bash
chmod +x tests/test_ft_strcmp.sh
./tests/test_ft_strcmp.sh
```
📦 Ajout Git recommandé :

```bash
git add src/ft_strcmp.c tests/tests_ft_strcmp.c tests/test_ft_strcmp.sh include/libft.h
git commit -m "[feat] ft_strcmp: comparaison caractère par caractère avec TDD"
```
🧩 Convention Git pro utilisée :

Balise  Signification
[feat]  Nouvelle fonctionnalité
[test]  Ajout de tests
[doc] Documentation (README, commentaires, etc.)
[chore] Fichiers annexes (Makefile, scripts, configs)

🐞 Debug via GDB :

```bash
gcc -g -Iinclude -o test_cmp tests/tests_ft_strcmp.c src/ft_strcmp.c
gdb ./test_cmp
```
Dans GDB :

```gdb
break ft_strcmp
run
step
print s1[i]
print s2[i]
```
🔍 Reverse Engineering – objdump + nm :

```bash

nm ./test_cmp | grep ft_strcmp
objdump -d ./test_cmp | less
```
Dans GDB :

```gdb
disassemble ft_strcmp
````
📘 README.md (optionnel mais pro) :

```md
### ft_strcmp

- But : Comparer deux chaînes et retourner la différence du premier caractère distinct.
- Cas limites testés :
  - Chaînes identiques
  - Chaîne vide vs non vide
  - Différence à la fin
- Outils : gdb, objdump, nm, test .sh
- Complexité : O(n)
```

📌 À retenir de cet exercice :

Le retour peut être négatif, nul ou positif, comme dans strcmp.
L'ordre ASCII est important : 'A' < 'a'.
Le \0 compte aussi dans la comparaison.
Tu compares des unsigned char, donc attention aux signes négatifs inattendus (bonus).

-------------------------------------------------
## 1.4) ft_strncpy
-------------------------------------------------
**🧠 Le but :**
- Copier jusqu’à `n` caractères depuis `src` vers `dest`.
- Si `src` est plus courte que `n`, remplir les caractères restants avec `\0`.

**📌 Prototype :**
```c
char *ft_strncpy(char *dest, const char *src, size_t n);
```
🧪 Explication pédagogique :

Tu parcours la chaîne src et copies chaque caractère dans dest, jusqu’à n caractères maximum.
Si src fait moins de n, tu dois compléter dest avec des \0.
La fonction retourne dest.

🛑 Interdictions :

❌ strncpy (stdlib)
❌ Toute fonction de <string.h>

✅ Tu dois :

Utiliser une boucle while ou for.
Gérer les cas où src < n.
Ajouter les \0 restants toi-même.

💬 Bulle d'ami :

"Être précis, c’est aussi savoir s’arrêter au bon moment, et ne rien laisser au hasard."

🎯 Mini-TDD – tests de base :

Crée ce fichier de test :

```bash
tests/tests_ft_strncpy.c
```
💡 Contenu minimaliste :

```c
#include <unistd.h>
#include "libft.h"

int main(void)
{
  ...
}
```
🧪 TDD Étendu — à compléter :

Cas de test Résultat attendu  À faire ?
- "abc", n = 5  "abc\0\0"                   🔲
- "abc", n = 3  "abc"                       🔲
- "abc", n = 1  "a"                         🔲
- "", n = 3 "\0\0\0"                        🔲
- Chaîne longue, n petit  début seulement   🔲

🧱 Structure recommandée :

```css
libft/
├── Makefile
├── src/
│   └── ft_strncpy.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_strncpy.c
│   └── test_ft_strncpy.sh
```
🧪 Script de test automatisé — test_ft_strncpy.sh :

```bash
#!/bin/bash
echo "🔎 Compilation de ft_strncpy..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strncpy tests/tests_ft_strncpy.c src/ft_strncpy.c
if [ $? -ne 0 ]; then
    echo "❌ Compilation échouée."
    exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_strncpy
```
💡 Rends-le exécutable :

```bash
chmod +x tests/test_ft_strncpy.sh
./tests/test_ft_strncpy.sh
```
📦 Ajout Git recommandé :

```bash
git add src/ft_strncpy.c tests/tests_ft_strncpy.c tests/test_ft_strncpy.sh include/libft.h
git commit -m "[feat] ft_strncpy: copie limitée à n caractères avec complétion \\0"
```
🧩 Rappel Convention Git pro :

Balise  Signification
- [feat]  Nouvelle fonctionnalité
- [test]  Ajout de tests
- [refactor]  Refactorisation du code sans changer le résultat
- [doc] Documentation (README, commentaires, etc.)
- [chore] Tâche annexe (scripts, Makefile, arborescence)

🐞 GDB – Debug pas à pas :

```bash
gcc -g -Iinclude -o test_ncpy tests/tests_ft_strncpy.c src/ft_strncpy.c
gdb ./test_ncpy
```
Dans GDB :

```gdb
break ft_strncpy
run
step
print src[i]
print dest[i]
```
🔍 Reverse Engineering — objdump + nm :

```bash
nm ./test_ncpy | grep ft_strncpy
objdump -d ./test_ncpy | less
```
ou dans GDB :

```gdb
disassemble ft_strncpy
```
📘 README.md (optionnel mais pro) :

```md

### ft_strncpy

- But : Copier n caractères depuis une chaîne source.
- Particularité : Complète par \0 si la source est plus courte.
- Cas limites testés :
  - n > taille source
  - n < taille source
  - chaîne vide
- Commandes utilisées :
  - `gdb`, `objdump`, `nm`, `git`, test .sh
- Complexité : O(n)
```

📌 À retenir :

Tu dois remplir avec des \0 si la chaîne source est plus courte.

Ta fonction doit toujours copier n caractères exactement.

Attention aux zones non remplies si tu oublies les \0.

-------------------------------------------------
# Bloc 2 — Libft++ Boostée — Partie 2/? [🟢 Facile]
-------------------------------------------------
📚 Introduction rapide Partie 2
Ici, on entre dans un univers encore plus bas niveau :
➔ Manipuler directement la mémoire (memset, bzero, memcpy, etc.)

Ton cerveau doit maintenant penser comme la mémoire :
octet par octet, sans erreur.

📚 Fonctions de cette Partie 2

-------------------------------------------------
## 2.0) ft_memset
-------------------------------------------------
🧠 Le but :
Remplir un bloc mémoire avec une valeur donnée, octet par octet.

📌 Prototype :

```c
void *ft_memset(void *b, int c, size_t len);
```
🧪 Explication pédagogique :
Tu dois parcourir len octets à partir de b, et écrire la valeur c castée en unsigned char dans chacun.
Cette fonction est très utilisée pour initialiser un buffer, effacer une structure, ou préparer un tableau.
Elle retourne b, ce qui permet de chaîner les appels (ex: if (ft_memset(...)) {...}).

🛑 Interdictions :

❌ memset()
❌ bzero()
❌ Toute fonction de <string.h>

✅ Tu dois :

Utiliser une boucle while ou for
Caster correctement le pointeur void * en unsigned char *
Écrire sur chaque octet exactement une fois

💬 Bulle d'ami :

“Peindre toute une pièce d’une seule couleur… sans déborder, sans oublier un coin.”

🎯 Mini-TDD – Test de base

Remplir un tableau de 10 caractères avec 'A' et afficher chaque caractère entre crochets :

```c
#include <unistd.h>
#include "libft.h"

int main(void)
{
  ...
}
```
🧪 TDD Étendu — Cas à tester

Cas Résultat attendu  À faire
ft_memset(buffer, 'A', 10)  [A][A][A][A][A][A][A][A][A][A]  🔲
ft_memset(buffer, 0, 5) [\\0][\\0][\\0][\\0][\\0]...        🔲
ft_memset(buffer, 'Z', 0) Rien ne change                    🔲
ft_memset(NULL, 'X', 0) Autorisé (comportement défini en C) 🔲
ft_memset(buffer, 257, 3) Interprété comme (unsigned char)1 🔲

🧱 Structure recommandée :

```css
libft/
├── Makefile
├── src/
│   └── ft_memset.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_memset.c
│   └── test_ft_memset.sh
```
🧪 Script de test automatisé — test_ft_memset.sh

```bash
#!/bin/bash
echo "🔧 Compilation de ft_memset..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memset tests/tests_ft_memset.c src/ft_memset.c
if [ $? -ne 0 ]; then
    echo "❌ Compilation échouée."
    exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_memset
```
💡 Rends-le exécutable :

```bash

chmod +x tests/test_ft_memset.sh
./tests/test_ft_memset.sh
````

📦 Ajout Git recommandé :

```bash
git add src/ft_memset.c tests/tests_ft_memset.c tests/test_ft_memset.sh include/libft.h
git commit -m "[feat] ft_memset: remplissage mémoire octet par octet"
```
🐞 Debug pas à pas avec GDB :

```bash
gcc -g -Iinclude -o test_memset tests/tests_ft_memset.c src/ft_memset.c
gdb ./test_memset
```
Dans GDB :

```gdb
break ft_memset
run
step
print i
print ((unsigned char *)b)[i]
```
🔍 Reverse Engineering (analyse mémoire et binaire).

```bash
nm ./test_memset | grep ft_memset
objdump -d ./test_memset | less
````

ou dans GDB :.

```gdb
disassemble ft_memset
```
📘 README.md (pro)

```md
### ft_memset

- But : Remplir un bloc mémoire de `len` octets avec l'octet `c`.
- Utilité : Initialisation, nettoyage, patterns mémoire.
- Retour : Le pointeur original (`b`), pour permettre le chaînage.
- Cas gérés :
  - `len = 0` → aucun changement
  - `c > 255` → conversion automatique en `unsigned char`
- Outils : `GDB`, `nm`, `objdump`, `test.sh`, Git
- Complexité : O(n)
```
📌 À retenir :

Le pointeur `void *` doit être converti en `unsigned char *` pour écrire des octets.
La fonction doit écrire exactement len octets.
Toujours retourner b pour respecter la norme POSIX.
Ne jamais utiliser la fonction `memset()` native.

🔬 Bonus Reverse Engineering — Décrypter l’ASM

💡 Astuce : dans `objdump` ou `gdb`, cherche les instructions suivantes :
- `mov` : transfert de la valeur c dans une case mémoire
- `cmp`, `dec`, `jnz` `loop`: gestion de la boucle (souvent dans `for`)
- `rep stosb` (optimisation sur x86) : instruction spéciale pour memset natif
- le cast implicite vers unsigned char (visible dans les registres comme `al`, `rdi`, `rsi`)

📌 Exemple typique à reconnaître :
```asm
mov    BYTE PTR [rdi],al   ; copie de l'octet 'c' dans la mémoire pointée
inc    rdi                 ; passage à l’octet suivant
dec    rdx                 ; décrémentation du compteur
jnz    ...                 ; saut si compteur != 0
```
🎓 GDB TUI (Terminal User Interface) :

```bash
(gdb) layout asm
```
➜ Cela ouvre un affichage interactif du code assembleur ligne par ligne.

Lien conceptuel entre C et assembleur :
➜ Rajoute un encart pédagogique :

📚 “Quand tu écris une boucle en C, le compilateur génère des instructions machines pour cette boucle : typiquement une comparaison (cmp), une décrémentation (dec) et un saut conditionnel (jnz).”

-------------------------------------------------
## 2.1) ft_bzero
-------------------------------------------------
🧠 Le but :
Mettre à zéro une zone mémoire, octet par octet, de façon sécurisée et explicite.

📌 Prototype :

```c
void ft_bzero(void *s, size_t n);
```
🧪 Explication pédagogique :
Tu dois écrire n octets à la valeur 0 dans la mémoire pointée par s.
Cela correspond à mettre tous les octets à '\0', souvent utilisé pour effacer ou initialiser des buffers.

📌 Cette fonction est très utile :

Avant un malloc non initialisé
Avant d'utiliser une structure
Pour remettre un tableau à zéro

🛑 Interdictions :

❌ bzero()
❌ Toute fonction de <string.h> (autre que ta propre ft_memset)

✅ Tu dois :

Soit utiliser ta propre ft_memset() si elle est codée
Soit tout réécrire manuellement, avec une boucle, comme un memset avec c = 0
Toujours respecter les pointeurs et les types

💬 Bulle d'ami :

“Effacer sans laisser de trace… même dans les coins sombres.”

🎯 Mini-TDD – Test de base

Créer un tableau de 10 caractères, l’effacer avec ft_bzero(), puis afficher chaque caractère pour vérifier qu’il vaut bien \0 :

```c
#include <unistd.h>
#include "libft.h"

int main(void)
{
  ...
}
```
🧪 TDD Étendu — Cas à tester

Cas Résultat attendu  À faire
ft_bzero(buffer, 10)  [0][0][0][0][0][0][0][0][0][0]  ✅
ft_bzero(buffer, 0) Rien ne change  ✅
ft_bzero(NULL, 0) Comportement défini : OK  ✅
ft_bzero(buffer + 3, 2) Seuls indices 3 et 4 remis à zéro ✅
Utilisation dans une structure  Tous les champs initialisés à 0 ✅

🧱 Structure recommandée :

```css
libft/
├── Makefile
├── src/
│   └── ft_bzero.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_bzero.c
│   └── test_ft_bzero.sh
```
🧪 Script de test automatisé — test_ft_bzero.sh

```bash
#!/bin/bash
echo "🔧 Compilation de ft_bzero..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_bzero tests/tests_ft_bzero.c src/ft_bzero.c src/ft_memset.c
if [ $? -ne 0 ]; then
    echo "❌ Compilation échouée."
    exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_bzero
```
💡 Rends-le exécutable :

```bash
chmod +x tests/test_ft_bzero.sh
./tests/test_ft_bzero.sh
```
📦 Ajout Git recommandé :

```bash
git add src/ft_bzero.c tests/tests_ft_bzero.c tests/test_ft_bzero.sh include/libft.h
git commit -m "[feat] ft_bzero: mise à zéro d’une zone mémoire"
```
🐞 Debug pas à pas avec GDB :

```bash
gcc -g -Iinclude -o test_bzero tests/tests_ft_bzero.c src/ft_bzero.c src/ft_memset.c
gdb ./test_bzero
```
Dans GDB :

```gdb
break ft_bzero
run
step
print i
print ((unsigned char *)s)[i]
```
🔍 Reverse Engineering (analyse assembleur)

```bash
nm ./test_bzero | grep ft_bzero
objdump -d ./test_bzero | less
```
ou dans GDB :

```gdb
disassemble ft_bzero
```
📘 README.md (bonus pro)

```md
### ft_bzero

- But : Mettre à zéro une zone mémoire (remplir avec `\0`)
- Utilité : Initialiser des tableaux, structures ou buffers
- Comportement : Ne fait rien si `n == 0`
- Implémentation : Soit avec `ft_memset(s, 0, n)` si dispo, soit manuelle
- Outils : `GDB`, `objdump`, `nm`, `test.sh`, Git
- Complexité : O(n)
```
📌 À retenir :

ft_bzero() est équivalent à ft_memset(s, 0, n)
Elle ne retourne rien (void), contrairement à memset
Elle est utile pour remettre à zéro sans réallocation
n == 0 ➜ ne fait rien
Tu peux l'utiliser dans des struct, tableaux, etc.

🔬 Bonus Reverse Engineering — Décrypter l’ASM

💡 Astuce : dans objdump ou gdb, tu peux retrouver ces instructions :

mov BYTE PTR [rdi], 0x0 ➜ écriture explicite du zéro
loop / jnz / dec ➜ gestion de la boucle
rep stosb ➜ optimisé si memset est appelé (selon l'implémentation)

📚 Exemple typique :

```asm
mov    BYTE PTR [rdi], 0x0   ; mise à zéro d’un octet
inc    rdi                   ; avance d’un octet
dec    rdx                   ; décrémente le compteur
jnz    ...                   ; boucle jusqu’à 0
```
🎓 GDB TUI :

```bash
(gdb) layout asm
```
➜ Affichage interactif ligne par ligne du code assembleur généré par ft_bzero

📚 Lien conceptuel C → Assembleur :

“Quand tu écris une boucle for ou while en C, le compilateur génère des instructions bas niveau : cmp, dec, jnz, et des
opérations mov sur la mémoire. Comprendre ça t’aide à visualiser ce que fait réellement ton code, octet par octet.”

-------------------------------------------------
## 2.2) ft_memcpy
-------------------------------------------------
🧠 Le but :
Copier exactement n octets depuis une zone mémoire src vers une zone mémoire dst.
Contrairement à memmove, ft_memcpy ne doit PAS gérer le chevauchement.

📌 Prototype :

```c
void *ft_memcpy(void *dst, const void *src, size_t n);
```
🧪 Explication pédagogique :

Tu dois parcourir chaque octet un par un.
Copier n octets de src vers dst à l'identique.
Ne gère aucun chevauchement (src et dst ne doivent pas se superposer).
Tu dois caster void * en unsigned char * pour manipuler les octets.
Retourne dst.

🛑 Interdictions :

❌ memcpy()
❌ Toute fonction de <string.h>

✅ Tu dois :

Travailler octet par octet
Bien caster les pointeurs
Ne pas utiliser de fonction standard
Retourner dst à la fin

💬 Bulle d'ami :
"Copier, c’est comme transvaser de l’eau entre deux verres… sans mélanger, sans dépasser, sans chevauchement."

🎯 Mini-TDD — Test simple

Crée tests/tests_ft_memcpy.c :

```c
#include <unistd .h>
#include "libft.h"

void  ft_putchar(char c)
{
  write(1, &c, 1);
}

void  ft_putstr(char *s)
{
  int i = 0;
  while (s[i])
    ft_putchar(s[i++]);
}

int main(void)
{
  ...
}
```
🧪 TDD Étendu — Cas à tester

Cas Résultat attendu  À faire
ft_memcpy(dest, src, 5) "Hello"                       🔲
ft_memcpy(dest, src, 0) Rien ne change                🔲
ft_memcpy(dest, NULL, 5)  ⚠️ comportement indéfini   🔲
ft_memcpy(NULL, src, 5) ⚠️ comportement indéfini     🔲
ft_memcpy(NULL, NULL, 0)  Défini : OK                 🔲

➡️ Bonus : Ajoute un fichier expected_memcpy.txt contenant :

```txt
Résultat : [Hello]
```

🧱 Structure recommandée :

```css
libft/
├── Makefile
├── src/
│   └── ft_memcpy.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_memcpy.c
│   └── test_ft_memcpy.sh
│   └── expected_memcpy.txt
```
🧪 Script de test automatisé — test_ft_memcpy.sh

```bash
#!/bin/bash
echo "🔧 Compilation de ft_memcpy..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memcpy tests/tests_ft_memcpy.c src/ft_memcpy.c

if [ $? -ne 0 ]; then
    echo "❌ Compilation échouée."
    exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_memcpy > result.txt
diff result.txt tests/expected_memcpy.txt && echo "✅ OK" || echo "❌ Différence détectée"

```
diff -u result.txt tests/expected_memcpy.txt || echo "❌ Différences détectées dans la sortie"

Rends-le exécutable :

```bash
chmod +x tests/test_ft_memcpy.sh
./tests/test_ft_memcpy.sh
```
📦 Ajout Git recommandé :

```bash
git add src/ft_memcpy.c tests/tests_ft_memcpy.c tests/test_ft_memcpy.sh tests/expected_memcpy.txt include/libft.h
git commit -m "[feat] ft_memcpy: copie mémoire byte par byte avec TDD"
```
Conventions recommandées :

Tag Git Signification
- [feat]  Ajout d’une nouvelle fonction
- [test]  Ajout ou correction de test
- [fix] Correction de bug
- [doc] Commentaire ou documentation
- [chore] Tâche annexe (script, nettoyage, etc)

🐞 Debug pas à pas avec GDB :

```bash
gcc -g -Iinclude -o test_memcpy tests/tests_ft_memcpy.c src/ft_memcpy.c
gdb ./test_memcpy
```
Dans GDB :

```gdb
break ft_memcpy
run
step
print i
print ((unsigned char *)dst)[i]
```
🧠 Astuce :
Tu peux voir la mémoire directement :

```gdb
x/10cb dst
```
Affiche 10 octets consécutifs à partir de dst.

🔍 Reverse Engineering — Analyse assembleur :

```bash
nm ./test_memcpy | grep ft_memcpy
objdump -d ./test_memcpy | less
```
Ou dans GDB :

```gdb
disassemble ft_memcpy
```
🔍 Recherche dans le code assembleur :

- mov BYTE PTR [rdi], al : copie d’un octet
- inc rdi / rsi : déplacement pointeurs source/destination
- cmp / dec / jnz : boucle de copie
- Pas de rep movsb ici car ce serait une optimisation interne à memcpy du compilateur

💡 Tu verras typiquement :

```asm
mov    al,BYTE PTR [rsi]   ; lecture source
mov    BYTE PTR [rdi],al   ; écriture destination
inc    rdi                 ; avance
inc    rsi
dec    rdx
jnz    ...
````

📘 README.md (bonus pro)

```md
### ft_memcpy

- But : Copier `n` octets d’une source vers une destination, sans chevauchement.
- Utilité : Transfert mémoire rapide et contrôlé.
- Cas gérés :
  - `n == 0` → ne fait rien
  - `src == NULL` ou `dst == NULL` → comportement indéfini sauf si `n == 0`
- Outils : `GDB`, `objdump`, `nm`, `test.sh`, Git
- Complexité : O(n)
````
📌 À retenir :
Toujours caster `void *` en `(unsigned char *)` pour copier octet par octet.

Ne pas gérer de chevauchement (ce sera pour memmove).
memcpy n’est pas sûr si src et dst se recoupent.
Retourne dst pour permettre le chaînage.
Lire les instructions mov, rep movsb en ASM peut révéler des optimisations natives.

📚 Lien C → ASM :
"Le compilateur convertit ta boucle C en une suite d’instructions bas niveau : souvent un mov pour copier, et une boucle avec dec, cmp, jnz. Comprendre ça, c’est toucher la mécanique réelle de la mémoire."

-------------------------------------------------
## 2.3) ft_memmove
-------------------------------------------------
🧠 Le but :
Copier `len` octets d’une zone mémoire `src` vers `dst`, **même en cas de chevauchement**.

📌 Prototype :
```c
void *ft_memmove(void *dst, const void *src, size_t len);
```
🧪 Explication pédagogique :

Contrairement à ft_memcpy, cette fonction doit gérer les cas où les zones mémoire se recoupent.
Tu dois tester si dst > src, et si c’est le cas, copier en partant de la fin.
Sinon, tu copies en partant du début, comme memcpy.
Tu dois caster les `void *` en `unsigned char *`.
La fonction retourne toujours dst.

🛑 Interdictions :

❌ memmove()
❌ Toute fonction de <string.h>

✅ Copie manuelle, logique de chevauchement incluse
✅ Pas de #include <stdio.h> (respect norme 42)

💬 Bulle d’ami :
"Déplacer sans écraser, c’est savoir dans quel sens danser avec les octets."

🎯 Mini-TDD — Cas de test simple

Crée tests/tests_ft_memmove.c :

```c

#include <unistd.h>
#include "libft.h"

void ft_putchar(char c) 
{
  write(1, &c, 1);
}
void ft_putstr(char *s)
{
  int i = 0;
  while (s[i])
    ft_putchar(s[i++]);
}

int main(void)
{
  ...
}
```

🧪 TDD Étendu — Cas recommandés

Test  Résultat attendu
memmove(dst, src, 0)  Rien ne change
memmove(dst, src, 5)  Copie normale
memmove(dst, dst, 5)  Ne fait rien
memmove(dst+2, dst, 5)  Copie vers l’avant avec chevauchement
memmove(dst, dst+2, 5)  Copie vers l’arrière avec chevauchement
memmove(NULL, NULL, 0)  OK

➡️ Bonus : Ajoute tests/expected_memmove.txt :

```txt
Résultat : [ababcdehij]
```
🧱 Structure recommandée :

```css
libft/
├── Makefile
├── src/
│   └── ft_memmove.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_memmove.c
│   └── test_ft_memmove.sh
│   └── expected_memmove.txt
```

🧪 Script de test automatisé — test_ft_memmove.sh :

```bash
#!/bin/bash
echo "🔧 Compilation de ft_memmove..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memmove tests/tests_ft_memmove.c src/ft_memmove.c

if [ $? -ne 0 ]; then
    echo "❌ Compilation échouée."
    exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_memmove > result.txt
diff -u result.txt tests/expected_memmove.txt && echo "✅ OK" || echo "❌ Différences détectées"
```
💡 Rends-le exécutable :

```bash
chmod +x tests/test_ft_memmove.sh
./tests/test_ft_memmove.sh
```
📦 Ajout Git recommandé :

```bash
git add src/ft_memmove.c tests/tests_ft_memmove.c tests/test_ft_memmove.sh tests/expected_memmove.txt include/libft.h
git commit -m "[feat] ft_memmove: gestion des copies avec chevauchement + TDD"
```
🧩 Convention Git Pro :

Tag Rôle
- [feat]  Ajout de ft_memmove
- [test]  Ajout des tests automatisés
- [fix] Correction d’un bug
- [doc] Documentation / README
- [chore] Script ou maintenance annexe

🐞 GDB — Debug pas à pas :

```bash
gcc -g -Iinclude -o test_memmove tests/tests_ft_memmove.c src/ft_memmove.c
gdb ./test_memmove
```

Dans GDB :

```gdb
break ft_memmove
run
step
print i
print ((unsigned char *)dst)[i]
x/10cb dst
```
🔍 Reverse Engineering — Analyse ASM :

```bash
nm ./test_memmove | grep ft_memmove
objdump -d ./test_memmove | less
```
Ou dans GDB :

```gdb
disassemble ft_memmove
```
💡 Ce que tu verras :
Si copie avant → boucle normale
Si copie arrière → boucle décrémentée, mov en arrière
Pas de rep movsb ici : c’est notre version manuelle.

📘 README.md (bonus pro) :

```md
### ft_memmove

- But : Copier `n` octets entre deux zones mémoire, même si elles se chevauchent.
- Cas gérés :
  - `n == 0` → ne fait rien
  - `dst == src` → pas d’opération
  - `src < dst` → copie de droite à gauche
  - `src > dst` → copie de gauche à droite
- Outils utilisés : `GDB`, `objdump`, `nm`, `test.sh`
- Complexité : O(n)
```
📌 À retenir :

Ne pas écraser la source lors du recouvrement.
Bien tester les 2 sens de recouvrement.
Toujours caster les `void *` en `unsigned char *`.
Retourner dst à la fin.

📚 Lien C → Assembleur :
"Le sens de la copie se traduit dans le code machine : selon que tu parcours à l’endroit ou à l’envers, le compilateur
produit deux boucles différentes. Observer cela dans objdump te révèle les optimisations cachées du langage C."

-------------------------------------------------
## 2.4) ft_memchr
-------------------------------------------------
🧠 Le but :
Chercher un octet `c` dans les `n` premiers octets de la zone mémoire `s`.

📌 Prototype :

```c
void *ft_memchr(const void *s, int c, size_t n);
```
🧪 Explication pédagogique :

Tu dois parcourir octet par octet la zone mémoire pointée par s sur n octets.
À chaque itération, tu compares le contenu avec la valeur de c (castée en unsigned char).
Si tu trouves une correspondance, tu retournes un pointeur vers cet octet.
Sinon, tu retournes NULL.

⚠️ c est un int mais comparé comme un unsigned char.

🛑 Interdictions :

❌ memchr()
❌ Toute fonction de <string.h>
❌ #include <stdio.h> (interdit à 42)

✅ Tu dois :

✔️ Travailler octet par octet
✔️ Retourner un pointeur vers l'octet trouvé
✔️ Caster les pointeurs `((unsigned char *))`

💬 Bulle d'ami :
"Explorer octet par octet, comme un chercheur d’or qui s’arrête dès qu’il voit briller."

🎯 Mini-TDD — Cas de test simple

Crée tests/tests_ft_memchr.c :

```c
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putstr(char *s);

int main(void)
{
  ...
}
```
🧪 TDD Étendu — Cas recommandés

Test  Résultat attendu
ft_memchr("hello", 'o', 5)  Renvoie un pointeur vers 'o'
ft_memchr("hello", 'l', 5)  Renvoie le premier 'l'
ft_memchr("hello", 'z', 5)  NULL
ft_memchr("abcabc", 'a', 2) Trouve 'a' à la première position
ft_memchr(NULL, 'a', 0) OK (pas d'accès mémoire)
ft_memchr(NULL, 'a', 5) ⚠️ Comportement indéfini

➡️ Bonus : Crée tests/expected_memchr.txt :

```txt
Résultat : [o]
```
🧱 Structure recommandée :

```css
libft/
├── Makefile
├── src/
│   └── ft_memchr.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_memchr.c
│   └── test_ft_memchr.sh
│   └── expected_memchr.txt
```

🧪 Script de test automatisé — test_ft_memchr.sh

```bash
#!/bin/bash
echo "🔧 Compilation de ft_memchr..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memchr tests/tests_ft_memchr.c src/ft_memchr.c

if [ $? -ne 0 ]; then
  echo "❌ Compilation échouée."
  exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_memchr > result.txt
diff -u result.txt tests/expected_memchr.txt && echo "✅ OK" || echo "❌ Différences détectées"
```
```bash
chmod +x tests/test_ft_memchr.sh
./tests/test_ft_memchr.sh
```
📦 Ajout Git recommandé :

```bash
git add src/ft_memchr.c tests/tests_ft_memchr.c tests/test_ft_memchr.sh tests/expected_memchr.txt include/libft.h
git commit -m "[feat] ft_memchr: recherche octet en mémoire + TDD"
```
🧩 Convention Git Pro :

Tag Description
- [feat]  Nouvelle fonction ajoutée
- [test]  Script ou fichier de test
- [fix] Correction d'un bug
- [doc] Documentation ou README
- [chore] Maintenance, Makefile, etc

🐞 GDB — Debug pas à pas :

```bash
gcc -g -Iinclude -o test_memchr tests/tests_ft_memchr.c src/ft_memchr.c
gdb ./test_memchr
```
Dans GDB :

```gdb
break ft_memchr
run
step
print i
print ((unsigned char *)s)[i]
x/10cb s
```

🔍 Reverse Engineering — Analyse ASM :

```bash
nm ./test_memchr | grep ft_memchr
objdump -d ./test_memchr | less
```

Ou directement dans GDB :

```gdb
disassemble ft_memchr
```

💡 Regarde si le compilateur utilise cmp, mov, loop, ret.

📘 README.md (bonus pro) :

```md
### ft_memchr

- But : Chercher un octet `c` dans les `n` premiers octets de `s`
- Cas gérés :
  - Octet trouvé → pointeur retourné
  - Octet absent → NULL
  - `n == 0` → retourne NULL
  - `s == NULL` → comportement indéfini sauf si `n == 0`
- Outils utilisés : `GDB`, `objdump`, `nm`, `diff`, Git
- Complexité : O(n)
```

📌 À retenir :

Toujours caster `(void *)` en `(unsigned char *)` pour comparaison octet par octet
Retourne un pointeur vers la première occurrence
int c est comparé comme unsigned char
Si pas trouvé, retourne NULL

📚 Lien C → ASM :

"Une simple boucle avec cmp, mov, inc, jnz.
Mais cette routine est au cœur de toutes les recherches mémoire rapides."

-------------------------------------------------
📚 Récapitulatif rapide Partie 2 :

Fonction Ce que tu dois savoir faire
ft_memset Remplir une zone mémoire
ft_bzero Mettre à zéro une zone mémoire
ft_memcpy Copier une zone mémoire sans collision
ft_memmove Copier une zone mémoire en gérant la collision
ft_memchr Chercher un octet précis en mémoire

-------------------------------------------------
# Bloc 2 — Libft++ Boostée — Partie 3/? [🟢 Facile]
-------------------------------------------------

📚 Introduction rapide Partie 3
Ici, tu vas apprendre à :
Comparer correctement de la mémoire ou des chaînes,
Trouver des caractères dans des chaînes,
Gérer le bas niveau avec de la précision absolue.
Ta mémoire et ta logique doivent devenir chirurgicales.

📚 Fonctions de cette Partie 3 :

| Fonction        | Ce que tu dois apprendre à faire                     |
|-----------------|------------------------------------------------------|
| ft_memcmp       | Comparer deux zones mémoire octet par octet          |
| ft_strchr       | Trouver un caractère dans une chaîne (vers l’avant)  |
| ft_strrchr      | Trouver un caractère dans une chaîne (vers l’arrière)|
| ft_strncmp      | Comparer deux chaînes jusqu’à n caractères           |
| ft_strnstr      | Chercher une sous-chaîne dans une chaîne             |
| ft_atoi         | Convertir une chaîne en entier                       |
| ft_isalpha      | Vérifier si un caractère est alphabétique            |
| ft_isdigit      | Vérifier si un caractère est un chiffre              |
| ft_isalnum      | Vérifier si un caractère est alphanumérique          |

-------------------------------------------------
## 3.0) ft_memcmp
-------------------------------------------------
🧠 Le but :
Comparer deux zones mémoire octet par octet sur `n` octets.
Renvoyer une valeur **négative**, **zéro** ou **positive** selon la première différence rencontrée.

📌 Prototype :
```c
int ft_memcmp(const void *s1, const void *s2, size_t n);
```
🧪 Explication pédagogique :

Tu dois parcourir les deux zones mémoire s1 et s2, sur n octets.

Chaque octet est casté en unsigned char pour éviter les pièges liés aux valeurs négatives.

Dès que tu détectes une différence, tu retournes :
➔ (s1[i] - s2[i]) (en int)

Sinon, si tous les octets sont identiques :
➔ retourne 0

⚠️ Attention :
➔ On ne s'arrête pas à \0 !
➔ On traite toute la mémoire, même les octets nuls.

🛑 Interdictions 42 :

❌ memcmp()
❌ Toute fonction de <string.h>
❌ #include <stdio.h> (interdit à 42)

✅ Tu dois :

✔️ Caster les void * en (unsigned char *)
✔️ Comparer manuellement chaque octet
✔️ Retourner dès la première différence
✔️ Retourner 0 si toutes les valeurs sont égales

💬 Bulle d’ami :

"Comparer byte à byte, c’est comme lire deux lettres ligne par ligne pour détecter la moindre faute de frappe."

🎯 Mini-TDD — Test simple

Crée tests/tests_ft_memcmp.c :

```c
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putnbr(int n);

int main(void)
{
    ft_putnbr(ft_memcmp("abc", "abd", 3));
    return (0);
}
```
🧪 TDD Étendu — Cas recommandés :

Test  Résultat attendu
memcmp("abc", "abc", 3) 0
memcmp("abc", "abd", 3) 'c' - 'd' = -1
memcmp("aaa", "AAA", 3) 'a' - 'A' = 32
memcmp("abc", "abc", 0) 0
memcmp(NULL, NULL, 0) 0 (valide)
memcmp(NULL, s2, 3) ❌ comportement indéfini
memcmp(s1, NULL, 3) ❌ comportement indéfini

➡️ Bonus : Crée tests/expected_memcmp.txt :

```txt
Résultat : [-1]
```
🧱 Structure recommandée :

```css
libft/
├── Makefile
├── src/
│   └── ft_memcmp.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_memcmp.c
│   └── test_ft_memcmp.sh
│   └── expected_memcmp.txt
```
🧪 Script test automatisé : test_ft_memcmp.sh

```bash
#!/bin/bash
echo "🔧 Compilation de ft_memcmp..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_memcmp tests/tests_ft_memcmp.c src/ft_memcmp.c

if [ $? -ne 0 ]; then
  echo "❌ Compilation échouée."
  exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_memcmp > result.txt
diff -u result.txt tests/expected_memcmp.txt && echo "✅ OK" || echo "❌ Différences détectées"
```
```bash
chmod +x tests/test_ft_memcmp.sh
./tests/test_ft_memcmp.sh
```

📦 Ajout Git recommandé :

```bash
git add src/ft_memcmp.c tests/tests_ft_memcmp.c tests/test_ft_memcmp.sh tests/expected_memcmp.txt include/libft.h
git commit -m "[feat] ft_memcmp: comparaison mémoire octet par octet + TDD complet"
```
🧩 Convention Git Pro :

Tag Signification
- [feat]  Nouvelle fonction
- [test]  Tests ou validations automatisées
- [fix] Correction d’erreur
- [doc] Documentation ou README
- [chore] Scripts ou maintenance

🐞 GDB — Débogage pas à pas :

```bash
gcc -g -Iinclude -o test_memcmp tests/tests_ft_memcmp.c src/ft_memcmp.c
gdb ./test_memcmp
```
```gdb
break ft_memcmp
run
step
print i
print ((unsigned char *)s1)[i]
print ((unsigned char *)s2)[i]
x/10cb s1
x/10cb s2
```
🔍 Reverse Engineering — Analyse assembleur :

```bash
nm ./test_memcmp | grep ft_memcmp
objdump -d ./test_memcmp | less
```
Ou depuis GDB :

```gdb
disassemble ft_memcmp
```
💡 À observer dans le désassemblage :

```asm
movzx  eax, BYTE PTR [rdi]   ; charger s1[i]
movzx  edx, BYTE PTR [rsi]   ; charger s2[i]
cmp    al, dl                ; comparaison
jne    .Ldiff                ; saut si différent
ret                          ; sinon continue ou retourne 0
```
📘 README.md (bonus) :

```md
### ft_memcmp

- Objectif : comparer deux zones mémoire.
- Résultat :
  - `0` si identique
  - `< 0` si `s1 < s2`
  - `> 0` si `s1 > s2`
- Ne s’arrête pas à `\0`
- Comporte des cas limites (`NULL`, `n == 0`)
- Outils : GDB, objdump, nm, TDD, Git
```
📌 À retenir :

Ne t’arrête jamais à \0
Toujours caster `(void *)` en `(unsigned char *)`
Retourne la différence des octets, pas 1 ou -1
Très utile pour comprendre comment le C manipule la mémoire brute

📚 C → Assembleur → Reverse Engineering :

Dans objdump, cmp est le cœur de la détection de différence.
jne gère les sauts conditionnels.
Ces instructions te montrent comment ta logique en C se transforme en exécution CPU.

🔬 Pourquoi on apprend ça (ASM + Reverse Engineering) :

Tu vas bientôt faire des fonctions plus complexes → voir comment le CPU compare, saute, et retourne est fondamental.
L’assembleur te montre comment ton code se transforme réellement.
Le reverse engineering te servira à :
Analyser des binaires inconnus
Comprendre le comportement mémoire
Débugger même sans les sources
Créer des outils maison (type memwatcher, disassembler, etc.)
C’est aussi le cœur des outils comme Valgrind, GDB, ou les débogueurs système.

📚 Bonus étude :
Lis les premières pages du PDF “Reverse Engineering pour Débutants” que tu as fourni (notamment le chap. sur cmp, jne, ret) pour voir les équivalents machine des blocs if et return de ton code .

-------------------------------------------------
## 3.1) ft_strchr
-------------------------------------------------
🧠 Le but :
Trouver la première occurrence du caractère `c` dans la chaîne de caractères `s`.  
Retourner un pointeur vers ce caractère si trouvé, ou `NULL` sinon.

📌 Prototype :

```c
char *ft_strchr(const char *s, int c);
```
🧪 Explication pédagogique :

Tu parcours s caractère par caractère.
Tu compares s[i] avec (char)c (attention au cast).
Tu dois inclure le caractère nul \0 dans la recherche (ex: si c == 0, retourne un pointeur vers la fin de la chaîne).
Si une correspondance est trouvée → retourne `(char *)&s[i]`
Sinon → retourne NULL

🛑 Interdictions 42 :

❌ strchr()
❌ Toute fonction de <string.h>
❌ #include <stdio.h>

✅ Tu dois :

✔️ Boucle manuelle
✔️ Comparaison caractère par caractère
✔️ Retourner un char * vers la première occurrence trouvée

💬 Bulle d’ami :

"Trouver la première étoile dans un ciel plein de lettres, et s’y accrocher."

🎯 Mini-TDD — Test simple

Fichier tests/tests_ft_strchr.c :

```c
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putstr(char *s);

int main(void)
{
    char *s = ft_strchr("bonjour", 'o');
    if (s)
        ft_putchar(*s);
    else
        ft_putstr("NULL");
    return (0);
}
```

🧪 TDD Étendu — Cas recommandés :

Test  Résultat attendu
ft_strchr("bonjour", 'o') pointeur vers premier 'o'
ft_strchr("bonjour", 'z') NULL
ft_strchr("bonjour", '\0')  pointeur vers \0
ft_strchr("bonjour", 'b') pointeur vers 'b'
ft_strchr("", 'a')  NULL
ft_strchr(NULL, 'a')  ⚠️ comportement indéfini

➡️ Crée tests/expected_strchr.txt :

```txt
Résultat : [o]
```
🧱 Arborescence recommandée :

```css
libft/
├── Makefile
├── src/
│   └── ft_strchr.c
├── include/
│   └── libft.h
├── tests/
│   └── tests_ft_strchr.c
│   └── test_ft_strchr.sh
│   └── expected_strchr.txt
```
🧪 Script de test automatisé — test_ft_strchr.sh

```bash
#!/bin/bash
echo "🔧 Compilation de ft_strchr..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strchr tests/tests_ft_strchr.c src/ft_strchr.c

if [ $? -ne 0 ]; then
  echo "❌ Compilation échouée."
  exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_strchr > result.txt
diff -u result.txt tests/expected_strchr.txt && echo "✅ OK" || echo "❌ Différences détectées"
```
📦 Ajout Git recommandé :

bash
Copier
Modifier
git add src/ft_strchr.c tests/tests_ft_strchr.c tests/test_ft_strchr.sh tests/expected_strchr.txt include/libft.h
git commit -m "[feat] ft_strchr: recherche du premier caractère dans chaîne + TDD complet"
🧩 Convention Git Pro :

Tag Signification
[feat]  Nouvelle fonction
[test]  Tests ou validation
[fix] Correction
[doc] Ajout de documentation
[chore] Maintenance ou scripts auxiliaires

🐞 GDB — Débogage pas à pas :

bash
Copier
Modifier
gcc -g -Iinclude -o test_strchr tests/tests_ft_strchr.c src/ft_strchr.c
gdb ./test_strchr
gdb
Copier
Modifier
break ft_strchr
run
step
print s[i]
print (char)c
x/s s
info registers rdi rsi rax
🔍 Reverse Engineering — Analyse assembleur :

bash
Copier
Modifier
nm ./test_strchr | grep ft_strchr
objdump -d ./test_strchr | less
Ou depuis GDB :

gdb
Copier
Modifier
disassemble ft_strchr
💡 Tu devrais observer des instructions comme :

asm
Copier
Modifier
movzx eax, BYTE PTR [rdi]   ; charge s[i]
cmp    al, sil              ; compare à c (casté)
je     match                ; saut si égal
test   al, al               ; fin de chaîne ?
jne    loop                 ; boucle si pas fini
ret
🧠 Comprendre les registres :

rdi : premier paramètre (s)

esi/sil : second paramètre (c)

al/eax : comparaison active

cmp, je, jne : cœur de ta logique

📘 README.md (bonus pro) :

md
Copier
Modifier
### ft_strchr

- Objectif : Trouver la première occurrence du caractère `c` dans la chaîne `s`.
- Retour : pointeur vers `c`, ou `NULL` si absent.
- Cas particuliers :
  - `c == '\0'` ➝ retour vers fin de chaîne
  - `s == NULL` ➝ comportement indéfini
- Outils utilisés : GDB, objdump, nm, test shell, Git
- Complexité : O(n)
📌 À retenir :

Cast obligatoire de c en (char)

Ne t’arrête pas avant d’avoir comparé le \0

Retourne un pointeur, pas un index

Utiliser const char *s mais retourner (char *) car c’est OK si on ne modifie pas

📚 C ↔ ASM ↔ Reverse Engineering :

Même dans une fonction aussi simple, tu manipules directement la mémoire : le compilateur génère un code de boucle avec cmp, je, ret, très lisible dans GDB ou objdump.
C’est ta porte d’entrée vers le bas niveau, et un excellent exercice pour lire des instructions machine simples.


-------------------------------------------------
## 3.2) ft_strrchr
-------------------------------------------------
🧠 Le but :
Trouver la **dernière occurrence** du caractère `c` dans la chaîne de caractères `s`.  
Retourner un pointeur vers cette occurrence si elle existe, ou `NULL` sinon.

📌 Prototype :

```c
char *ft_strrchr(const char *s, int c);
```
🧪 Explication pédagogique :

Tu parcours la chaîne s jusqu’au caractère nul \0.

À chaque fois que tu rencontres (char)c, tu gardes l’adresse.

Tu continues la lecture jusqu’au bout pour ne pas rater une occurrence ultérieure.

À la fin, tu retournes :

le dernier pointeur mémorisé si trouvé

NULL sinon

⚠️ Attention :

c est un int, mais doit être comparé en (char)

Le \0 doit être inclus dans la recherche (cas possible)

🛑 Interdictions 42 :

❌ strrchr()
❌ <string.h>
❌ #include <stdio.h>

✅ Tu dois :

✔️ Faire une boucle complète
✔️ Mémoriser la dernière position trouvée
✔️ Caster les types si besoin
✔️ Retourner un char *, même si s est const char *

💬 Bulle d’ami :

"La dernière étoile est souvent la plus brillante, mais il faut regarder tout le ciel avant de la voir."

🎯 Mini-TDD — Test simple

Fichier tests/tests_ft_strrchr.c :

c
Copier
Modifier
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putstr(char *s);

int main(void)
{
    char *res = ft_strrchr("bonjour", 'o');
    if (res)
    {
        ft_putchar('[');
        ft_putchar(*res);
        ft_putchar(']');
    }
    else
        ft_putstr("[NULL]");
    return 0;
}
🧪 TDD Étendu — Cas recommandés :

Test  Résultat attendu
ft_strrchr("bonjour", 'o')  pointeur vers le 2e 'o'
ft_strrchr("bonjour", 'b')  pointeur vers 'b'
ft_strrchr("bonjour", '\0') pointeur vers \0
ft_strrchr("bonjour", 'z')  NULL
ft_strrchr("", 'a') NULL
ft_strrchr(NULL, 'a') ⚠️ comportement indéfini

➡️ Crée tests/expected_strrchr.txt :

less
Copier
Modifier
Résultat : [o]
🧱 Structure recommandée :

css
Copier
Modifier
libft/
├── Makefile
├── src/
│   └── ft_strrchr.c
├── include/
│   └── libft.h
├── tests/
│   ├── tests_ft_strrchr.c
│   ├── test_ft_strrchr.sh
│   └── expected_strrchr.txt
🧪 Script de test automatisé — test_ft_strrchr.sh

bash
Copier
Modifier
#!/bin/bash
echo "🔧 Compilation de ft_strrchr..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strrchr tests/tests_ft_strrchr.c src/ft_strrchr.c

if [ $? -ne 0 ]; then
  echo "❌ Compilation échouée."
  exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_strrchr > result.txt
diff -u result.txt tests/expected_strrchr.txt && echo "✅ OK" || echo "❌ Différences détectées"
bash
Copier
Modifier
chmod +x tests/test_ft_strrchr.sh
./tests/test_ft_strrchr.sh
📦 Ajout Git recommandé :

bash
Copier
Modifier
git add src/ft_strrchr.c tests/tests_ft_strrchr.c tests/test_ft_strrchr.sh tests/expected_strrchr.txt include/libft.h
git commit -m "[feat] ft_strrchr: recherche dernière occurrence dans chaîne + TDD"
🧩 Convention Git Pro :

Tag Signification
[feat]  Nouvelle fonction
[test]  Ajout ou amélioration des tests
[fix] Correction de bug
[doc] Documentation ou README
[chore] Maintenance, script, Makefile, etc

🐞 GDB — Débogage pas à pas :

bash
Copier
Modifier
gcc -g -Iinclude -o test_strrchr tests/tests_ft_strrchr.c src/ft_strrchr.c
gdb ./test_strrchr
gdb
Copier
Modifier
break ft_strrchr
run
step
print i
print s[i]
print (char)c
x/s s
🔍 Reverse Engineering — Analyse assembleur :

bash
Copier
Modifier
nm ./test_strrchr | grep ft_strrchr
objdump -d ./test_strrchr | less
Ou dans GDB :

gdb
Copier
Modifier
disassemble ft_strrchr
💡 Tu peux observer un schéma comme :

asm
Copier
Modifier
movzx eax, BYTE PTR [rdi]   ; lit s[i]
cmp    al, sil              ; compare à (char)c
je     store_addr           ; mémorise si égal
test   al, al               ; fin de chaîne ?
jne    loop                 ; sinon continue
ret
store_addr est une adresse mémorisée temporairement

le ret retourne ce dernier pointeur ou NULL

📘 README.md (bonus pro) :

md
Copier
Modifier
### ft_strrchr

- But : Trouver la **dernière** occurrence du caractère `c` dans la chaîne `s`.
- Retour :
  - Un `char *` vers le dernier `c` trouvé
  - `NULL` si non trouvé
- Cas particuliers :
  - `c == '\0'` ➝ retourne pointeur vers `\0`
  - `s == NULL` ➝ comportement indéfini
- Outils : GDB, objdump, nm, test shell, Git
- Complexité : O(n)
📌 À retenir :

Tu parcours tout s, même après la première correspondance

Tu compares (char)c, pas int brut

Tu peux mémoriser la position avec char *last = NULL;

Retourne toujours la dernière correspondance

\0 fait partie de la recherche

📚 Lien C → Assembleur :

strrchr est un bon exercice pour apprendre à mémoriser une adresse conditionnellement.
En assembleur, cela donne une boucle avec : cmp, je, test, et stockage conditionnel.
C’est ta première boucle avec effet mémoire dans une routine d’analyse bas niveau.

-------------------------------------------------
## 3.3) ft_strncmp
-------------------------------------------------
🧠 Le but :
Comparer deux chaînes de caractères **sur au plus `n` caractères**, et retourner :
- `0` si les `n` premiers caractères sont identiques
- Un entier < 0 ou > 0 selon la différence dès le premier caractère différent

📌 Prototype :

```c
int ft_strncmp(const char *s1, const char *s2, size_t n);
```
🧪 Explication pédagogique :

Tu compares chaque caractère de s1[i] et s2[i], jusqu'à n fois maximum.

Dès qu'une différence est détectée, tu retournes :

c
Copier
Modifier
(unsigned char)s1[i] - (unsigned char)s2[i]
Si n == 0 ➝ retourne immédiatement 0.

Si aucun caractère ne diffère sur les n premiers, retourne 0.

⚠️ Attention :

Tu dois caster en unsigned char pour éviter des surprises avec les valeurs > 127.

Tu t'arrêtes soit à n, soit au premier caractère différent, soit aux \0.

🛑 Interdictions 42 :

❌ strncmp()
❌ <string.h>
❌ #include <stdio.h>

✅ Tu dois :

✔️ Comparer chaque caractère un par un
✔️ Limiter la comparaison à n caractères
✔️ Retourner une soustraction sur les unsigned char
✔️ Gérer n == 0 sans erreur

💬 Bulle d’ami :

"Comparer vite mais bien : pas besoin d’aller jusqu’au bout pour voir une différence."

🎯 Mini-TDD — Test simple

Fichier tests/tests_ft_strncmp.c :

c
Copier
Modifier
#include <unistd.h>
#include "libft.h"

void ft_putnbr(int n);
void ft_putchar(char c);

int main(void)
{
    int result = ft_strncmp("hello", "helix", 3);
    ft_putchar('[');
    ft_putnbr(result);
    ft_putchar(']');
    return 0;
}
🧪 TDD Étendu — Cas recommandés :

Test  Résultat attendu
ft_strncmp("abc", "abc", 3) 0
ft_strncmp("abc", "abd", 3) 'c' - 'd' = -1
ft_strncmp("abc", "ab", 3)  'c' - '\0' = +99
ft_strncmp("abc", "abd", 2) 0 (car seuls les 2 premiers sont comparés)
ft_strncmp("abc", "abc", 0) 0
ft_strncmp("", "", 5) 0
ft_strncmp(NULL, s2, n) / s1 == NULL  ❌ Comportement indéfini sauf si n == 0

➡️ Crée tests/expected_strncmp.txt :

less
Copier
Modifier
Résultat : [0]
🧱 Structure recommandée :

css
Copier
Modifier
libft/
├── Makefile
├── src/
│   └── ft_strncmp.c
├── include/
│   └── libft.h
├── tests/
│   ├── tests_ft_strncmp.c
│   ├── test_ft_strncmp.sh
│   └── expected_strncmp.txt
🧪 Script de test automatisé — test_ft_strncmp.sh

bash
Copier
Modifier
#!/bin/bash
echo "🔧 Compilation de ft_strncmp..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strncmp tests/tests_ft_strncmp.c src/ft_strncmp.c

if [ $? -ne 0 ]; then
  echo "❌ Compilation échouée."
  exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_strncmp > result.txt
diff -u result.txt tests/expected_strncmp.txt && echo "✅ OK" || echo "❌ Différences détectées"
bash
Copier
Modifier
chmod +x tests/test_ft_strncmp.sh
./tests/test_ft_strncmp.sh
📦 Ajout Git recommandé :

bash
Copier
Modifier
git add src/ft_strncmp.c tests/tests_ft_strncmp.c tests/test_ft_strncmp.sh tests/expected_strncmp.txt include/libft.h
git commit -m "[feat] ft_strncmp: comparaison limitée entre chaînes + TDD"
🧩 Convention Git Pro :

Tag Signification
[feat]  Nouvelle fonction
[test]  Ajout ou amélioration des tests
[fix] Correction de bug
[doc] Documentation ou README
[chore] Maintenance, script, Makefile, etc

🐞 GDB — Debug pas à pas :

bash
Copier
Modifier
gcc -g -Iinclude -o test_strncmp tests/tests_ft_strncmp.c src/ft_strncmp.c
gdb ./test_strncmp
gdb
Copier
Modifier
break ft_strncmp
run
step
print i
print s1[i]
print s2[i]
print (unsigned char)s1[i] - (unsigned char)s2[i]
🔍 Reverse Engineering — Analyse assembleur :

bash
Copier
Modifier
nm ./test_strncmp | grep ft_strncmp
objdump -d ./test_strncmp | less
Ou dans GDB :

gdb
Copier
Modifier
disassemble ft_strncmp
💡 Tu pourrais observer :

asm
Copier
Modifier
movzx eax, BYTE PTR [rdi + rcx]   ; charge s1[i]
movzx edx, BYTE PTR [rsi + rcx]   ; charge s2[i]
cmp eax, edx
jne diff_found
inc rcx
cmp rcx, rdx                      ; rdx = n
jl loop
rcx : index i

rdi / rsi : pointeurs s1 / s2

movzx : conversion sécurisée

cmp + jne : cœur de la comparaison

ret : retourne la différence

📘 README.md (bonus pro) :

md
Copier
Modifier
### ft_strncmp

- But : Comparer `n` caractères entre `s1` et `s2`
- Retour :
  - `0` si égalité sur `n` caractères
  - `< 0` si `s1[i] < s2[i]`
  - `> 0` si `s1[i] > s2[i]`
- Cas particuliers :
  - `n == 0` ➝ retourne `0`
  - Arrêt anticipé à la première différence
- Outils utilisés : GDB, objdump, nm, test shell, Git
- Complexité : O(n)
📌 À retenir :

Tu compares des unsigned char, pas des char

Tu t’arrêtes dès qu’un caractère diffère OU que n est atteint

Tu ne vas pas jusqu’au \0 si n < longueur

Tu ne dois pas retourner 1 ou -1 mais bien la soustraction entre octets

📚 Lien C → Assembleur :

strncmp est comme memcmp, mais limité par \0 : c’est un compromis entre sécurité et efficacité.
En assembleur, tu retrouves un cmp, une boucle avec je, et un compteur n décroissant.

Comprendre strncmp t’initie à la gestion sécurisée de tampons, utile pour l’analyse mémoire, les protocoles réseau et les audits bas niveau.

-------------------------------------------------
## 3.4) ft_strnstr
-------------------------------------------------
🧠 Le but :
Trouver une sous-chaîne `needle` dans la chaîne `haystack`, **mais sans dépasser `len` caractères**.

Si `needle` est vide, retourne `haystack`.  
Sinon, cherche `needle` dans les `len` premiers caractères de `haystack`.  
Retourne un `char *` vers le début de l’occurrence si trouvée, ou `NULL` sinon.

📌 Prototype :

```c
char *ft_strnstr(const char *haystack, const char *needle, size_t len);
```
🧪 Explication pédagogique :

Si needle est vide (needle[0] == '\0'), retourne haystack.

Sinon, parcours haystack caractère par caractère (jusqu'à len).

À chaque position i, vérifie s’il reste assez de place (len - i >= ft_strlen(needle)).

Compare needle avec haystack + i sur ft_strlen(needle) caractères.

Si match ➝ retourne un pointeur vers haystack + i.

Sinon ➝ continue jusqu’à la limite len.

Si aucun match trouvé ➝ retourne NULL.

🛑 Interdictions 42 :

❌ strstr()
❌ Toute fonction <string.h>
❌ #include <stdio.h>

✅ Tu dois :

✔️ Implémenter une recherche manuelle
✔️ Comparer les chaînes avec ta propre fonction ou une boucle
✔️ Bien gérer la limite len
✔️ Gérer needle == "" et len == 0

💬 Bulle d’ami :

"Trouver une île dans un océan… avant de manquer de carburant."

🎯 Mini-TDD — Test simple

Fichier tests/tests_ft_strnstr.c :

c
Copier
Modifier
#include <unistd.h>
#include "libft.h"

void ft_putchar(char c);
void ft_putstr(char *s);

int main(void)
{
    char *res = ft_strnstr("bonjour tout le monde", "to", 10);
    if (res)
    {
        ft_putchar('[');
        ft_putchar(*res);
        ft_putchar(']');
    }
    else
        ft_putstr("[NULL]");
    return 0;
}
🧪 TDD Étendu — Cas recommandés :

Test  Résultat attendu
ft_strnstr("bonjour tout le monde", "to", 10) [NULL]
ft_strnstr("bonjour tout le monde", "to", 15) pointeur vers 't'
ft_strnstr("hello world", "", 5)  pointeur vers "hello"
ft_strnstr("abc", "abcd", 3)  NULL
ft_strnstr("abc", "bc", 2)  NULL
ft_strnstr("abc", "bc", 3)  pointeur vers 'b'
ft_strnstr(NULL, "a", 3)  comportement indéfini ⚠️
ft_strnstr("abc", NULL, 3)  comportement indéfini ⚠️

➡️ Bonus : Crée tests/expected_strnstr.txt :

txt
Copier
Modifier
Résultat : [NULL]
🧱 Structure recommandée :

css
Copier
Modifier
libft/
├── Makefile
├── src/
│   └── ft_strnstr.c
├── include/
│   └── libft.h
├── tests/
│   ├── tests_ft_strnstr.c
│   ├── test_ft_strnstr.sh
│   └── expected_strnstr.txt
🧪 Script de test automatisé — test_ft_strnstr.sh :

bash
Copier
Modifier
#!/bin/bash
echo "🔧 Compilation de ft_strnstr..."
gcc -Wall -Wextra -Werror -g -Iinclude -o tests/tests_ft_strnstr tests/tests_ft_strnstr.c src/ft_strnstr.c

if [ $? -ne 0 ]; then
  echo "❌ Compilation échouée."
  exit 1
fi

echo "✅ Exécution des tests :"
./tests/tests_ft_strnstr > result.txt
diff -u result.txt tests/expected_strnstr.txt && echo "✅ OK" || echo "❌ Différences détectées"
bash
Copier
Modifier
chmod +x tests/test_ft_strnstr.sh
./tests/test_ft_strnstr.sh
📦 Ajout Git recommandé :

bash
Copier
Modifier
git add src/ft_strnstr.c tests/tests_ft_strnstr.c tests/test_ft_strnstr.sh tests/expected_strnstr.txt include/libft.h
git commit -m "[feat] ft_strnstr: recherche sous-chaîne limitée + TDD"
🧩 Convention Git Pro :

Tag Signification
[feat]  Nouvelle fonction
[test]  Ajout ou amélioration des tests
[fix] Correction de bug
[doc] Documentation ou README
[chore] Maintenance, script, Makefile, etc

🐞 GDB — Debug pas à pas :

bash
Copier
Modifier
gcc -g -Iinclude -o test_strnstr tests/tests_ft_strnstr.c src/ft_strnstr.c
gdb ./test_strnstr
gdb
Copier
Modifier
break ft_strnstr
run
step
print haystack[i]
print needle[j]
print len
🔍 Reverse Engineering — Analyse assembleur :

bash
Copier
Modifier
nm ./test_strnstr | grep ft_strnstr
objdump -d ./test_strnstr | less
Ou depuis GDB :

gdb
Copier
Modifier
disassemble ft_strnstr
💡 Tu pourrais observer :

asm
Copier
Modifier
movzx eax, BYTE PTR [rdi + rcx]   ; haystack[i]
cmp eax, BYTE PTR [rsi]           ; needle[0]
je match_loop
cmp rcx, rdx                      ; comparaison avec len
jl search_loop
rdi : haystack

rsi : needle

rdx : len

rcx : i

boucles de comparaison internes imbriquées

📘 README.md (bonus pro) :

md
Copier
Modifier
### ft_strnstr

- But : Trouver une sous-chaîne dans `haystack` sans dépasser `len` caractères.
- Retour :
  - `char *` vers le début de l’occurrence trouvée
  - `NULL` si non trouvée
- Cas particuliers :
  - `needle == ""` ➝ retourne `haystack`
  - `len == 0` ➝ retourne `NULL`, sauf si `needle == ""`
- Outils utilisés : GDB, objdump, nm, tests.sh, Git
- Complexité : O(n * m) dans le pire des cas
📌 À retenir :

ft_strnstr ≠ strstr car limité en taille !

⚠️ Attention aux dépassements de len

Ne fais pas de comparaison si len < strlen(needle)

⚠️ Ne jamais lire au-delà de len

📚 Lien C → Assembleur :

Cette fonction t’apprend à gérer les limites de buffer, une compétence essentielle pour la sécurité.
Tu dois penser aux bornes, à la comparaison double, à la terminaison correcte.

-------------------------------------------------
📚 Récapitulatif rapide Partie 3 :
-------------------------------------------------

Fonction Ce que tu dois savoir faire
ft_memcmp Comparer mémoire brute
ft_strchr Trouver la première occurrence
ft_strrchr Trouver la dernière occurrence
ft_strncmp Comparer jusqu à un certain nombre de caractères
ft_strnstr Chercher une sous-chaîne dans une limite

-------------------------------------------------
# Bloc 2 — Libft++ Boostée — Partie 4/? [🟢 Facile]
-------------------------------------------------

📚 Introduction rapide Partie 4

Bienvenue dans la **partie dynamique** de la Libft++ : ici, on joue avec **la mémoire**, **les conversions**, et **l’allocation**.

Tu vas apprendre à :

- Allouer dynamiquement de la mémoire (`malloc`, `calloc`)
- Libérer proprement cette mémoire
- Convertir des chaînes en entiers (`ft_atoi`)
- Convertir des entiers en chaînes (`ft_itoa`)
- Gérer les pointeurs avec une extrême précision

🧠 Ce que ton cerveau doit intégrer maintenant :

- ✅ Calculer combien d’octets il faut pour un tableau de `int`, `char`, etc.
- ✅ Gérer le caractère `\0` à la fin de chaque chaîne
- ✅ Bien vérifier si `malloc` a échoué
- ✅ Ne jamais oublier de libérer ce que tu alloues (free)

---

📚 Fonctions de cette Partie 4 :

| Fonction        | Objectif                                                    |
|----------------|-------------------------------------------------------------|
| `ft_calloc`     | Allouer `count * size` octets, initialisés à 0             |
| `ft_strdup`     | Dupliquer une chaîne de caractères                         |
| `ft_substr`     | Extraire une sous-chaîne                                   |
| `ft_strjoin`    | Joindre deux chaînes                                       |
| `ft_strtrim`    | Supprimer des caractères spécifiques au début/fin d’une chaîne |
| `ft_split`      | Découper une chaîne en tableau de mots                     |
| `ft_itoa`       | Convertir un entier en chaîne                              |
| `ft_atoi`       | Convertir une chaîne en entier                             |

⚠️ Ces fonctions sont **les bases de toute manipulation dynamique de texte en C**.  
Tu vas devoir les utiliser dans 90% de tes projets futurs (libft, minishell, pipex…).

---

📦 Organisation des fichiers recommandée :

libft/
├── Makefile
├── include/
│ └── libft.h
├── src/
│ ├── ft_calloc.c
│ ├── ft_strdup.c
│ ├── ft_substr.c
│ ├── ft_strjoin.c
│ ├── ft_strtrim.c
│ ├── ft_split.c
│ ├── ft_itoa.c
│ ├── ft_atoi.c
├── tests/
│ ├── tests_ft_calloc.c
│ ├── test_ft_calloc.sh
│ └── expected_calloc.txt
│ (... les autres à suivre)

yaml
Copier
Modifier

---

🔍 Outils à maîtriser dans cette partie :

| Outil      | Rôle                                                   |
|------------|--------------------------------------------------------|
| `malloc`   | Allouer dynamiquement de la mémoire                    |
| `free`     | Libérer cette mémoire                                  |
| `gdb`      | Vérifier les pointeurs, les fuites, les allocations    |
| `valgrind` | (⚠️ interdit à 42, mais à connaître plus tard)         |
| `objdump`  | Observer la génération ASM d’allocations               |
| `nm`       | Voir si `malloc`, `free` sont appelés dans ton code    |

---

💬 Bulle d’ami :

> "Là où la mémoire vit et meurt, ton code doit être précis comme un chirurgien."

-------------------------------------------------
## 4.0) ft_calloc
-------------------------------------------------
Le but :
Allouer de la mémoire et l'initialiser à zéro.

Prototype :

c
Copier
Modifier
```c
void *ft_calloc(size_t count, size_t size);
Explication :
Réserver count * size octets et tout mettre à zéro (\0).

```
Interdictions :

❌ Pas de calloc

✅ Utiliser malloc + ft_bzero (déjà codé)

💬 Bulle d'ami :
"Créer une maison vide, propre et prête à accueillir."

🎯 Mini-TDD :
Allouer 5 int et vérifier qu'ils valent 0.

## 4.1) ft_strdup (Rappel amélioré)
Le but :
Copier une chaîne en créant une nouvelle zone mémoire.

Prototype :

c
Copier
Modifier
```c
char *ft_strdup(const char *s1);
Explication :
Allouer, puis copier, caractère par caractère.

```
Interdictions :

❌ Pas d'appel à strdup

✅ malloc obligatoire

💬 Bulle d'ami :
"Un clone parfait doit vivre dans sa propre maison."

🎯 Mini-TDD :
Dupliquer "Bonjour" et vérifier contenu ET adresses différentes.

## 4.2) ft_atoi
Le but :
Convertir une chaîne de caractères en entier.

Prototype :

c
Copier
Modifier
```c
int ft_atoi(const char *str);
Explication :
Lire les chiffres d'une chaîne jusqu'à pouvoir former un int.

```
Interdictions :

❌ Pas de atoi

✅ Parsing manuel obligatoire

💬 Bulle d'ami :
"Chaque chiffre raconte une histoire, mais il faut bien écouter."

🎯 Mini-TDD :
Convertir " -123" et vérifier que tu obtiens -123.

## 4.3) ft_itoa
Le but :
Convertir un entier en chaîne de caractères.

Prototype :

c
Copier
Modifier
```c
char *ft_itoa(int n);
Explication :
Découper un nombre en chiffres et les assembler en une chaîne.

```
Interdictions :

❌ Pas d'utilisation de sprintf

✅ Allocation dynamique (malloc) obligatoire

💬 Bulle d'ami :
"Transformer un nombre en mot: la magie du code."

🎯 Mini-TDD :
Transformer 42 ➔ "42", -2147483648 ➔ "-2147483648".

## 4.4) ft_substr
Le but :
Extraire une sous-chaîne d'une chaîne.

Prototype :

c
Copier
Modifier
```c
char *ft_substr(char const *s, unsigned int start, size_t len);
Explication :
Créer une nouvelle chaîne commençant à start, avec len caractères maximum.

```
Interdictions :

❌ Pas de substr toute faite

✅ Allocation + copie manuelles

💬 Bulle d'ami :
"Parfois, la meilleure histoire est juste un chapitre extrait."

🎯 Mini-TDD :
Extraire "am" de "Programme" en partant du 5ᵉ caractère.

📚 Récapitulatif rapide Partie 4 :

Fonction Ce que tu dois savoir faire
ft_calloc Allouer mémoire initialisée à zéro
ft_strdup Dupliquer une chaîne manuellement
ft_atoi Lire un nombre dans une chaîne
ft_itoa Transformer un int en chaîne
ft_substr Extraire un morceau de chaîne

# Bloc 2 — Libft++ Boostée — Partie 5/? [🟢 Facile]
📚 Introduction rapide Partie 5
Ici, tu vas :

Assembler (strjoin) des chaînes,

Découper (split) intelligemment une chaîne,

Nettoyer (strtrim) les chaînes de caractères.

Ton objectif :
Maîtriser la manipulation propre des chaînes en mémoire dynamique.

📚 Fonctions de cette Partie 5
## 5.0) ft_strjoin
Le but :
Assembler deux chaînes de caractères en une seule.

Prototype :

c
Copier
Modifier
```c
char *ft_strjoin(char const *s1, char const *s2);
Explication :
Allouer une nouvelle chaîne contenant s1 suivi de s2.

```
Interdictions :

❌ Pas de strcat, sprintf, etc.

✅ Construction manuelle obligatoire

💬 Bulle d'ami :
"Assembler deux âmes en un seul voyage."

🎯 Mini-TDD :
Assembler "Hello" et "World" ➔ obtenir "HelloWorld".

## 5.1) ft_strtrim
Le but :
Supprimer les caractères spécifiés au début et à la fin d'une chaîne.

Prototype :

c
Copier
Modifier
```c
char *ft_strtrim(char const *s1, char const *set);
Explication :
Supprimer tous les caractères de set présents au début et à la fin de s1.

```
Interdictions :

❌ Pas d'utilisation de fonction externe

✅ Parsing et allocation manuels

💬 Bulle d'ami :
"Élaguer les branches mortes pour faire respirer l'arbre."

🎯 Mini-TDD :
Trimer " Hello " avec " " ➔ obtenir "Hello".

## 5.2) ft_split
Le but :
Diviser une chaîne en plusieurs sous-chaînes, selon un séparateur.

Prototype :

c
Copier
Modifier
```c
char **ft_split(char const *s, char c);
Explication :
À chaque fois que tu rencontres le caractère c, tu découpes et crées un nouveau mot.

```
Interdictions :

❌ Pas de strtok, strsep

✅ Allocation manuelle obligatoire

💬 Bulle d'ami :
"Découper un long chemin en plusieurs étapes claires."

🎯 Mini-TDD :
Diviser "Hello World 42" par ' ' ➔ obtenir ["Hello", "World", "42"].

## 5.3) ft_strmapi
Le but :
Appliquer une fonction à chaque caractère d'une chaîne (retourne une nouvelle chaîne).

Prototype :

c
Copier
Modifier
```c
char *ft_strmapi(char const *s, char (*f)(unsigned int, char));
Explication :
Pour chaque caractère, appeler une fonction qui le transforme.

```
Interdictions :

❌ Pas de map automatique

✅ Construire la chaîne toi-même

💬 Bulle d'ami :
"Transformer lettre après lettre, comme un alchimiste."

🎯 Mini-TDD :
Appliquer une fonction qui transforme "abc" en "BCD" (ajouter 1 à chaque caractère).

## 5.4) ft_striteri
Le but :
Appliquer une fonction à chaque caractère d'une chaîne directement (sans créer une nouvelle chaîne).

Prototype :

c
Copier
Modifier
```c
void ft_striteri(char *s, void (*f)(unsigned int, char*));
Explication :
Modifier directement la chaîne existante en passant l'index et un pointeur sur chaque caractère.

```
Interdictions :

❌ Pas de double allocation

✅ Modifications en place

💬 Bulle d'ami :
"Parfois, il faut polir la pierre sans l'échanger."

🎯 Mini-TDD :
Appliquer une fonction qui met tout en majuscule directement sur "hello" ➔ devient "HELLO".

📚 Récapitulatif rapide Partie 5 :

Fonction Ce que tu dois savoir faire
ft_strjoin Coller deux chaînes ensemble
ft_strtrim Enlever un ensemble de caractères autour d'une chaîne
ft_split Couper une chaîne en plusieurs sous-chaînes
ft_strmapi Créer une nouvelle chaîne transformée caractère par caractère
ft_striteri Modifier une chaîne existante caractère par caractère

# Bloc 2 — Libft++ Boostée — Partie 6/? [🟢 Facile]
📚 Introduction rapide Partie 6
Ici, tu vas :

Afficher dans un fichier donné (et plus seulement sur l'écran),

Apprendre à penser en terme de "file descriptor" (fd),

Maîtriser l'affichage contrôlé en C.

📚 Fonctions de cette Partie 6
## 6.0) ft_putchar_fd
Le but :
Écrire un caractère dans un fichier donné (file descriptor).

Prototype :

c
Copier
Modifier
```c
void ft_putchar_fd(char c, int fd);
Explication :
Utiliser write pour envoyer c vers le fd spécifié.

```
Interdictions :

❌ Pas de fprintf

✅ Utiliser write directement

💬 Bulle d'ami :
"Parler exactement à celui que tu veux atteindre."

🎯 Mini-TDD :
Afficher 'A' dans un fichier ouvert en écriture.

## 6.1) ft_putstr_fd
Le but :
Écrire une chaîne de caractères dans un fichier donné.

Prototype :

c
Copier
Modifier
```c
void ft_putstr_fd(char *s, int fd);
Explication :
Écrire toute la chaîne caractère par caractère (ou d'un coup) vers fd.

```
Interdictions :

❌ Pas de fprintf

✅ write obligatoire

💬 Bulle d'ami :
"Exprimer un mot entier, mais à la bonne personne."

🎯 Mini-TDD :
Afficher "Hello World" dans un fichier temporaire.

## 6.2) ft_putendl_fd
Le but :
Écrire une chaîne de caractères suivie d'un retour à la ligne (\n), dans un fichier donné.

Prototype :

c
Copier
Modifier
```c
void ft_putendl_fd(char *s, int fd);
Explication :
Écrire la chaîne puis écrire un \n derrière.

```
Interdictions :

❌ Pas de puts

✅ Construction manuelle avec write

💬 Bulle d'ami :
"Parler et toujours bien finir sa phrase."

🎯 Mini-TDD :
Afficher "Hello" + retour à la ligne dans un fichier.

## 6.3) ft_putnbr_fd
Le but :
Afficher un nombre entier dans un fichier donné.

Prototype :

c
Copier
Modifier
```c
void ft_putnbr_fd(int n, int fd);
Explication :
Transformer un nombre en caractères et l'écrire, chiffre par chiffre.

```
Interdictions :

❌ Pas de fprintf

✅ Écriture manuelle obligatoire

💬 Bulle d'ami :
"Parler en chiffres, avec clarté et précision."

🎯 Mini-TDD :
Afficher 42 puis -12345 dans un fichier.

📚 Récapitulatif rapide Partie 6 :

Fonction Ce que tu dois savoir faire
ft_putchar_fd Écrire un caractère dans un fichier
ft_putstr_fd Écrire une chaîne dans un fichier
ft_putendl_fd Écrire une chaîne avec saut de ligne
ft_putnbr_fd Écrire un nombre entier

# Bloc 2 — Libft++ Boostée — Partie 7/? [🟢 Facile]
📚 Introduction rapide Partie 7
Ici, tu passes au niveau supérieur :
➔ Créer et manipuler des listes chaînées en C.

Objectif :

Comprendre la mémoire dynamique complexe,

Créer, ajouter, supprimer, parcourir des éléments reliés par des pointeurs,

Être sûr de la stabilité de ton code sans fuites mémoire.

📚 Fonctions de cette Partie 7
## 7.0) ft_lstnew
Le but :
Créer un nouvel élément de liste.

Prototype :

c
Copier
Modifier
```c
t_list *ft_lstnew(void *content);
Explication :
Allouer un élément, lui donner son contenu, initialiser next à NULL.

```
Interdictions :

❌ Pas d'allocation automatique

✅ malloc obligatoire

💬 Bulle d'ami :
"Chaque histoire commence par un premier chapitre."

🎯 Mini-TDD :
Créer un nouvel élément contenant "hello".

## 7.1) ft_lstadd_front
Le but :
Ajouter un élément au début d'une liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstadd_front(t_list **lst, t_list *new);
Explication :
Modifier le next du nouvel élément pour qu'il pointe sur l'ancienne tête de liste.

```
Interdictions :

❌ Pas de recréation complète

✅ Simple manipulation des pointeurs

💬 Bulle d'ami :
"Parfois, le dernier arrivé doit être le premier servi."

🎯 Mini-TDD :
Créer une liste, ajouter un élément devant, vérifier l'ordre.

## 7.2) ft_lstsize
Le but :
Compter le nombre d'éléments dans une liste.

Prototype :

c
Copier
Modifier
```c
int ft_lstsize(t_list *lst);
Explication :
Parcourir la liste en comptant les éléments jusqu'à NULL.

```
Interdictions :

❌ Pas de compter avec une fonction externe

✅ Boucle manuelle obligatoire

💬 Bulle d'ami :
"Compter pour mieux comprendre la longueur du chemin."

🎯 Mini-TDD :
Créer 3 éléments liés et vérifier que ft_lstsize retourne 3.

## 7.3) ft_lstlast
Le but :
Trouver le dernier élément d'une liste.

Prototype :

c
Copier
Modifier
t_list *ft_lstlast(t_list *lst);
Explication :
Avancer jusqu'à l'élément dont next est NULL.

Interdictions :

❌ Pas de raccourcis

✅ Traverser proprement

💬 Bulle d'ami :
"La fin d'une liste est toujours un point d'arrêt."

🎯 Mini-TDD :
Vérifier que tu arrives sur le dernier élément de ta liste.

## 7.4) ft_lstadd_back
Le but :
Ajouter un élément à la fin d'une liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstadd_back(t_list **lst, t_list *new);
Explication :
Trouver la fin et ajouter l'élément.

```
Interdictions :

❌ Pas de recréation de liste

✅ Manipuler les pointeurs

💬 Bulle d'ami :
"Ajoute ton histoire à la fin du livre."

🎯 Mini-TDD :
Créer une liste, ajouter à la fin, vérifier.

## 7.5) ft_lstdelone
Le but :
Supprimer un élément de la liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstdelone(t_list *lst, void (*del)(void *));
Explication :
Libérer l'élément et son contenu avec la fonction del.

```
Interdictions :

❌ Pas de free seul

✅ Utiliser del

💬 Bulle d'ami :
"Effacer proprement sans laisser de trace."

🎯 Mini-TDD :
Supprimer un élément, vérifier pas de fuite mémoire.

## 7.6) ft_lstclear
Le but :
Supprimer toute une liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstclear(t_list **lst, void (*del)(void *));
Explication :
Parcourir tous les éléments et les supprimer.

```
Interdictions :

❌ Pas de fuite mémoire

✅ Suppression manuelle obligatoire

💬 Bulle d'ami :
"Un vrai nettoyage ne laisse rien derrière."

🎯 Mini-TDD :
Créer 3 éléments, les clear et vérifier avec Valgrind.

## 7.7) ft_lstiter
Le but :
Appliquer une fonction à chaque élément de la liste.

Prototype :

c
Copier
Modifier
```c
void ft_lstiter(t_list *lst, void (*f)(void *));
Explication :
Passer chaque élément à la fonction f.

```
Interdictions :

❌ Pas de création de nouvelle liste

✅ Agir en place

💬 Bulle d'ami :
"Chaque pierre tournée révèle une nouvelle face."

🎯 Mini-TDD :
Modifier toutes les données d'une liste avec f.

## 7.8) ft_lstmap
Le but :
Créer une nouvelle liste en appliquant une fonction à chaque élément.

Prototype :

c
Copier
Modifier
```c
t_list *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));
Explication :
Appliquer f à chaque contenu et créer une nouvelle liste.

```
Interdictions :

❌ Pas de réutilisation d'anciennes données

✅ Nouvelle allocation pour chaque élément

💬 Bulle d'ami :
"Refaire un monde neuf à partir des ruines."

🎯 Mini-TDD :
Créer une liste transformée à partir d'une liste existante.

📚 Récapitulatif rapide Partie 7 :

Fonction Ce que tu dois savoir faire
ft_lstnew Créer un élément de liste
ft_lstadd_front Ajouter au début
ft_lstsize Compter
ft_lstlast Trouver la fin
ft_lstadd_back Ajouter à la fin
ft_lstdelone Supprimer un élément
ft_lstclear Supprimer toute une liste
ft_lstiter Modifier chaque élément existant
ft_lstmap Créer une nouvelle liste transformée

# Bloc 2 — Libft++ Boostée — Partie 8/8 [🟢 Facile]
📚 Introduction rapide Partie 8
Ici, tu vas :

Apprendre à écrire un Makefile propre,

Apprendre à compiler ton projet automatiquement,

Mettre en place un vrai TDD complet,

Automatiser tes tests pour devenir solide et rigoureux.

Objectif :
➔ Transformer ta Libft++ en un projet prêt à être livré en entreprise.

📚 Ce que tu vas faire
## 8.0) Créer un Makefile Pro
Ton Makefile devra :

Compiler tous les .c du dossier src/,

Placer les .o dans un dossier build/ (ou directement à la racine si simple),

Générer une librairie statique appelée libft.a,

Nettoyer (make clean), nettoyer complètement (make fclean), recompiler (make re),

Gérer correctement les dépendances (make all, make bonus si besoin).

📋 Plan minimal de ton Makefile

Cible Action
all Compile la libft.a
clean Supprime les fichiers .o
fclean Supprime .o + .a
re Relance clean + all
📋 Rappels très importants :

Règle Détail
Nom du fichier Makefile (majuscule obligatoire)
Variables autorisées ✅ CC, CFLAGS, SRCS, OBJS, NAME
Commandes invisibles ✅ Utiliser @ pour cacher la commande
Interdictions ❌ Pas d'appels à gcc sauvages en dehors des règles
## 8.1) Mettre en place un TDD Complet
Tu dois :

Créer un dossier tests/,

Dans tests/, avoir un fichier de test par fonction (tests_ft_strlen.c, etc.),

Chaque fichier doit :

Tester ta fonction avec des entrées valides,

Tester avec des cas limites (chaînes vides, NULL, etc.),

Vérifier les erreurs possibles.

## 8.2) Automatiser l'exécution des tests
Ton objectif :

Créer une règle make tests,

Cette règle compile les tests,

Puis exécute les tests automatiquement,

Affiche clairement si les tests passent ou échouent.

(Tu pourras faire simple au début, puis améliorer avec du vert/rouge plus tard.)

📚 Exemples simples de TDD attendu
Exemple Test - ft_strlen
c
Copier
Modifier
```c
# include "../include/libft.h"
# include <stdio.h>

```
void test_ft_strlen(void)
{
 if (ft_strlen("hello") != 5)
```c
 printf("❌ Test ft_strlen(\"hello\") échoué\n");
 else
 printf("✅ Test ft_strlen(\"hello\") réussi\n");

```
 if (ft_strlen("") != 0)
```c
 printf("❌ Test ft_strlen(\"\") échoué\n");
 else
 printf("✅ Test ft_strlen(\"\") réussi\n");
}
(Puis tu auras un main spécial pour tout exécuter dans tests/.)

```
📚 Arborescence finale attendue
plaintext
Copier
Modifier
libft/
├── Makefile
├── src/
│ ├── ft_strlen.c
│ ├── ft_strcpy.c
│ └── (toutes tes fonctions)
├── include/
│ ├── libft.h
├── tests/
│ ├── tests_ft_strlen.c
│ ├── tests_ft_strcpy.c
│ ├── tests_main.c
├── build/
│ ├── (tous les fichiers .o)
├── libft.a
📋 Checklist pour finaliser ta Libft++

Etape Fait ?
Toutes les fonctions codées 🟰
Header libft.h propre 🟰
Makefile propre 🟰
Tests TDD présents 🟰
Tests automatiques 🟰
Nettoyage correct 🟰
Respect norme 42 (aucune faute norme) 🟰
Aucun warning à la compilation 🟰
Structure propre 🟰

✅ Bloc 2 Partie 8 — Libft++ Boostée terminé proprement ! [🟢 Facile]

══════════════════════════════════════════════════════════════════════════
# Bloc 3 — GNL++ Boosté [🟡 Intermédiaire]
══════════════════════════════════════════════════════════════════════════

📚 Introduction Bloc 3 - Get Next Line [🟡 Intermédiaire]
🎯 Objectif
Lire un fichier ligne par ligne, dynamiquement,

Gérer correctement la mémoire, les erreurs, les EOF (End Of File),

Savoir manipuler les buffers et les retours incomplets,

Respecter la norme 42 strictement.

📚 Ce que tu vas apprendre

Sujet Compétence
Buffers Lire par blocs (read)
Pointeurs complexes Concaténation dynamique de mémoire
Gestion de la mémoire malloc, free, strjoin, strdup, etc.
Gestion d'erreur EOF, erreurs de lecture
Fonction robuste Fonction unique et réutilisable
🚀 Prototype officiel de Get Next Line
c
Copier
Modifier
```c
char *get_next_line(int fd);
fd ➔ file descriptor du fichier à lire.
Retour ➔ une ligne complète terminée par \n ou la fin du fichier.

```
📚 Contraintes imposées

Interdits Autorisés
❌ Pas d'utilisation de fopen, fgets, getline, etc. ✅ Seulement read, malloc, free
❌ Pas de lib externe (sauf ta libft++) ✅ Tu peux utiliser tes propres fonctions (libft++)
❌ Pas de fuite mémoire ✅ Chaque appel de get_next_line gère mémoire proprement
📋 Détail de fonctionnement GNL++
💬 Comment ça marche ?

Étape Action
1 Lire dans un buffer de taille fixe (ex: BUFFER_SIZE = 42)
2 Chercher un \n dans ce buffer
3 Extraire tout jusqu'au \n et garder le reste
4 Renvoyer une ligne complète à chaque appel
5 Libérer correctement tout à la fin
📚 Fonctions que tu devrass recréer/utiliser

Fonction Utilité
ft_strlen Calculer longueur d'une chaîne
ft_strchr Chercher caractère \n
ft_strdup Dupliquer une chaîne
ft_strjoin Joindre deux chaînes
ft_substr Extraire sous-chaîne
📋 Plan de ton code GNL++
Fichier principal :
get_next_line.c

get_next_line_utils.c

get_next_line.h

📋 Contenu minimal de get_next_line.h
c
Copier
Modifier
# ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

# include <unistd.h>
# include <stdlib.h>

```c
char *get_next_line(int fd);
char *ft_strjoin_gnl(char *s1, char *s2);
char *ft_strdup_gnl(const char *s);
char *ft_strchr_gnl(const char *s, int c);
size_t ft_strlen_gnl(const char *s);

```
# endif
📚 Mini explication stratégique
Exemple basique d'utilisation dans main.c :

c
Copier
Modifier
```c
# include "get_next_line.h"
# include <fcntl.h>
# include <stdio.h>

```
int main(void)
{
```c
 int fd = open("mon_fichier.txt", O_RDONLY);
 char *line;

```
 while ((line = get_next_line(fd)) != NULL)
 {
```c
 printf("%s", line);
 free(line);
 }
 close(fd);
 return (0);
}
🎯 TDD minimal attendu pour GNL++
Lire plusieurs fichiers simultanément,

```
Tester fichier vide,

Tester fichier contenant seulement des sauts de lignes,

Tester fichiers gigantesques,

Tester gestion d'erreurs (fd invalide, etc.).

📋 À construire pour ton projet GNL++

Dossier Contenu
gnl/ ton code GNL (get_next_line.c, .h, etc.)
tests/ tests_get_next_line.c
Makefile pour compiler séparément GNL

# Bloc 3 — GNL++ Boosté — Partie 1/? [🟡 Intermédiaire]
📚 Introduction rapide de Partie 1
Ici, on ne code pas tout d'un coup.
On construit GNL étape par étape, proprement, sans tricher :

Écrire seulement les outils (utils) nécessaires,

Ensuite, construire la logique de lecture progressivement,

Enfin, assembler tout dans get_next_line.c.

📋 Premier objectif de Partie 1

Objectif immédiat Détail
Créer uniquement les outils (utils) ft_strlen, ft_strchr, ft_strdup, ft_strjoin
On ne touche pas encore à read() !
On construit juste ta "boîte à outils".

📚 Fonctions de cette Partie 1
## 3.1.0) ft_strlen_gnl
Le but :
Calculer la taille d'une chaîne (strlen) pour Get Next Line.

Prototype :

c
Copier
Modifier
```c
size_t ft_strlen_gnl(const char *s);
Explication :
Retourner combien de caractères il y a avant \0.

```
Interdictions :

❌ Pas d'appel à strlen

✅ Tout parcourir manuellement

💬 Bulle d'ami :
"Le silence (\0) marque toujours la fin du voyage."

🎯 Mini-TDD :
Tester "hello" ➔ 5, "" ➔ 0.

## 3.1.1) ft_strchr_gnl
Le but :
Trouver la première occurrence d'un caractère dans une chaîne.

Prototype :

c
Copier
Modifier
```c
char *ft_strchr_gnl(const char *s, int c);
Explication :
Chercher c dans s et retourner un pointeur dessus.

```
Interdictions :

❌ Pas de strchr

✅ Parcours manuel obligatoire

💬 Bulle d'ami :
"Trouver la première étoile sur ta carte."

🎯 Mini-TDD :
Chercher 'o' dans "bonjour" ➔ tomber sur le 2ᵉ caractère o.

## 3.1.2) ft_strdup_gnl
Le but :
Dupliquer une chaîne de caractères.

Prototype :

c
Copier
Modifier
```c
char *ft_strdup_gnl(const char *s1);
Explication :
Allouer la mémoire et copier la chaîne.

```
Interdictions :

❌ Pas de strdup

✅ Utiliser malloc + copie manuelle

💬 Bulle d'ami :
"Créer un double parfait sans vol d'identité."

🎯 Mini-TDD :
Dupliquer "Test" ➔ nouvelle adresse mémoire, même contenu.

## 3.1.3) ft_strjoin_gnl
Le but :
Joindre deux chaînes ensemble.

Prototype :

c
Copier
Modifier
```c
char *ft_strjoin_gnl(char *s1, char *s2);
Explication :
Allouer une nouvelle chaîne contenant s1 puis s2.

```
Interdictions :

❌ Pas de strcat

✅ Construction manuelle obligatoire

💬 Bulle d'ami :
"Fusionner deux rivières pour créer un fleuve."

🎯 Mini-TDD :
Joindre "abc" et "def" ➔ "abcdef".

📚 Résumé de Partie 1 :

Fonction Ce que tu sais faire
ft_strlen_gnl Mesurer une chaîne
ft_strchr_gnl Chercher un caractère
ft_strdup_gnl Dupliquer une chaîne
ft_strjoin_gnl Fusionner deux chaînes

# Bloc 3 — GNL++ Boostée — Partie 2/? [🟡 Intermédiaire]
📚 Introduction rapide Partie 2
Maintenant que tu as ta boîte à outils (utils),
tu vas apprendre à utiliser read() correctement.

On va construire la première lecture et accumuler dynamiquement la mémoire.

📋 Objectif immédiat Partie 2

Objectif immédiat Détail
Implémenter la lecture de BUFFER_SIZE octets ✅
Accumuler dans une "stash" ✅
Détecter quand une ligne complète (\n) est prête ✅
📚 Ce que tu dois construire
## 3.2.0) Gérer la lecture en blocs (BUFFER_SIZE)
Le but :

Lire par petits morceaux,

Concaténer ce qui est lu au fur et à mesure.

📋 Exemple logique interne simplifiée
c
Copier
Modifier
```c
// Lire BUFFER_SIZE octets
ret = read(fd, buffer, BUFFER_SIZE);

```
c
// Ajouter buffer lu à la stash
stash = ft_strjoin_gnl(stash, buffer);
## 3.2.1) Comprendre la "stash" 📦
Définition de stash :

```
📦 stash = contenu partiellement lu et mémorisé,

Chaque appel de get_next_line doit reprendre à partir de là où il s'était arrêté.

Situation Action
Pas de \n trouvé Continuer à lire et concaténer
\n trouvé Couper et retourner une ligne
## 3.2.2) Lire en boucle jusqu'à trouver une ligne complète
Logique en pseudo-code :

c
Copier
Modifier
while (pas de '\n' trouvé ET pas d'erreur)
{
 ret = read(fd, buffer, BUFFER_SIZE);
 si (erreur de read ou ret == 0)
 break;
 stash = ft_strjoin_gnl(stash, buffer);
}
📚 Petits détails techniques

Détail Important
read() retourne le nombre d'octets lus (0 si fin de fichier, -1 si erreur)
Bien \0-terminer ton buffer après chaque read 
Ne jamais oublier de free le buffer quand terminé 
🎯 Mini plan d'action Partie 2
Lire BUFFER_SIZE octets,

Ajouter à la stash,

Si \n est trouvé ➔ STOP et prépare la ligne,

Sinon ➔ continue de lire.

📋 TDD minimal de Partie 2

Test Attendu
Fichier contenant plusieurs lignes longues Lire et retourner chaque ligne correctement
Fichier contenant peu de \n Accumuler le contenu correctement sans erreur
Fichier vide Retourner NULL sans crash

# Bloc 3 — GNL++ Boostée — Partie 3/? [🟡 Intermédiaire]
📚 Introduction rapide Partie 3
Maintenant que tu sais lire et accumuler dans une stash,
il faut séparer la bonne ligne de tout ce qui reste dans la mémoire.

C'est l'étape clé qui transforme ton buffer en vraie ligne utilisable.

📋 Objectif immédiat Partie 3

Objectif immédiat Détail
Extraire la ligne jusqu'au premier \n ✅
Garder le reste dans la stash pour plus tard ✅
📚 Ce que tu dois construire
## 3.3.0) Extraire la ligne prête
Le but :

Parcourir la stash,

Copier tout jusqu'à et y compris le \n,

Retourner cette ligne.

📋 Exemple de logique
c
Copier
Modifier
trouver la position du premier '\n'
copier de 0 jusqu'à cette position dans un nouveau malloc
📋 Petit rappel important :
Si pas de \n, et stash non vide, retourner tout ce qu'il reste,

Si stash vide, retourner NULL.

## 3.3.1) Garder le reste pour plus tard
Le but :

Après avoir extrait la ligne,

Ne pas oublier de :

Garder ce qu'il reste après \n,

Réinitialiser proprement la stash.

📋 Exemple de logique
c
Copier
Modifier
stash = tout ce qui est après '\n'
(Il faudra free l'ancienne stash avant de créer la nouvelle.)

📚 Astuces pour réussir

Conseil Pourquoi
Utiliser ft_strchr_gnl Trouver facilement où couper
Utiliser ft_substr Extraire proprement une partie
Free ce qui est inutile Pour éviter les fuites mémoire
🎯 Mini plan d'action Partie 3
Chercher la position du premier \n,

Copier tout jusqu'à \n dans la ligne à retourner,

Copier le reste dans une nouvelle stash,

Free l'ancienne stash,

Retourner la ligne trouvée.

📋 TDD minimal Partie 3

Test Attendu
Lire un fichier de plusieurs lignes Chaque appel retourne exactement une ligne terminée par \n
Dernière ligne sans \n Retourner la ligne restante même sans \n
Fichier vide Retourner NULL immédiatement

# Bloc 3 — GNL++ Boostée — Partie 4/4 [🟡 Intermédiaire]
📚 Objectif final de cette partie

Étape Description
✅ Gestion du EOF Retourner NULL proprement à la fin du fichier
✅ Gestion des erreurs de read() Ne pas crasher, libérer mémoire
✅ Libération mémoire (free) À chaque sortie, tout doit être propre
✅ Code compact et clair Réutilisable dans tous tes projets
✅ Résumé du comportement attendu de get_next_line

Cas Comportement
Appel normal avec ligne terminée par \n Retourne la ligne avec \n
Appel sur dernière ligne sans \n Retourne le reste de la ligne
Fichier terminé Retourne NULL
Erreur read() Retourne NULL et libère tout
Plusieurs appels successifs Continue où ça s'est arrêté
📚 Étapes internes à vérifier dans ton code
📦 1. Initialiser le buffer de lecture
Allouer BUFFER_SIZE + 1

Vérifier le fd

Retourner NULL en cas de problème

🔁 2. Lire et accumuler (Partie 2)
Lire dans buffer

Concaténer dans la stash

Continuer jusqu'à trouver un \n ou EOF

✂️ 3. Extraire la ligne (Partie 3)
Créer une ligne allant jusqu'au premier \n

Retourner la ligne à l'utilisateur

📦 4. Nettoyer la stash
Garder ce qu'il reste après le \n

Si plus rien ➔ stash = NULL

❌ 5. Gérer les erreurs
Si read retourne -1 ➔ free stash, buffer, retourner NULL

Ne jamais laisser de malloc sans free derrière

📋 TDD Final pour valider ton GNL++

Test Ce que tu dois valider
Fichier normal Lecture ligne par ligne avec \n
Fichier sans retour à la ligne final Dernière ligne retournée proprement
Fichier vide Retourne NULL sans erreur
Fichier avec beaucoup de lignes Aucune fuite mémoire (Valgrind ✅)
Fichier non ouvert (fd = -1) Retourne NULL proprement
Appel multiple sur différents fd Chaque fd garde son état (bonus)
✅ Et maintenant ? Tu as un vrai GNL pro 🎯
📚 Arborescence finale de ton projet GNL++
plaintext
Copier
Modifier
gnl/
├── get_next_line.c
├── get_next_line_utils.c
├── get_next_line.h
├── main.c
├── Makefile

# Bloc 4 — Pipex++ Boosté [🟡 Intermédiaire]
📚 Objectif de Pipex++
Reproduire ce que fait un shell Linux quand on tape :

bash
Copier
Modifier
$ < infile cmd1 | cmd2 > outfile
Autrement dit :

Lire l'entrée depuis un fichier (infile),

Passer la sortie de cmd1 dans l'entrée de cmd2,

Envoyer la sortie finale dans outfile.

Tu dois :

Utiliser les pipes, forks, dup2, execve, etc.

Gérer les erreurs système avec propreté,

Devenir à l'aise avec les processus Unix et les redirections.

🔁 Résultat attendu de ton programme
bash
Copier
Modifier
$ ./pipex infile "ls -l" "grep .c" outfile
Doit équivaloir à :

bash
Copier
Modifier
$ < infile ls -l | grep .c > outfile
📦 Étapes générales

Étape Explication
1. Ouvrir infile open() en lecture
2. Créer un pipe() pour la communication entre les deux cmd
3. fork() le processus une fois pour chaque commande
4. Rediriger les entrées/sorties avec dup2() pour relier les commandes au pipe
5. Exécuter les commandes avec execve() passage des arguments et PATH
6. Fermer les fichiers et gérer les erreurs avec attention et rigueur
📚 À utiliser obligatoirement

Fonction Utilité
pipe() Créer un canal de communication
fork() Créer un nouveau processus
dup2() Dupliquer une stdin/stdout vers un pipe
execve() Exécuter une commande binaire
waitpid() Attendre que les enfants se terminent
access() Vérifier qu'un fichier est accessible
📚 Ce que tu vas devoir implémenter

Partie Fonctionnalité
pipex.c Le point d'entrée principal
pipex_utils.c Fonctions outils: parsing, erreurs
pipex.h En-tête de fonctions
parse_cmd.c Séparer les arguments et préparer execve
error_handling.c Affichage et nettoyage des erreurs
🧪 TDD minimal à mettre en place

Test Ce que tu vérifies
Fichier infile inexistant Message d'erreur clair, pas de segfault
Commande invalide Ne plante pas, affiche une erreur
Permissions refusées Gère correctement l'erreur
Plusieurs arguments dans les commandes Bien traités
Redirection correcte de stdin et stdout Résultat final écrit dans outfile
📚 Exemple de structure finale attendue
plaintext
Copier
Modifier
pipex/
├── pipex.c
├── pipex_utils.c
├── parse_cmd.c
├── error_handling.c
├── pipex.h
├── Makefile
├── tests/
│ └── tests_pipex.sh

# Bloc 4 — Pipex++ Boosté — Partie 1/? [🟡 Intermédiaire]
📚 Introduction rapide Partie 1
Objectif immédiat :
➔ Lire les arguments passés à ton programme
➔ Ouvrir correctement infile et outfile

Sans entrer encore dans les pipes ou forks.

📋 Ce que tu vas faire maintenant

Étape Objectif
1 Vérifier que tu reçois les bons arguments
2 Ouvrir infile en lecture
3 Ouvrir (ou créer) outfile en écriture
📚 Plan précis Bloc 4 Partie 1 [🟡 Intermédiaire]
## 4.1.0) Vérifier les arguments
Ton programme doit être appelé comme ceci :

bash
Copier
Modifier
./pipex infile "cmd1" "cmd2" outfile
Donc :

argv[0] = ./pipex

argv[1] = infile

argv[2] = cmd1

argv[3] = cmd2

argv[4] = outfile

📋 Mini-code (pas encore complet) pour vérifier
c
Copier
Modifier
if (argc != 5)
{
 write(2, "Error: wrong number of arguments\n", 33);
```c
 return (1);
}
## 4.1.1) Ouvrir infile
Utilise open() en lecture seule :

```
c
Copier
Modifier
```c
int infile_fd = open(argv[1], O_RDONLY);
if (infile_fd < 0)
{
 perror("Error opening infile");
 return (1);
}
## 4.1.2) Ouvrir (ou créer) outfile
Utilise open() avec ces flags :

```
O_CREAT: créer si n'existe pas,

O_WRONLY: écriture uniquement,

O_TRUNC: écraser le contenu si le fichier existe.

c
Copier
Modifier
```c
int outfile_fd = open(argv[4], O_CREAT | O_WRONLY | O_TRUNC, 0644);
if (outfile_fd < 0)
{
 perror("Error opening outfile");
 return (1);
}
(0644 = droits classiques lecture/écriture pour l'utilisateur)

```
🎯 Mini résumé étape Partie 1

Action À vérifier
Vérifier argc == 5 sinon erreur
Ouvrir infile en lecture avec gestion d'erreur
Ouvrir outfile en écriture avec gestion d'erreur
📋 TDD minimal Bloc 4 Partie 1 [🟡 Intermédiaire]

Test Attendu
Lancement sans 5 arguments Message d'erreur propre
Fichier infile inexistant Message d'erreur clair
Impossible d'ouvrir outfile Message d'erreur clair

# Bloc 4 — Pipex++ Boosté — Partie 2/? [🟡 Intermédiaire]
📚 Introduction rapide Partie 2
Maintenant que :

Tes arguments sont validés,

Tes fichiers infile et outfile sont ouverts,

Tu vas apprendre à :

Créer un pipe (pipe()),

Dupliquer les entrées/sorties avec dup2() pour contrôler qui écrit/lit.

📋 Objectif immédiat Partie 2

Étape Objectif
1 Créer un pipe (pipe())
2 Forker pour exécuter cmd1
3 Rediriger l'entrée depuis infile et la sortie vers le pipe
4 Préparer à exécuter la commande
📚 Ce que tu dois construire maintenant
## 4.2.0) Créer un pipe
Un pipe, c'est simplement un tableau de 2 entiers :

c
Copier
Modifier
```c
int pipefd[2];
if (pipe(pipefd) == -1)
{
 perror("pipe");
 return (1);
}
pipefd[0]: la lecture du pipe,

```
pipefd[1]: l'écriture dans le pipe.

## 4.2.1) Forker
Un fork() crée deux processus :

Le parent continue normalement,

Le fils est un clone qui peut exécuter une autre commande.

c
Copier
Modifier
pid_t pid = fork();
if (pid == -1)
{
 perror("fork");
```c
 return (1);
}
## 4.2.2) Dans le fils — préparation pour cmd1
Le fils doit :

```
Rediriger son stdin depuis infile (via dup2(infile_fd, 0)),

Rediriger son stdout vers le pipe (via dup2(pipefd[1], 1)).

c
Copier
Modifier
if (pid == 0)
{
 dup2(infile_fd, 0); // Remplacer l'entrée standard par infile_fd
 dup2(pipefd[1], 1); // Remplacer la sortie standard par l'écriture du pipe
 close(pipefd[0]); // Important ! Ne pas garder la lecture ouverte
```c
 // Ici: exécuter cmd1
}
## 4.2.3) Dans le parent — préparation pour cmd2
Le parent :

```
Va attendre plus tard,

Mais surtout prépare à lire depuis le pipe.

📋 Attention importante

Détail Pourquoi
Toujours fermer les fd inutiles Sinon ton programme "pend" sur le pipe
Après dup2() tu n'as plus besoin des fd d'origine car les dup2 ont redirigé les flux
📚 Schéma de fonctionnement
plaintext
Copier
Modifier
[infile] → [cmd1] → (pipe) → [cmd2] → [outfile]
🎯 Mini plan d'action Partie 2
Créer un pipe(),

fork() pour créer un processus enfant,

Dans le fils :

Rediriger stdin (dup2 infile),

Rediriger stdout (dup2 pipe écriture),

Fermer les fd inutiles,

Dans le parent :

Préparer à lancer cmd2 dans la prochaine partie.

📋 TDD minimal Bloc 4 Partie 2 [🟡 Intermédiaire]

Test Attendu
Pipe est bien créé Pas d'erreur
Fork se passe bien Deux processus créés
Redirection de stdin/stdout correcte Peut écrire et lire

# Bloc 4 — Pipex++ Boosté — Partie 3/? [🟡 Intermédiaire]
📚 Introduction rapide Partie 3
Tu as maintenant :

Créé ton pipe,

Forké ton premier processus,

Redirigé correctement stdin et stdout.

Maintenant, dans ton fils, tu vas :

Exécuter vraiment la commande cmd1,

Transformer ton processus en cmd1 grâce à execve().

📋 Objectif immédiat Partie 3

Étape Objectif
1 Préparer la commande et ses arguments
2 Trouver le chemin absolu de la commande
3 Exécuter avec execve()
4 Gérer les erreurs d'exécution
📚 Ce que tu dois construire
## 4.3.0) Préparer la commande et ses arguments
Récupérer cmd1 (qui est une seule string "ls -l") :

Tu dois split cette string pour récupérer :

"ls"

"-l"

Utilise ta fonction perso ft_split (ou un split équivalent).

c
Copier
Modifier
```c
char **args = ft_split(argv[2], ' ');
## 4.3.1) Trouver le chemin absolu de la commande
Le binaire "ls" n'est pas directement disponible. Tu dois chercher dans $PATH :

```

Étape Action
1 Récupérer la variable PATH de l'environnement (envp)
2 Split par: pour obtenir toutes les possibilités
3 Tester chaque chemin en ajoutant /cmd
4 Utiliser access(path, X_OK) pour vérifier si c'est exécutable
(On fera une fonction spéciale find_path() bientôt si tu veux.)

## 4.3.2) Appeler execve
Une fois que tu as :

Le chemin absolu de cmd1,

Les arguments (args),

tu fais simplement :

c
Copier
Modifier
execve(path, args, envp);
⚡ Attention :
Si execve fonctionne, il ne revient jamais.
Si execve échoue, tu dois :

free proprement tout,

exit(1).

📚 Schéma du processus cmd1
plaintext
Copier
Modifier
[infile] -> [fork fils] -> [redirection stdin, stdout] -> [execve(cmd1)]
📋 Exemple simplifié
c
Copier
Modifier
if (pid == 0)
{
 dup2(infile_fd, 0);
 dup2(pipefd[1], 1);
 close(pipefd[0]);
 close(pipefd[1]);
 args = ft_split(argv[2], ' ');
 path = find_path(args[0], envp);
 if (!path)
 {
 perror("command not found");
 exit(1);
 }
 execve(path, args, envp);
```c
 // Si execve échoue
 perror("execve");
 exit(1);
}
📚 Rappels critiques

```
Point Pourquoi
Toujours free avant d'exiter si erreur Sinon fuite mémoire
execve ne retourne jamais si réussi Important de comprendre
🎯 Mini plan d'action Partie 3
Split cmd1,

Trouver le chemin absolu dans $PATH,

Appeler execve(path, args, envp),

En cas d'échec ➔ clean + exit(1).

📋 TDD minimal Bloc 4 Partie 3 [🟡 Intermédiaire]

Test Ce que tu dois vérifier
Commande valide La commande s'exécute et sort dans le pipe
Commande invalide Message "command not found" propre
Plusieurs arguments dans cmd1 Correctement pris en compte

# Bloc 4 — Pipex++ Boosté — Partie 4/4 [🟡 Intermédiaire]
📚 Introduction rapide Partie 4
Maintenant que :

Ton fils exécute cmd1,

Ton pipe est prêt à transférer la sortie de cmd1 vers cmd2,

Tu dois :

Faire exécuter cmd2 dans le parent,

Lire depuis le pipe,

Écrire dans outfile,

Nettoyer correctement.

📋 Objectif immédiat Partie 4

Étape Objectif
1 Dans le parent, préparer la lecture du pipe
2 Forker à nouveau pour exécuter cmd2
3 Rediriger correctement stdin et stdout
4 Exécuter cmd2 avec execve
📚 Ce que tu dois construire maintenant
## 4.4.0) Dans le parent après fork
Après avoir lancé cmd1, dans le processus parent :

Fermer pipefd[1] (on n'écrit plus dedans),

Garder pipefd[0] pour la lecture.

## 4.4.1) Forker pour lancer cmd2
Tu refais un fork() pour un nouveau fils :

c
Copier
Modifier
pid_t pid2 = fork();
if (pid2 == -1)
{
 perror("fork");
```c
 return (1);
}
## 4.4.2) Dans le second fils — rediriger et exécuter cmd2
Dans ce second processus fils :

```
stdin doit venir de pipefd[0] (la sortie de cmd1),

stdout doit aller vers outfile_fd.

c
Copier
Modifier
if (pid2 == 0)
{
 dup2(pipefd[0], 0); // Lire depuis le pipe
 dup2(outfile_fd, 1); // Écrire dans outfile
 close(pipefd[0]);
 close(outfile_fd);
 args = ft_split(argv[3], ' ');
 path = find_path(args[0], envp);
 if (!path)
 {
 perror("command not found");
 exit(1);
 }
 execve(path, args, envp);
 perror("execve");
 exit(1);
}
## 4.4.3) Dans le parent final
Après avoir forké le second fils :

Fermer tout ce qui reste,

Attendre les deux fils (waitpid()).

c
Copier
Modifier
close(pipefd[0]);
close(infile_fd);
close(outfile_fd);
waitpid(pid, NULL, 0);
waitpid(pid2, NULL, 0);
📚 Résumé fonctionnement Pipex
plaintext
Copier
Modifier
[infile] → [cmd1] → (pipe) → [cmd2] → [outfile]
📋 Schéma global complet du projet Pipex
plaintext
Copier
Modifier
Parent Process
│
├── fork() --> Processus fils 1
│ (stdin = infile, stdout = pipe[1], execve(cmd1))
│
├── Parent ferme pipe[1]
│
├── fork() --> Processus fils 2
│ (stdin = pipe[0], stdout = outfile, execve(cmd2))
│
└── Parent ferme pipe[0], infile, outfile et attend les deux enfants
🎯 Mini plan d'action Partie 4
Forker second fils,

Rediriger entrées/sorties (dup2(pipe, infile) et dup2(outfile)),

Exécuter cmd2,

Parent nettoie tout et attend.

📋 TDD minimal Bloc 4 Partie 4 [🟡 Intermédiaire]

Test Ce que tu dois vérifier
Commandes valides Sortie correcte dans outfile
Commandes invalides Erreurs affichées proprement
Permissions refusées Géré sans crash
Plusieurs arguments dans cmd2 Ok

# Bloc 5 — Minishell++ Boosté [🟠 Avancé]
📚 Objectif de Minishell++
Recréer un vrai terminal Linux capable de :

Comprendre des commandes,

Gérer des pipes (|),

Gérer des redirections (>, <, >>),

Gérer des variables d'environnement ($VAR),

Gérer des erreurs proprement,

Gérer des signaux (CTRL+C, CTRL+D).

📋 À terme, ton minishell devra permettre :

Exemple utilisateur Ton Minishell doit savoir faire
ls -l ✅ Affiche liste fichiers
cat < file.txt ✅ Lecture fichier
`grep hello wc -l`
echo hello > output.txt ✅ Redirection sortie
export VAR=value et echo $VAR ✅ Variables d'environnement
CTRL+C pour interrompre une commande ✅ Gestion signaux
📚 Les étapes majeures de Minishell++
1. Lire la ligne de commande
Utiliser readline() pour obtenir ce que tape l'utilisateur.

(Ou read et gestion maison si pas de readline au début)

2. Parser correctement la commande

Action Objectif
Séparer les mots et options ✅
Détecter les pipes ` `
Détecter les redirections < > >> ✅
Reconnaître les quotes ' " " ✅
Gérer les variables d'environnement $VAR ✅
3. Exécuter la commande

Action Objectif
Forker un processus ✅
Gérer redirections/fd correctement ✅
Exécuter binaire ou built-in ✅
4. Implémenter les "built-ins"
Un built-in est une commande interne à ton shell (pas un binaire externe) :

Built-in attendu Fonction
echo Afficher un texte
cd Changer de répertoire
pwd Afficher le répertoire courant
export Ajouter une variable d'environnement
unset Supprimer une variable d'environnement
env Lister l'environnement
exit Quitter minishell
5. Gérer correctement la mémoire
À chaque commande :

Libérer tout ce qui doit l'être (pas de fuite mémoire).

Séparer clairement parsing / exécution / destruction.

6. Gérer les signaux

Signal Action
CTRL+C (SIGINT) Interrompre l'exécution d'une commande
CTRL+D (EOF) Quitter le shell proprement
📦 Organisation du projet attendue
plaintext
Copier
Modifier
minishell/
├── src/
│ ├── main.c
│ ├── parser.c
│ ├── executor.c
│ ├── builtins.c
│ ├── env.c
│ ├── signals.c
│ ├── utils.c
├── include/
│ ├── minishell.h
├── tests/
│ ├── tests_minishell.sh
├── Makefile
🎯 Objectifs pédagogiques réels de Minishell
Maîtriser les processus UNIX (fork, execve, pipe),

Maîtriser l'allocation dynamique avancée,

Comprendre l'architecture d'un programme complexe,

Devenir autonome sur debug, gdb, valgrind.





🧩 Module 3 — types/ — Types avancés, bitfields, union, enum [📐 Niveau Moyen à Avancé]
📦 Module types/ — Typologie avancée en langage C [📐 Moyen à Avancé]
🎯 Objectif pédagogique
Ce module a pour but de t’enseigner des types plus complexes et plus puissants du C, souvent méconnus mais indispensables en bas niveau, dans les protocoles, l’embarqué ou les OS :

typedef, pour améliorer la lisibilité

enum, pour définir des constantes lisibles

union, pour partager la mémoire entre types

bitfield, pour économiser de la place et manipuler des bits

volatile, restrict, pour optimiser ou contrôler la compilation

📚 Concepts abordés
✅ 1. typedef — Créer des alias
c
Copier
Modifier
typedef unsigned char t_byte;
typedef struct s_point {
    int x;
    int y;
} t_point;
→ Améliore la lisibilité dans les projets complexes.

✅ 2. enum — Constantes lisibles et logiques
c
Copier
Modifier
enum e_state { OFF, ON, PAUSE };

enum e_state power = ON;
→ Remplace des #define, avec typage, debug facile, lisibilité ++.

✅ 3. union — Partage mémoire
c
Copier
Modifier
union u_data {
    int i;
    float f;
    char c[4];
};

union u_data d;
d.i = 42;
printf("%f\n", d.f); // Interprétation du même bloc mémoire en float
→ Utilisé dans : parsing binaire, protocoles, représentation polymorphe.

✅ 4. bitfields — Occupation mémoire minimale
c
Copier
Modifier
struct s_flags {
    unsigned a : 1;
    unsigned b : 1;
    unsigned c : 2;
};

struct s_flags f = {1, 0, 3};
→ Parfait pour gérer des flags, des octets binaires, ou des registres.

✅ 5. Modificateurs spéciaux
volatile :
Empêche les optimisations → utile en accès mémoire directe (hardware, signal, thread)

c
Copier
Modifier
volatile int status; // lu à chaque fois dans la RAM, jamais mis en cache
restrict (C99) :
Indique au compilateur qu’un pointeur est seul à accéder à une mémoire

c
Copier
Modifier
void add(int *restrict a, int *restrict b);
→ Optimise certaines boucles (précaution requise).

🧪 Exercices
📂 types/ex00 — Structure et typedef
Crée une struct t_point { int x, y; } avec un typedef, initialise-la et affiche-la.

📂 types/ex01 — Utilisation de enum
Définir un enum e_direction (NORTH, SOUTH, EAST, WEST). Créer une fonction print_direction(enum e_direction).

📂 types/ex02 — union et interprétation binaire
Utilise une union pour lire un entier comme tableau de char.

c
Copier
Modifier
union {
    int i;
    char c[4];
} u;

u.i = 0x12345678;
printf("%x %x %x %x\n", u.c[0], u.c[1], u.c[2], u.c[3]);
→ Permet d’aborder la notion d’endianess (bonus).

📂 types/ex03 — bitfields
Créer une struct s_flags avec 4 bits : is_active, is_visible, is_dirty, reserved.
Affiche leur état.

📂 types/ex04 — volatile et optimisation
Comparer deux versions d’un compteur while (!flag);
→ Dans l'une, flag est volatile, dans l’autre non. Compiler avec -O2.

🔬 Bonus : visualisation mémoire
Comparer la taille de struct, union, bitfield

Afficher les offsets avec offsetof() et sizeof()






# Bloc 5 — Minishell++ Boosté — Partie 1/9 [🟠 Avancé]
📚 Objectif immédiat
Commencer simple mais propre :
➔ Lire une ligne de commande tapée par l'utilisateur.

Sans parsing encore, sans exécution — juste lire et afficher.

📋 Ce que tu dois faire dans cette Partie

Étape Objectif
1 Afficher un prompt (ex: minishell$ )
2 Lire une ligne tapée par l'utilisateur
3 Afficher ce qui a été tapé
4 Répéter indéfiniment (boucle infinie)
📚 Les fonctions utiles pour ça
## Option 1: Avec readline (pro)
readline() permet :

D'avoir un historique de commandes,

Un affichage clean,

Une gestion des touches clavier améliorée.

🛠️ Librairie à linker avec -lreadline.

Prototype readline :

c
Copier
Modifier
```c
char *readline(const char *prompt);
## Option 2: Sans readline (manuel)
Si tu ne veux pas utiliser readline tout de suite :

```
Utiliser write(1, "minishell$ ", 11);

Lire avec get_next_line(0); (si tu as codé ton GNL)

Ou avec read(0, buffer, size); (manuel)

📋 Exemple minimal avec readline
c
Copier
Modifier
```c
# include <stdio.h>
# include <readline/readline.h>
# include <readline/history.h>

```
int main(void)
{
```c
 char *input;

```
 while (1)
 {
 input = readline("minishell$ ");
 if (!input) // Gestion de CTRL+D
 {
```c
 printf("exit\n");
 break;
 }
 if (*input) // Ne pas ajouter de vide à l'historique
 add_history(input);
 printf("Vous avez tapé: %s\n", input);
 free(input);
 }
 return (0);
}
📋 Ce qu'on apprend ici

```
Sujet Pourquoi c'est important
Boucle infinie Un shell ne s'arrête jamais (sauf exit)
Lecture propre Pour pouvoir parser/exécuter après
Libération de mémoire Aucune fuite dès maintenant
Gestion de CTRL+D Car c'est standard sur Unix
🎯 Mini-plan d'action Partie 1
Boucle infinie (while (1)),

Lire la ligne de commande (avec readline),

Afficher la commande,

Libérer la mémoire,

Gérer CTRL+D (readline retourne NULL).

📋 TDD minimal Bloc 5 Partie 1 [🟠 Avancé]

Test Attendu
Tapez une commande normale S'affiche correctement
Appuyez sur CTRL+D Affiche "exit" et quitte
Spammez la mémoire Pas de fuite mémoire (valgrind ✅)

# Bloc 5 — Minishell++ Boosté — Partie 2/9 [🟠 Avancé]
📚 Objectif immédiat
Maintenant que tu sais lire une ligne,
➔ Tu vas analyser (parser) cette ligne,
➔ Découper correctement les mots (= commande + options).

Pas encore de pipes ni de redirections ici — juste du découpage propre.

📋 Ce que tu dois faire dans cette Partie

Étape Objectif
1 Splitter la ligne tapée en tokens/mots
2 Gérer correctement les espaces
3 Stocker les mots dans un tableau de chaînes
4 Préparer pour exécuter après
📚 Les fonctions utiles pour parser
📦 Avec ta fonction ft_split
Si tu as une fonction type ft_split() :

c
Copier
Modifier
```c
char **ft_split(char const *s, char c);
Alors tu peux découper la ligne tapée par l'utilisateur en mots en utilisant ' ' (espace) comme séparateur.

```
Exemple :

c
Copier
Modifier
```c
char **tokens = ft_split(input, ' ');
📋 Ce que tu obtiens
Pour une ligne :

```
bash
Copier
Modifier
ls -l /home/user
Après split, tu obtiens :

c
Copier
Modifier
tokens[0] = "ls"
tokens[1] = "-l"
tokens[2] = "/home/user"
tokens[3] = NULL
📋 Gestion spéciale des espaces multiples
Ton ft_split doit pouvoir :

Ignorer les espaces multiples consécutifs,

Ne pas créer de token vide.

📋 Petit exemple pour vérifier
c
Copier
Modifier
```c
// ligne lue
input = " ls -la /etc ";

```
c
// après split
tokens[0] = "ls"
tokens[1] = "-la"
tokens[2] = "/etc"
tokens[3] = NULL
✅ Aucun token vide, même s'il y avait plein d'espaces au début ou entre les mots.

```
📋 Mini-code simplifié
c
Copier
Modifier
char **parse_line(char *input)
{
```c
 return (ft_split(input, ' '));
}
📚 Mini-pièges à éviter

```
Erreur possible Solution
Créer un token vide quand plusieurs espaces Corriger ton ft_split
Oublier de NULL-terminer ton tableau Toujours terminer par un NULL
Ne pas free l'ancien input avant de parser une nouvelle ligne Toujours nettoyer
📋 Exemple simplifié d'utilisation
c
Copier
Modifier
```c
char *input = readline("minishell$ ");
char **tokens = parse_line(input);

```
c
// Afficher tous les tokens
for (int i = 0; tokens[i]; i++)
 printf("token[%d] = %s\n", i, tokens[i]);

```
c
// Free tokens après utilisation !
free_tokens(tokens);
free(input);
(free_tokens() = fonction qui libère chaque string + le tableau.)

```
🎯 Mini plan d'action Partie 2
Lire la ligne de commande,

Splitter avec ft_split(' '),

Stocker dans char **tokens,

Vérifier et afficher chaque token,

Libérer tout correctement.

📋 TDD minimal Bloc 5 Partie 2 [🟠 Avancé]

Test Attendu
Ligne simple (ls -l) Tokens OK
Ligne vide (" ") Aucun token
Ligne avec plusieurs espaces Aucun token vide
Valgrind sur boucle infinie Zéro fuite mémoire

# Bloc 5 — Minishell++ Boosté — Partie 3/9 [🟠 Avancé]
📚 Objectif immédiat
Maintenant que :

Tu lis une ligne de commande,

Tu parses correctement en tokens,

➔ Il est temps d'exécuter vraiment la commande via un fork/execve.

📋 Ce que tu dois faire dans cette Partie

Étape Objectif
1 Forker ton shell pour exécuter la commande
2 Utiliser execve() pour lancer la commande
3 Gérer les erreurs si la commande est introuvable
4 Attendre la fin de l'exécution (waitpid)
📚 Les fonctions à utiliser
📦 Forker avec fork()
c
Copier
Modifier
pid_t pid = fork();
pid == 0 ➔ tu es dans l'enfant ➔ lance la commande,

pid > 0 ➔ tu es dans le parent ➔ attends que l'enfant finisse.

📦 Exécuter la commande avec execve()
Prototype :

c
Copier
Modifier
```c
int execve(const char *pathname, char *const argv[], char *const envp[]);
pathname: chemin absolu ou relatif vers la commande (/bin/ls par exemple),

```
argv: tableau de chaînes (tokens que tu as déjà),

envp: tableau des variables d'environnement (passé au main généralement).

📦 Attendre l'enfant avec waitpid()
c
Copier
Modifier
waitpid(pid, NULL, 0);
📋 Schéma global d'exécution
plaintext
Copier
Modifier
Parent Minishell
│
├── fork() -> Fils
│ ├── execve(path, tokens, envp)
│ └── (ne revient pas si succès)
│
└── Parent attend la fin du fils (waitpid)
📚 Trouver le chemin absolu (/bin/ls, etc.)
Dans un vrai shell, si l'utilisateur tape juste ls,
tu dois :

Chercher dans $PATH,

Tester chaque dossier jusqu'à trouver ls.

Exemple de PATH :

bash
Copier
Modifier
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
(Séparé par :)

📋 Mini plan rapide
Récupérer PATH dans envp,

Split PATH avec :,

Pour chaque dossier :

Joindre / + cmd,

Tester avec access(path, X_OK),

Si trouvé, utiliser execve(path, tokens, envp).

📋 Exemple de code simplifié
c
Copier
Modifier
pid_t pid = fork();
if (pid == 0)
{
```c
 char *path = find_path(tokens[0], envp); // fonction à écrire
 if (!path)
 {
 printf("Command not found: %s\n", tokens[0]);
 exit(1);
 }
 execve(path, tokens, envp);
 perror("execve"); // Ne devrait jamais arriver si execve réussi
 exit(1);
}
else if (pid > 0)
{
 waitpid(pid, NULL, 0);
}
else
{
 perror("fork");
}
📚 Gestion des erreurs

```
Cas Action
Commande introuvable Message d'erreur
execve échoue Message d'erreur
Fork échoue Message d'erreur et exit
📚 Bonus: petite fonction find_path
c
Copier
Modifier
char *find_path(char *cmd, char **envp)
{
```c
 // À coder: récupérer PATH dans envp, split, tester chaque chemin avec access()
}
(Je peux te la détailler si tu veux après.)

```
🎯 Mini plan d'action Partie 3
Forker,

Dans l'enfant: chercher chemin + execve,

Dans le parent: attendre,

Gestion correcte des erreurs.

📋 TDD minimal Bloc 5 Partie 3 [🟠 Avancé]

Test Attendu
ls -l fonctionne ✅
Commande invalide (fakecmd) Affiche "command not found"
Plus de 10 exécutions Pas de fuite mémoire

# Bloc 5 — Minishell++ Boosté — Partie 4/9 [🟠 Avancé]
📚 Objectif immédiat
Maintenant que tu sais :

Lire une commande,

Parser les mots,

Forker et exécuter un programme,

Tu vas apprendre à gérer les pipes (|) :
➔ connecter deux (ou plusieurs) commandes ensemble, comme dans un vrai shell.

📋 Ce que tu vas faire dans cette Partie

Étape Objectif
1 Détecter les pipes dans la ligne de commande
2 Couper la commande en segments entre les `
3 Créer un pipe() pour chaque liaison
4 Forker pour chaque commande séparée
5 Rediriger les entrées/sorties avec dup2()
6 Lancer chaque commande avec execve()
📚 Schéma d'exemple
Pour :

bash
Copier
Modifier
ls -l | grep .c | wc -l
Ton minishell doit créer :

plaintext
Copier
Modifier
[Processus 1] ls -l → écrit dans pipe1 → 
[Processus 2] grep .c → écrit dans pipe2 →
[Processus 3] wc -l → écrit dans stdout
📋 Comment fonctionnent les pipes
Chaque pipe() te donne deux fd :

pipefd[0] ➔ lecture,

pipefd[1] ➔ écriture.

Tu dois :

Relier stdout du processus actuel à pipefd[1],

Relier stdin du prochain processus à pipefd[0].

📚 Plan d'implémentation
📦 Étape 1: Parser sur les |
Quand tu lis la commande complète, tu dois split en commandes séparées par |.

Exemple :

c
Copier
Modifier
```c
// Ligne: "ls -l | grep .c | wc -l"
commands[0] = "ls -l"
commands[1] = "grep .c"
commands[2] = "wc -l"
commands[3] = NULL
(On peut faire un ft_split_pipe personnalisé si besoin.)

```
📦 Étape 2: Créer une boucle sur les commandes
Tu crées une boucle pour :

Créer un pipe,

Forker,

Rediriger correctement.

📦 Étape 3: Dans chaque processus

Si c'est... Tu fais...
Premier processus Lire depuis stdin normal, écrire dans pipe
Processus du milieu Lire depuis le pipe précédent, écrire dans un nouveau pipe
Dernier processus Lire depuis le pipe précédent, écrire vers stdout
📋 Code conceptuel ultra simplifié
c
Copier
Modifier
```c
int pipefd[2];
int prev_fd = 0; // au début stdin

```
for (chaque commande)
{
 pipe(pipefd);
 pid = fork();
 if (pid == 0)
 {
 dup2(prev_fd, 0); // lire depuis prev_fd
 if (il y a une autre commande après)
 dup2(pipefd[1], 1); // écrire dans le pipe actuel
 close(pipefd[0]);
 close(pipefd[1]);
 execve(cmd);
 }
 else
 {
 close(pipefd[1]); // ne plus écrire ici
 prev_fd = pipefd[0]; // pour la prochaine commande
 }
}
waitpid pour tous les enfants
📚 Résumé super clair
plaintext
Copier
Modifier
[stdin] -> [cmd1] -> (pipe) -> [cmd2] -> (pipe) -> [cmd3] -> [stdout]
Chaque pipe connecte deux commandes.

📋 Détails critiques

Astuce Pourquoi
Toujours fermer ce que tu n'utilises pas Sinon bloqué
Gérer correctement tous les dup2() Sinon la commande ne lit/écrit pas au bon endroit
Libérer toutes les mémoires inutilisées Pas de fuite
🎯 Mini plan d'action Partie 4
Split sur | pour récupérer chaque commande,

Pour chaque commande :

Créer un pipe,

Forker,

Rediriger fd avec dup2,

Exécuter commande,

Fermer les pipes inutiles,

Parent attend tous les enfants.

📋 TDD minimal Bloc 5 Partie 4 [🟠 Avancé]

Test Attendu
`ls wc -l`
`cat file grep hello`
`ls grep .c
Commande fausse au milieu Shell continue correctement

# Bloc 5 — Minishell++ Boosté — Partie 5/9 [🟠 Avancé]
📚 Objectif immédiat
Maintenant que :

Tu sais lire, parser, exécuter une commande,

Tu sais gérer plusieurs commandes avec des pipes,

Tu vas apprendre à gérer les redirections :

> (écriture dans un fichier),

>> (écriture en ajout à un fichier),

< (lecture d'un fichier).

📋 Ce que tu vas faire dans cette Partie

Étape Objectif
1 Détecter les opérateurs de redirection
2 Ouvrir correctement les fichiers
3 Rediriger l'entrée ou la sortie avec dup2()
4 Nettoyer correctement
📚 Les types de redirection
1. Sortie standard vers fichier (>)
Exemple :

bash
Copier
Modifier
echo hello > file.txt
Ouvre file.txt en écriture (O_WRONLY | O_CREAT | O_TRUNC),

Remplace stdout (fd 1) par le fd du fichier.

2. Sortie standard vers fichier en ajout (>>)
Exemple :

bash
Copier
Modifier
echo hello >> file.txt
Ouvre file.txt en écriture (O_WRONLY | O_CREAT | O_APPEND),

Remplace stdout (fd 1) par le fd du fichier.

3. Entrée standard depuis un fichier (<)
Exemple :

bash
Copier
Modifier
cat < file.txt
Ouvre file.txt en lecture (O_RDONLY),

Remplace stdin (fd 0) par le fd du fichier.

📚 Le cycle de redirection général

Étape Action
Lire la commande et détecter les redirections 
Ouvrir le fichier correspondant 
dup2(fd_fichier, 0) ou dup2(fd_fichier, 1) 
Fermer l'ancien fd_fichier 
Exécuter normalement la commande (execve) 
📋 Exemple de logique pour gérer > :
c
Copier
Modifier
```c
int fd = open("file.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
if (fd < 0)
{
 perror("open");
 exit(1);
}
dup2(fd, 1);
close(fd);
execve(...);
📚 Parsing spécial pour détecter redirections
Ton parseur doit :

```
Repérer > ou >> ou <,

Savoir quel mot est la commande, quel mot est un fichier,

Nettoyer la liste des arguments avant execve (en retirant les >, >>, < et le fichier associé).

📋 Exemples concrets de parsing :
1. Simple redirection
Entrée utilisateur :

bash
Copier
Modifier
echo hello > file.txt
Parser résultat :

plaintext
Copier
Modifier
commande: echo
arguments: hello
redirection: > file.txt
2. Double redirection
Entrée utilisateur :

bash
Copier
Modifier
cat < input.txt > output.txt
Parser résultat :

plaintext
Copier
Modifier
commande: cat
redirection 1: < input.txt
redirection 2: > output.txt
📋 Points techniques essentiels

Piège Solution
Oublier de fermer le fd du fichier ouvert Toujours close après dup2
Tenter d'exécuter les arguments > file Nettoyer la liste avant execve
Ne pas traiter les >> différemment de > Toujours tester > ET >>
🎯 Mini plan d'action Partie 5
Modifier le parseur pour détecter < > >>,

Ouvrir correctement le ou les fichiers,

Rediriger avec dup2(),

Nettoyer les arguments envoyés à execve,

Exécuter normalement la commande.

📋 TDD minimal Bloc 5 Partie 5 [🟠 Avancé]

Test Attendu
echo hello > file.txt file.txt contient "hello"
cat < file.txt Lit file.txt
echo hello >> file.txt Ajoute "hello" à la fin
Redirection impossible (dossier en écriture) Erreur propre
Pas de fuite mémoire OK Valgrind

# Bloc 5 — Minishell++ Boosté — Partie 6/9 [🟠 Avancé]
📚 Objectif immédiat
Maintenant que :

Tu sais lire, parser, exécuter,

Tu gères les pipes et redirections,

Tu vas ajouter les built-ins ➔ les commandes que ton shell exécute lui-même, sans passer par execve.

📋 Ce que tu dois faire dans cette Partie

Étape Objectif
1 Détecter si la commande est un built-in
2 Exécuter directement le code du built-in
3 Ne pas forker inutilement pour certains built-ins (cd, exit)
4 Gérer correctement l'environnement (export, unset, etc.)
📚 La liste officielle des built-ins à implémenter
📦 echo
Répéter ce qui suit,

Gérer -n (pas de saut de ligne final).

Exemple :

bash
Copier
Modifier
echo hello world
echo -n hello
📦 cd
Changer de répertoire courant.

Modifier $PWD et $OLDPWD.

Exemple :

bash
Copier
Modifier
cd /home/user
📦 pwd
Afficher le chemin absolu actuel.

Exemple :

bash
Copier
Modifier
pwd
📦 export
Ajouter ou modifier une variable d'environnement.

Exemple :

bash
Copier
Modifier
export VAR=value
📦 unset
Supprimer une variable d'environnement.

Exemple :

bash
Copier
Modifier
unset VAR
📦 env
Afficher toutes les variables d'environnement existantes.

Exemple :

bash
Copier
Modifier
env
📦 exit
Fermer minishell proprement.

Exemple :

bash
Copier
Modifier
exit
exit 42
📚 Mini-stratégie pour gérer les built-ins
📋 1. Avant de forker: tester si la commande est un built-in
Si oui ➔ appeler la fonction correspondante directement.

Si non ➔ forker et utiliser execve.

📋 2. Implémenter une fonction is_builtin()
Exemple :

c
Copier
Modifier
int is_builtin(char *cmd)
{
```c
 if (!strcmp(cmd, "echo")) return (1);
 if (!strcmp(cmd, "cd")) return (1);
 if (!strcmp(cmd, "pwd")) return (1);
 if (!strcmp(cmd, "export")) return (1);
 if (!strcmp(cmd, "unset")) return (1);
 if (!strcmp(cmd, "env")) return (1);
 if (!strcmp(cmd, "exit")) return (1);
 return (0);
}
📋 3. Dispatcher les commandes
Dans ton exécution principale :

```
c
Copier
Modifier
if (is_builtin(tokens[0]))
 exec_builtin(tokens, envp);
else
{
 pid = fork();
 if (pid == 0)
 execve(...);
 else
 waitpid(pid, NULL, 0);
}
📚 Détails particuliers

Built-in Attention spéciale
cd Modifier $PWD en interne
exit Quitter immédiatement minishell (pas après fork)
export / unset Modifier directement ton tableau d'environnement
📋 Exemple de dispatcher de built-ins
c
Copier
Modifier
void exec_builtin(char **tokens, char ***envp)
{
 if (!strcmp(tokens[0], "echo"))
 ft_echo(tokens + 1);
 else if (!strcmp(tokens[0], "cd"))
 ft_cd(tokens[1], envp);
 else if (!strcmp(tokens[0], "pwd"))
 ft_pwd();
 else if (!strcmp(tokens[0], "export"))
 ft_export(tokens + 1, envp);
 else if (!strcmp(tokens[0], "unset"))
 ft_unset(tokens + 1, envp);
 else if (!strcmp(tokens[0], "env"))
 ft_env(*envp);
 else if (!strcmp(tokens[0], "exit"))
 ft_exit(tokens);
}
📚 Structure recommandée
plaintext
Copier
Modifier
src/
├── builtins/
│ ├── echo.c
│ ├── cd.c
│ ├── pwd.c
│ ├── export.c
│ ├── unset.c
│ ├── env.c
│ ├── exit.c
📚 Mini-astuces pour réussir

Astuce Pourquoi
Ne pas forker pour exit, cd, export, unset Sinon tu modifies un fils inutilement
Penser à errno pour les erreurs cohérent avec UNIX
Penser à libérer la mémoire de l'environnement si modifié éviter fuite mémoire
🎯 Mini plan d'action Partie 6
Détecter les built-ins avec is_builtin(),

Appeler la fonction appropriée directement,

Implémenter echo, pwd, env (simples),

Implémenter cd, export, unset, exit (plus costauds).

📋 TDD minimal Bloc 5 Partie 6 [🟠 Avancé]

Test Attendu
echo hello Affiche hello
cd /tmp + pwd Affiche /tmp
export VAR=hello + echo $VAR Affiche hello
unset VAR + echo $VAR Rien
exit Quitte correctement

# Bloc 5 — Minishell++ Boosté — Partie 7/9 [🟠 Avancé]
📚 Objectif immédiat
Maintenant que :

Tu sais exécuter des commandes,

Tu sais gérer les built-ins,

➔ Il est temps de bien gérer l'environnement (envp) :

Lire,

Modifier (export, unset),

Remplacer les variables $VAR dans les commandes.

📋 Ce que tu dois faire dans cette Partie

Étape Objectif
1 Stocker proprement les variables d'environnement (envp)
2 Gérer export (ajouter / modifier une variable)
3 Gérer unset (supprimer une variable)
4 Remplacer $VAR dans les lignes de commande avant exécution
5 Afficher env correctement
📚 Comment stocker l'environnement
Au démarrage de ton minishell :

Copie le char **envp que reçoit ton main,

Stocke-le dans ta propre structure,

Travaille toujours dessus ensuite.

📋 Exemple simple :
c
Copier
Modifier
char **copy_envp(char **envp)
{
```c
 int i = 0;
 char **new_env;
 
```
 while (envp[i])
 i++;
```c
 new_env = malloc(sizeof(char *) * (i + 1));
 i = 0;
 while (envp[i])
 {
 new_env[i] = strdup(envp[i]);
 i++;
 }
 new_env[i] = NULL;
 return (new_env);
}
📚 Gérer export
📋 Quand tu tapes :
bash
Copier
Modifier
export VAR=42
Tu dois :

```
Chercher si VAR existe déjà dans envp,

Si oui ➔ remplacer sa valeur,

Si non ➔ ajouter VAR=42 à la fin de ton tableau.

📚 Gérer unset
📋 Quand tu tapes :
bash
Copier
Modifier
unset VAR
Tu dois :

Supprimer l'entrée VAR=xxx de ton tableau envp,

Décaler tous les éléments suivants,

Ajuster la taille de envp.

📚 Remplacer $VAR dans les commandes
📋 Quand tu tapes :
bash
Copier
Modifier
echo $HOME
Tu dois :

Chercher $HOME dans ton tableau envp,

Remplacer $HOME par sa valeur réelle (/home/tonuser).

📋 Mini méthode de substitution
c
Copier
Modifier
char *get_env_value(char *var, char **envp)
{
```c
 int i = 0;
 int len = strlen(var);

```
 while (envp[i])
 {
 if (!strncmp(envp[i], var, len) && envp[i][len] == '=')
```c
 return (envp[i] + len + 1);
 i++;
 }
 return (NULL);
}
(Ensuite tu replaces $VAR par sa valeur dans la commande.)

```
📚 Gestion spéciale de cas

Cas Que faire
$? Remplacer par le code retour de la dernière commande
Variable inconnue ($XYZ) Remplacer par vide
Double dollar $$ Pas obligatoire dans ton mini-projet (sauf bonus)
📋 Détails critiques

Piège Solution
Modifier directement envp passé à main Toujours copier
Ne pas gérer le NULL final du tableau Toujours avoir envp[i] = NULL
Libérer l'ancien tableau lors d'un export/unset Refaire proprement
🎯 Mini plan d'action Partie 7
Copier envp dans ta propre structure,

Gérer export et unset,

Substituer $VAR avant exécution,

Tester tout avec Valgrind ✅.

📋 TDD minimal Bloc 5 Partie 7 [🟠 Avancé]

Test Attendu
export VAR=hello puis echo $VAR Affiche hello
unset VAR puis echo $VAR Affiche vide
env Affiche toutes les variables
Redéfinir une variable Remplace la bonne valeur
Valgrind 0 fuite mémoire sur 10 000 variables

# Bloc 5 — Minishell++ Boosté — Partie 8/9 [🟠 Avancé]
📚 Objectif immédiat
Maintenant que :

Ton shell sait exécuter, parser, rediriger, gérer l'environnement,

➔ Il est temps de gérer proprement les signaux système :

CTRL+C pour interrompre proprement,

CTRL+D pour quitter proprement (EOF),

(Éventuellement plus tard: SIGQUIT, SIGTERM, etc.)

📋 Ce que tu dois faire dans cette Partie

Étape Objectif
1 Intercepter SIGINT (CTRL+C) pour ne pas quitter brutalement
2 Gérer EOF (CTRL+D) proprement (afficher exit et fermer)
3 S'assurer que les signaux se comportent comme dans Bash
4 Protéger les processus enfants des mauvais signaux
📚 Les signaux à intercepter
📦 SIGINT (CTRL+C)
Quand l'utilisateur tape CTRL+C pendant que minishell attend une commande,
➔ Ne pas quitter minishell.

Juste :

Afficher une nouvelle ligne propre,

Réafficher le prompt (minishell$).

📦 EOF (CTRL+D)
Quand l'utilisateur tape CTRL+D (fin de fichier), ➔ minishell doit :

Quitter proprement,

Afficher exit avant de quitter.

📚 Fonctions utiles
📋 signal()
Te permet de capturer un signal et d'appeler une fonction personnalisée.

c
Copier
Modifier
```c
# include <signal.h>

```
void handler(int signum)
{
 if (signum == SIGINT)
 {
 write(1, "\nminishell$ ", 12);
 }
}

int main(void)
{
 signal(SIGINT, handler);
```c
 // ...
}
📋 readline() et signaux
Attention si tu utilises readline() :

```
readline intercepte automatiquement CTRL+C et CTRL+D !

Il te faudra appeler rl_replace_line("", 0) et rl_on_new_line() après un signal pour être propre.

📋 Exemple avec readline
c
Copier
Modifier
```c
# include <readline/readline.h>
# include <readline/history.h>

```
void handler(int signum)
{
 if (signum == SIGINT)
 {
 write(1, "\n", 1);
 rl_replace_line("", 0);
 rl_on_new_line();
 rl_redisplay();
 }
}

int main(void)
{
 signal(SIGINT, handler);
```c
 // minishell loop
}
📋 Comment détecter CTRL+D ?
Quand tu utilises readline, tu peux savoir si l'utilisateur tape CTRL+D car :

```
c
Copier
Modifier
input = readline("minishell$ ");
if (!input) // si NULL
{
```c
 printf("exit\n");
 break; // quitter proprement
}
📚 Protection spéciale des enfants (bonus)
Pendant qu'un fils (fork) exécute une commande :

```
Tu peux choisir d'ignorer certains signaux temporairement,

Ou de leur laisser le comportement par défaut.

Exemple :

c
Copier
Modifier
signal(SIGINT, SIG_DFL); // Dans fils: comportement normal
📋 Points critiques à bien respecter

Piège Solution
Quitter minishell sur un CTRL+C Jamais, juste afficher le prompt à nouveau
Ne pas afficher exit sur CTRL+C Uniquement sur CTRL+D
Ignorer SIGQUIT (CTRL+\) si demandé Possible en bonus
🎯 Mini plan d'action Partie 8
Capturer SIGINT (CTRL+C) et juste réafficher prompt,

Détecter CTRL+D (NULL sur readline) et quitter avec exit,

Gérer signaux dans fils correctement (si bonus).

📋 TDD minimal Bloc 5 Partie 8 [🟠 Avancé]

Test Attendu
CTRL+C pendant prompt Affiche une nouvelle ligne et re-prompt
CTRL+D pendant prompt Affiche exit et quitte
CTRL+C pendant exécution de sleep 5 Interrompt sleep mais minishell continue

# Bloc 5 — Minishell++ Boosté — Partie 9/9 [🟠 Avancé]
📚 Objectif immédiat
Maintenant que :

Ton shell sait lire, parser, exécuter, gérer l'environnement, les pipes, les redirections et les signaux,

➔ Il est temps de tout tester, nettoyer, et polir ton minishell pour en faire un projet solide et livrable !

📋 Ce que tu dois faire dans cette Phase Finale

Étape Objectif
1 Test intensif toutes fonctionnalités
2 Nettoyer le code (pas d'interdits norme 42)
3 Faire un Makefile propre
4 Bonus possibles si tu veux aller encore plus loin
📚 Checklist ultra-complète de tests 📋
📋 Fonctionnalités obligatoires à tester

Test Résultat attendu
Exécuter commande simple ls Fonctionne
Exécuter avec arguments ls -la Fonctionne
Commande inexistante Affiche erreur
Pipeline simple `ls wc -l`
Pipeline multiple `cat file grep hello
Redirection de sortie echo hello > file.txt Fonctionne
Redirection d'entrée cat < file.txt Fonctionne
Append echo world >> file.txt Fonctionne
Built-in cd changement de dossier Fonctionne
Built-in pwd retourne chemin correct Fonctionne
Built-in export, unset, env Fonctionnent
Substitution $VAR dans echo Fonctionne
CTRL+C dans prompt Réaffiche le prompt
CTRL+D dans prompt Quitte avec "exit"
Exécution massive (10000 commandes) Pas de fuite mémoire (Valgrind ✅)
📋 Nettoyage du code

Règle À vérifier
Norme 42 respectée (fonctions courtes, pas de malloc sauvage, indentation) ✅
Pas de warnings compilation (-Wall -Wextra -Werror) ✅
Libération de toute mémoire avant exit ✅
Makefile complet ✅
Pas de fichiers .DS_Store, .vscode, etc. dans ton dépôt ✅
📋 Structure finale de ton projet Minishell++
plaintext
Copier
Modifier
minishell/
├── src/
│ ├── main.c
│ ├── parser.c
│ ├── executor.c
│ ├── builtins/
│ │ ├── echo.c
│ │ ├── cd.c
│ │ ├── pwd.c
│ │ ├── export.c
│ │ ├── unset.c
│ │ ├── env.c
│ │ ├── exit.c
│ ├── redirections.c
│ ├── pipes.c
│ ├── signals.c
│ ├── env_utils.c
│ ├── utils.c
├── include/
│ ├── minishell.h
├── tests/
│ ├── heavy_tests.sh
├── Makefile
📚 Makefile final attendu

Target Action
all Compile minishell
clean Supprime les .o
fclean Supprime les .o et minishell
re clean + all
bonus (si tu as bonus, bonus compilation)
🎯 Mini plan d'action Partie 9
Passer tous les tests intensifs,

Nettoyer tout le code (norminette + valgrind clean),

Avoir un Makefile béton,

(Optionnel) Ajouter bonus si envie !

📚 Bonus possibles ⭐

Bonus Détail
>> dans les pipes intermédiaires Plus complexe mais faisable
Gestion Here-Doc (<<) Rediriger entrée avec input dynamique
Gestion avancée des signaux enfants Propagation fine des SIGINT/SIGQUIT
Support des variables d'environnement locales $?, etc.
Support du wildcard * (ls *.c) Avancé mais faisable

# Bloc 6 — Malloc++ Boosté
📚 Objectif général
Recréer le fonctionnement de base de :

malloc() ➔ Allouer dynamiquement de la mémoire,

free() ➔ Libérer proprement la mémoire,

(Optionnel) realloc() ➔ Redimensionner une zone mémoire.

➔ Le tout sans utiliser malloc de la libc !

📋 Ce que tu vas construire concrètement

Fonction Description
```c
void *malloc(size_t size); Allouer un bloc mémoire de taille size
void free(void *ptr); Libérer un bloc mémoire précédemment alloué
(optionnel) void *realloc(void *ptr, size_t size); Réallouer une mémoire à une autre taille
📚 Connaissances que tu vas renforcer ici

```
Compétence Importance
Gestion des pointeurs avancée ✅
Gestion de la mémoire système ✅
Compréhension du heap (tas mémoire) ✅
Utilisation de brk() et sbrk() ✅
Architecture de la mémoire d'un programme ✅
Organisation propre d'un mini-projet système ✅
📦 Architecture mémoire minimale que tu vas gérer
Chaque bloc alloué doit contenir :

Un header (données internes, taille, libre ou pas),

La zone utilisateur (la vraie mémoire allouée).

📚 Exemple d'un header minimal
c
Copier
Modifier
typedef struct s_block
{
```c
 size_t size;
 int free;
 struct s_block *next;
} t_block;
size: taille du bloc,

```
free: 0 ou 1 (occupé ou libre),

next: pointeur vers le bloc suivant.

📚 Fonctionnement basique de ton malloc

Étape Action
1 Chercher un bloc libre assez grand dans ta liste
2 Si trouvé ➔ réutiliser ce bloc
3 Si pas trouvé ➔ demander plus de mémoire au système avec sbrk()
4 Retourner un pointeur sur la zone utilisateur (après le header)
📋 sbrk() rapide explication
sbrk(0) ➔ Retourne la fin actuelle du heap.

sbrk(size) ➔ Agrandit le heap de size octets.

Attention: pas autorisé dans tous les systèmes modernes ➔ mais pour projet éducatif, parfait.

📋 Fonction signature de ton malloc++
c
Copier
Modifier
```c
void *malloc(size_t size);
Alloue dynamiquement size octets,

```
Retourne un pointeur utilisable par l'utilisateur.

📚 Schéma mémoire après quelques malloc
plaintext
Copier
Modifier
[block1_header][block1_data][block2_header][block2_data][block3_header][block3_data]...
Chaque block est lié au suivant avec un pointeur next.

📚 Pourquoi ce projet est excellent ?

Raison Impact
Approfondir la gestion bas niveau ✅
Savoir comment marche malloc/realloc/free vraiment ✅
Comprendre fragmentation, compactage mémoire ✅
Apprendre organisation et rigueur ✅
📋 Démarrage rapide pour Bloc 6
Fichier principal malloc.c
Chercher un bloc libre,

Si non ➔ appeler sbrk pour agrandir le heap,

Créer un nouveau t_block,

Retourner l'adresse après le header.

Fichier free.c
Marquer le bloc comme libre (block->free = 1),

(En bonus) Fusionner blocs libres voisins.

Fichier malloc.h
Définir :

c
Copier
Modifier
typedef struct s_block t_block;
```c
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);
🎯 Mini plan d'action Bloc 6
Définir la structure t_block,

```
Écrire malloc() simple,

Écrire free() simple,

Gérer proprement la liste des blocs,

Option bonus: écrire realloc().

📋 TDD minimal pour Malloc++

Test Attendu
malloc(10) Retourne un pointeur utilisable
malloc(0) Comportement défini
malloc puis free Pas de fuite mémoire
malloc(1000) puis free Pas d'erreur
Allocation massive Pas de crash

# Bloc 6 — Partie 1/?? — Définir les structures & la base du système
📚 Objectif immédiat
Mettre en place :

✅ La structure de données qui décrit chaque bloc de mémoire,

✅ Les fonctions de base (init, premier malloc),

✅ Un pointeur global qui représente la tête de ton heap simulé.

🧱 Structure de base: t_block
C'est la brique principale de tout ton système mémoire.

c
Copier
Modifier
typedef struct s_block
{
```c
 size_t size; // Taille du bloc mémoire utilisateur
 int free; // 1 si libre, 0 si utilisé
 struct s_block *next; // Pointeur vers le bloc suivant
} t_block;
🎯 Ta "heap" personnalisée
Ton heap est simplement une liste chaînée de t_block.

```
Le premier élément est un pointeur global :

c
Copier
Modifier
t_block *g_base = NULL;
📁 Fichiers à créer maintenant

Fichier Rôle
malloc.c Contiendra ton malloc()
free.c Contiendra ton free()
malloc.h Toutes les structures + prototypes
(+ debug_utils.c si tu veux afficher les blocs) 
📋 Étapes dans malloc()
c
Copier
Modifier
void *malloc(size_t size)
{
 t_block *block;

 if (size <= 0)
```c
 return NULL;

```
 if (!g_base)
 {
```c
 // Première allocation: créer le premier bloc avec sbrk
 block = sbrk(sizeof(t_block) + size);
 if (block == (void*) -1)
 return NULL;
 block->size = size;
 block->free = 0;
 block->next = NULL;
 g_base = block;
 return (void*)(block + 1);
 }

```
c
 // À compléter dans les parties suivantes: chercher bloc libre, etc.
}
🧪 Que fait (void*)(block + 1) ?
Ça retourne: ➔ l'adresse juste après ton t_block struct,
➔ donc l'adresse utile pour l'utilisateur.

```
📚 Schéma mémoire après premier malloc(16)
plaintext
Copier
Modifier
[g_base] -> [BLOCK HEADER][USER DATA (16 bytes)]
🛠️ malloc.h (à créer maintenant)
c
Copier
Modifier
# ifndef MALLOC_H
# define MALLOC_H

# include <unistd.h>
# include <stddef.h>

typedef struct s_block
{
```c
 size_t size;
 int free;
 struct s_block *next;
} t_block;

```
c
void *malloc(size_t size);
void free(void *ptr);

```
# endif
📋 Points importants à retenir

Point Détail
Tu construis ton propre heap avec sbrk() (ne jamais utiliser le malloc standard)
t_block est toujours en mémoire avant le pointeur que tu rends à l'utilisateur Très utile pour free() plus tard
Tu commences avec une seule allocation Recherche de bloc libre viendra ensuite
🎯 Mini plan d'action Partie 1
Définir t_block dans malloc.h,

Créer malloc.c avec un premier malloc() fonctionnel,

Utiliser sbrk() pour allouer un seul bloc,

Retourner (block + 1) à l'utilisateur,

Préparer g_base pour suivre la mémoire.

📋 TDD minimal pour cette étape

Test Attendu
ptr = malloc(32); ptr != NULL
*ptr = 42; Pas de crash
malloc(0); Retourne NULL
Afficher (void*)ptr - sizeof(t_block) Doit pointer sur g_base

# Bloc 6 — Partie 2/?? — Réutiliser les blocs libres
📚 Objectif de cette partie
Tu vas :

Réutiliser un bloc mémoire déjà libéré (éviter sbrk trop souvent),

Implémenter une fonction find_free_block() dans ta liste chaînée,

Ne demander plus de mémoire au système que quand c'est vraiment nécessaire.

📋 Étapes principales

Étape Action
1 Ajouter une fonction pour chercher un bloc libre assez grand
2 L'utiliser dans malloc()
3 Ajouter le bloc en fin de liste si rien n'est libre
4 Ne jamais oublier d'initialiser free = 0 en cas de réutilisation
📁 Fichier à modifier: malloc.c
🧱 Fonction à ajouter: find_free_block()
c
Copier
Modifier
t_block *find_free_block(t_block **last, size_t size)
{
 t_block *current = g_base;

 while (current)
 {
 if (current->free && current->size >= size)
```c
 return current;
 *last = current;
 current = current->next;
 }
 return NULL;
}
🧠 Comment elle fonctionne :
On parcourt la liste des blocs,

```
Si un bloc est free == 1 et que sa taille est suffisante ➔ on le prend,

Sinon, on garde le dernier bloc visité (dans *last) pour allouer un nouveau.

🔁 Mettre à jour ta fonction malloc()
Voici une version améliorée :

c
Copier
Modifier
```c
void *malloc(size_t size)
{
 t_block *block;
 t_block *last;

 if (size <= 0)
```c
 return NULL;

```
 if (!g_base)
 {
 block = sbrk(sizeof(t_block) + size);
 if (block == (void*) -1)
```c
 return NULL;
 block->size = size;
 block->free = 0;
 block->next = NULL;
 g_base = block;
 }
 else
 {
 block = find_free_block(&last, size);
 if (block)
 block->free = 0;
 else
 {
 block = sbrk(sizeof(t_block) + size);
 if (block == (void*) -1)
 return NULL;
 block->size = size;
 block->free = 0;
 block->next = NULL;
 last->next = block;
 }
 }
 return (void*)(block + 1);
}
```
💡 Résumé :
On réutilise si on peut,

```
Sinon, on agrandit le heap via sbrk.

📚 Bonus: état mémoire à imprimer (optionnel debug)
Tu peux afficher :

c
Copier
Modifier
[Block 1] size=32 free=0 
[Block 2] size=128 free=1 
[Block 3] size=64 free=0 
➡️ pour t'assurer que tes blocs sont bien reliés et gérés.

📋 Cas à tester maintenant

Code Comportement
p1 = malloc(64); free(p1); p2 = malloc(64); p2 = p1 (réutilisation ✅)
p1 = malloc(64); p2 = malloc(32); free(p1); malloc(70); Ne réutilise pas p1 (pas assez grand)
📚 Tu viens d'implémenter :

Fonctionnalité Bénéfice
find_free_block() Réduction des appels à sbrk()
Recyclage mémoire + Pro propre et + performant
Ajout dynamique de bloc Liste chaînée extensible à l'infini

# Bloc 6 — Partie 3/?? — Implémenter free()
📚 Objectif immédiat
Maintenant que tu peux :

Allouer des blocs avec malloc(),

Réutiliser des blocs avec find_free_block(),

➔ Tu vas maintenant permettre à l'utilisateur de libérer un bloc avec free().

📋 Étapes à suivre

Étape Action
1 Récupérer le t_block à partir du void * fourni
2 Marquer le bloc comme free
3 Ne jamais oublier de vérifier que le pointeur est valide
4 (Option bonus plus tard) Fusionner les blocs adjacents libres
📚 Comment retrouver le bloc depuis ptr
Lorsque malloc() retourne :

c
Copier
Modifier
```c
return (void *)(block + 1);
Alors pour revenir en arrière, on fait :

```
c
Copier
Modifier
t_block *block = (t_block *)ptr - 1;
Cela te donne directement accès au header t_block du bloc correspondant.

📋 Implémentation de free() simple
Dans free.c :

c
Copier
Modifier
```c
# include "malloc.h"

```
void free(void *ptr)
{
 t_block *block;

 if (!ptr)
```c
 return;

```
 block = (t_block *)ptr - 1;
 block->free = 1;
}
🧠 Pourquoi cette implémentation fonctionne ?
On accède au header grâce au fait que malloc() renvoie (block + 1),

Le bloc est donc toujours juste avant le pointeur reçu,

Marquer free = 1 suffit à le rendre réutilisable par malloc() plus tard.

📚 À quoi faire attention

Piège Solution
ptr == NULL Ne rien faire
Libérer deux fois le même bloc À protéger en bonus
Libérer un pointeur invalide (pas d'un malloc à toi) Bonus: vérifier si le bloc est dans la liste gérée
🧪 Cas à tester

Code Ce qui doit se passer
p = malloc(64); free(p); block->free = 1
free(NULL); Ne plante pas
malloc(64); free(); malloc(64); Réutilise le même bloc
📋 Debug utile
Tu peux écrire une fonction (optionnelle) :

c
Copier
Modifier
void show_heap(void)
{
 t_block *current = g_base;
 while (current)
 {
```c
 printf("Block %p — size: %zu — free: %d\n", current, current->size, current->free);
 current = current->next;
 }
}
📚 Tu as maintenant :

```
Fonctionnalité Résultat
Allocation avec malloc() ✅
Réutilisation avec find_free_block() ✅
Libération avec free() ✅
Base solide pour ajouter fusion, realloc, debug avancé 🔜

# Bloc 6 — Partie 4/?? — Fusionner les blocs libres adjacents
📚 Objectif immédiat
Tu vas :

Détecter les blocs libres consécutifs dans ta liste,

Les fusionner en un seul grand bloc,

Éviter ainsi la fragmentation, qui gaspille de la mémoire inutilement.

❓ Pourquoi faire ça ?
Imaginons :

scss
Copier
Modifier
[Bloc 1] (free, 64 bytes) [🟢 Facile]
[Bloc 2] (free, 128 bytes) [🟢 Facile]
[Bloc 3] (used) [🟡 Intermédiaire]
Tu pourrais fusionner Bloc 1 + Bloc 2 en un seul  [🟢 Facile] [🟢 Facile]:

scss
Copier
Modifier
[Bloc fusionné] (free, 192 bytes)
Ce bloc fusionné pourra accueillir de plus grosses allocations.

📋 Étapes à suivre

Étape Action
1 Parcourir toute la liste de blocs mémoire
2 Dès que 2 blocs consécutifs sont libres → fusionner
3 Répéter jusqu'à ce qu'aucun bloc adjacent ne soit libre
📦 Fonction coalesce_free_blocks()
À appeler après chaque free() :

c
Copier
Modifier
void coalesce_free_blocks(void)
{
 t_block *current = g_base;

 while (current && current->next)
 {
 if (current->free && current->next->free)
 {
 current->size += sizeof(t_block) + current->next->size;
 current->next = current->next->next;
 }
 else
 current = current->next;
 }
}
📦 Mise à jour de free() :
c
Copier
Modifier
void free(void *ptr)
{
 t_block *block;

 if (!ptr)
```c
 return;

```
 block = (t_block *)ptr - 1;
 block->free = 1;
 coalesce_free_blocks();
}
📚 Illustration (avant/après)
Avant :

css
Copier
Modifier
[g_base] → [64 free] → [128 free] → [64 used]
Après :

css
Copier
Modifier
[g_base] → [192 free] → [64 used]
📋 Astuces pour éviter les erreurs

Erreur courante Solution
Oublier de mettre à jour next du bloc courant Toujours le réassigner après fusion
Bloquer sur une boucle infinie N'avancer current que si tu ne fusionnes pas
Tenter de fusionner avec un NULL Toujours vérifier current && current->next
🎯 Mini plan d'action Partie 4
Écrire coalesce_free_blocks(),

L'appeler à chaque free(),

Vérifier en debug visuel que ta heap se compacte,

Tester via allocations et libérations multiples.

🧪 Tests recommandés

Code Attendu
malloc A + B + C, puis free A et B A et B fusionnés
malloc A + B, free A, malloc C Si C < A, C réutilise A
malloc + free + free + malloc Aucune fuite mémoire, blocs réutilisés
✅ Tu viens d'ajouter à ton malloc :

Fonctionnalité Bénéfice
Fusion blocs libres Réduction fragmentation
Coalescence automatique Pas besoin de forcer
Heap plus intelligent Gère mieux les gros mallocs

# Bloc 6 — Partie 5 — Implémenter realloc()
📚 Objectif immédiat
Tu vas permettre à l'utilisateur de :

🔁 Modifier la taille d'un bloc mémoire déjà alloué,
sans perdre son contenu (dans la limite de la nouvelle taille bien sûr).

📋 Signature à respecter
c
Copier
Modifier
```c
void *realloc(void *ptr, size_t size);
🧠 Que fait realloc() exactement ?

```
Situation Comportement
ptr == NULL Même chose que malloc(size)
size == 0 et ptr != NULL Même chose que free(ptr)
Sinon Essaie de garder les données, mais change la taille
📦 Étapes classiques d'un realloc
Si ptr == NULL ➔ malloc(size)

Si size == 0 ➔ free(ptr) puis NULL

Sinon :

Cherche le bloc d'origine (ptr - 1)

Si size <= block->size → rien à faire, retourne le même ptr

Sinon :

Alloue un nouveau bloc avec malloc(size)

Copie les données (via memcpy)

Libère l'ancien

Retourne le nouveau

📋 Implémentation complète de realloc
c
Copier
Modifier
```c
# include "malloc.h"
# include <string.h>

```
void *realloc(void *ptr, size_t size)
{
 t_block *block;
```c
 void *new_ptr;

```
 if (!ptr)
```c
 return malloc(size);

```
 if (size == 0)
 {
 free(ptr);
```c
 return NULL;
 }

```
 block = (t_block *)ptr - 1;

 if (block->size >= size)
```c
 return ptr;

```
 new_ptr = malloc(size);
 if (!new_ptr)
```c
 return NULL;

```
 memcpy(new_ptr, ptr, block->size);
 free(ptr);
```c
 return new_ptr;
}
📋 Explication ligne par ligne

```
Bloc But
if (!ptr) Si realloc s'utilise comme un malloc
if (size == 0) Si realloc s'utilise comme un free
if (block->size >= size) Si la place est suffisante, ne rien faire
memcpy(new_ptr, ptr, block->size) Recopie les données
free(ptr) Libère l'ancien bloc après copie
📚 Avantages de realloc() bien fait

Point Pourquoi c'est utile
Évite de recopier inutilement si le bloc est assez grand ✅ performant
Garde les données intactes ✅ sécurité
Permet à un programme d'ajuster dynamiquement sa mémoire ✅ souplesse
🎯 Mini plan d'action Partie 5
Ajouter realloc() dans malloc.h,

Implémenter les 3 cas (NULL, 0, agrandissement),

Utiliser memcpy() pour la recopie,

Tester sur des tableaux, strings, buffers, etc.

📋 TDD minimal Bloc 6 Partie 5

Code Ce qui doit se passer
realloc(NULL, 42) Agit comme malloc(42)
realloc(ptr, 0) Agit comme free(ptr)
realloc(ptr, old_size) Retourne même bloc
realloc(ptr, bigger_size) Copie, libère, retourne nouveau

# Bloc 6 — Partie 6/6 — Tests, Debug, Valgrind, Makefile, Finalisation
📚 Objectif immédiat
Tu vas :

🧪 Tester toutes tes fonctions avec des cas réels et critiques,

🔍 Ajouter des outils de debug,

🧼 Valider l'absence de fuites mémoire avec Valgrind,

🧰 Rendre un projet propre, lisible, et maintenable.

✅ À ce stade, tu as :

Fonction Fait
malloc(size_t size) ✅
free(void *ptr) ✅
realloc(void *ptr, size_t size) ✅
Fusion de blocs (coalesce) ✅
Réutilisation mémoire ✅
Liste chaînée interne ✅
Allocation avec sbrk() uniquement ✅
🧪 Fichier de test minimal (test_malloc.c)
c
Copier
Modifier
```c
# include <stdio.h>
# include <string.h>
# include "malloc.h"

```
int main(void)
{
```c
 char *a = malloc(32);
 strcpy(a, "hello malloc!");
 printf("a = %s\n", a);

```
c
 char *b = malloc(16);
 char *c = malloc(64);
 free(b);

```
c
 char *d = malloc(16); // Devrait réutiliser l'ancien b
 char *e = realloc(a, 64);
 printf("e = %s\n", e);

```
 free(c);
 free(d);
 free(e);

```c
 return 0;
}
📋 Test à lancer avec Valgrind
bash
Copier
Modifier
valgrind --leak-check=full ./test_malloc
Attendu :

```
0 memory leak

0 error

Heap usage correct

🧰 Outil bonus: afficher la mémoire
Dans debug_utils.c :

c
Copier
Modifier
void show_heap(void)
{
 t_block *current = g_base;
 while (current)
 {
 printf("Block at %p | size: %zu | free: %d | next: %p\n",
```c
 (void *)current, current->size, current->free, (void *)current->next);
 current = current->next;
 }
}
Tu peux l'appeler entre deux tests pour visualiser tes blocs mémoire.

```
📦 Makefile minimal pour ton malloc++
makefile
Copier
Modifier
NAME = test_malloc

SRCS = malloc.c free.c realloc.c debug_utils.c test_malloc.c
OBJS = $(SRCS:.c=.o)
CC = gcc
CFLAGS = -Wall -Wextra -Werror

all: $(NAME)

$(NAME): $(OBJS)
 $(CC) $(CFLAGS) -o $@ $^

clean:
 rm -f $(OBJS)

fclean: clean
 rm -f $(NAME)

re: fclean all
📋 Structure finale recommandée
plaintext
Copier
Modifier
malloc++/
├── malloc.h
├── malloc.c
├── free.c
├── realloc.c
├── debug_utils.c
├── test_malloc.c
├── Makefile
📚 Pour aller plus loin (Bonus/Futur)

Option Description
Fusion automatique au malloc aussi Optimise encore +
Aligner les blocs (alignement mémoire) Architecture pro
Support multi-thread Gestion par mutex (avancé)
Ajout d'un garbage collector personnalisé Projet perso futur
✅ Tu viens de terminer ton propre gestionnaire mémoire complet en C.

Module Statut
Allocation dynamique (malloc) ✅
Libération (free) ✅
Réallocation (realloc) ✅
Coalescence mémoire ✅
Affichage & debug ✅
Makefile & test ✅




🧩 Module 2 — memory/allocators/ — Gestion mémoire avancée
📦 Module memory/allocators/ — Mini-Allocateur & Debug mémoire [💡 Niveau Avancé]
🎯 Objectif pédagogique
La mémoire est le cœur de tout programme en C. Ce module va t'apprendre à :

Débugger des fuites mémoire sans outils externes (sans Valgrind)

Écrire un mini-allocateur personnalisé (niveau expert)

Gérer toi-même le heap, les blocs libres, et l’alignement mémoire

Approcher la gestion de la mémoire comme dans les systèmes d’exploitation

📚 Concepts abordés
✅ 1. Détection manuelle de fuites mémoire
Allouer → libérer → vérifier

Système de log d’allocations

Utilisation de atexit() pour détecter les oublis

c
Copier
Modifier
// memory_log.c
#include <stdlib.h>
#include <stdio.h>

static int allocs = 0;

void *xmalloc(size_t size) {
    allocs++;
    return malloc(size);
}

void xfree(void *ptr) {
    allocs--;
    free(ptr);
}

void check_memory(void) {
    if (allocs != 0)
        printf("⚠️ %d allocations non libérées !\n", allocs);
    else
        printf("✅ Aucune fuite mémoire détectée.\n");
}

__attribute__((constructor)) void init(void) { atexit(check_memory); }
✅ 2. Mini-allocateur : simulation d’un malloc()
Zone mémoire statique

Gestion de blocs libres

Implémentation de malloc(), free(), realloc() simplifiés

c
Copier
Modifier
#define POOL_SIZE 4096
static char pool[POOL_SIZE];
static int used = 0;

void *simple_malloc(size_t size) {
    if (used + size > POOL_SIZE)
        return NULL;
    void *ptr = &pool[used];
    used += size;
    return ptr;
}
✅ 3. Alignement mémoire et "placement memory"
Simulation de placement new (style C++)

Alignement sur 8 ou 16 octets

uintptr_t pour manipulation bas niveau

c
Copier
Modifier
#include <stdint.h>

uintptr_t align(uintptr_t ptr, size_t align) {
    return (ptr + align - 1) & ~(align - 1);
}
🧪 Exercices
📂 memory/allocators/ex00 — Détecteur de fuites
Objectif : détecter et afficher le nombre d’allocations non libérées.

🧪 Tester avec :

c
Copier
Modifier
void *a = xmalloc(42);
void *b = xmalloc(10);
xfree(a);
// b oublié → une fuite détectée à la sortie
📂 memory/allocators/ex01 — Simuler malloc statique
Objectif : créer une fonction simple_malloc() dans une zone statique de 4096 octets.

🧠 Bonus : afficher le pourcentage utilisé de la mémoire.

📂 memory/allocators/ex02 — Fusion de blocs libres
🧠 Objectif : réutiliser les blocs libérés dans une zone simulée. Créer des metadata en tête de chaque bloc.

Structure de base :

c
Copier
Modifier
typedef struct s_block {
    size_t size;
    int    free;
    struct s_block *next;
} t_block;
🛠️ Extensions possibles (pour plus tard)
Implémenter un allocateur buddy system

Créer un calloc() custom

Utiliser sbrk() pour allouer dynamiquement (Unix-only, niveau OS)



🧩 Module 4 — signals/ — Signaux Unix, interruptions et gestion fine des processus [🚨 Niveau Avancé]
📦 Module signals/ — Maîtriser les signaux en C (UNIX) [🚨 Avancé]
🎯 Objectif pédagogique
Ce module va t’enseigner les bases vitales de la communication entre processus via les signaux, qui sont des interruptions logicielles :

Intercepter un CTRL+C (SIGINT)

Gérer les signaux personnalisés avec sigaction

Programmer des alarmes avec alarm()

Utiliser kill() pour envoyer un signal à un autre processus

Empêcher les crashs par SIGSEGV, SIGFPE, etc.

📚 Concepts abordés
✅ 1. signal() — Interception de signaux simples
c
Copier
Modifier
#include <signal.h>
#include <stdio.h>

void handler(int sig) {
    printf("Signal reçu : %d\n", sig);
}

int main() {
    signal(SIGINT, handler); // CTRL+C
    while (1); // Boucle infinie
}
⚠️ signal() est obsolète pour les projets sérieux. Préfère sigaction().

✅ 2. sigaction() — Méthode moderne et fiable
c
Copier
Modifier
#include <signal.h>

struct sigaction sa;
sa.sa_handler = handler;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;

sigaction(SIGTERM, &sa, NULL);
Avantages :

Plus de contrôle

Compatibilité POSIX

Masquage temporaire de signaux concurrents

✅ 3. alarm() et SIGALRM
c
Copier
Modifier
#include <unistd.h>

alarm(5); // Déclenche SIGALRM après 5 secondes
→ Pratique pour créer des timeouts.

✅ 4. kill() — Envoi de signaux
c
Copier
Modifier
kill(pid, SIGUSR1);
→ Permet de dialoguer entre processus, ou de stopper un service.

✅ 5. Signaux système courants
Signal  Description
SIGINT  Interruption (Ctrl+C)
SIGTERM Demande d'arrêt propre
SIGKILL Arrêt brutal (non capturable)
SIGSEGV Segmentation fault
SIGALRM Minuterie / alarm()
SIGCHLD Enfant terminé (wait)
SIGUSR1/2 Signaux utilisateur

🧪 Exercices
📂 signals/ex00 — Attraper SIGINT avec signal()
Crée une boucle infinie interrompue par Ctrl+C. Lors du signal, afficher Interruption reçue !.

📂 signals/ex01 — sigaction() propre
Utilise sigaction() pour intercepter SIGTERM, afficher un message, et quitter avec exit(0).

📂 signals/ex02 — Timeout avec alarm()
Créer une commande qui se termine automatiquement après 3 secondes si rien ne se passe.
💡 Bonus : pause() pour attendre un signal.

📂 signals/ex03 — Envoi de signaux entre processus
Créer deux programmes :

receiver.c qui affiche un message sur SIGUSR1

sender.c qui envoie ce signal à receiver via kill(pid, SIGUSR1)

🛠️ Bonus technique
sigprocmask() : bloquer certains signaux

sigpending(), sigismember() : gérer file d’attente

Réagir à SIGSEGV pour afficher une stack avant crash


🧩 Module 5 — file_syscalls/ — Appels système liés aux fichiers [🗃️ Niveau Moyen à Avancé]
📦 Module file_syscalls/ — Manipulation directe des fichiers via les appels système [🗃️ Moyen à Avancé]
🎯 Objectif pédagogique
Ce module te permet de comprendre et manipuler les fichiers à bas niveau comme le fait un OS ou un shell, sans passer par fopen ou la libc standard. Tu vas apprendre à :

Lire et écrire un fichier avec read() / write()

Ouvrir et fermer manuellement un fichier (open, close)

Repositionner le curseur avec lseek()

Analyser les métadonnées avec stat(), fstat()

Modifier les permissions avec chmod(), umask()

📚 Concepts abordés
✅ 1. open() et O_RDONLY / O_WRONLY / O_CREAT
c
Copier
Modifier
#include <fcntl.h>

int fd = open("data.txt", O_WRONLY | O_CREAT, 0644);
→ Retourne un descripteur de fichier, à manipuler comme un int.

✅ 2. read() et write()
c
Copier
Modifier
#include <unistd.h>

char buffer[128];
int r = read(fd, buffer, 128);
int w = write(fd, "Hello", 5);
⚠️ Bien vérifier le retour pour EOF ou erreur (-1).

✅ 3. close()
c
Copier
Modifier
close(fd);
→ Toujours fermer les fichiers pour éviter les fuites.

✅ 4. lseek() — Repositionner le curseur
c
Copier
Modifier
off_t pos = lseek(fd, 0, SEEK_END); // Aller à la fin
→ Sert à obtenir la taille du fichier, ou lire en arrière.

✅ 5. stat() et struct stat
c
Copier
Modifier
#include <sys/stat.h>

struct stat st;
stat("fichier.txt", &st);

printf("Taille : %ld octets\n", st.st_size);
printf("Type   : %d\n", st.st_mode & S_IFMT);
→ Obtenir toutes les infos système sur un fichier : taille, permissions, type…

✅ 6. chmod() et umask()
c
Copier
Modifier
chmod("file.txt", 0640);   // Modifie les droits
mode_t old = umask(0022);  // Définit le masque de création
→ Permet de gérer les droits d’accès UNIX (lecture, écriture, exécution)

🧪 Exercices
📂 file_syscalls/ex00 — Écrire dans un fichier
Créer un programme qui ouvre un fichier log.txt (ou le crée), y écrit "Hello World\n", puis le referme.

📂 file_syscalls/ex01 — Lire un fichier caractère par caractère
Lire un fichier texte et afficher chaque caractère en hexadécimal (utile pour fichiers binaires).

📂 file_syscalls/ex02 — Lire un fichier depuis la fin
Utiliser lseek() pour lire un fichier à l’envers (afficher le dernier octet, puis l’avant-dernier, etc.).

📂 file_syscalls/ex03 — stat() complet
Afficher :

la taille du fichier

le type (fichier, dossier, lien)

les permissions (S_IRUSR, S_IWUSR, etc.)

la date de dernière modification

📂 file_syscalls/ex04 — Créer un fichier avec permissions personnalisées
Créer un fichier en lecture/écriture uniquement pour l’utilisateur, puis changer ses permissions avec chmod().

🛠️ Bonus avancé
Lire un fichier binaire et l’afficher octet par octet

Créer un clone simplifié de la commande ls -l

Lire depuis /dev/random ou /proc/ (systèmes Linux only)




🧩 Module 10 — types/ — Types personnalisés, unions, énumérations, champs de bits [🧬 Niveau Moyen à Avancé]
📦 Module types/ — Renforcer sa maîtrise des types C avancés [🧬 Structuration & Contrôle Fin]
🎯 Objectif pédagogique
Ce module est dédié à l’expressivité du langage C via les types. Il t’enseigne à :

Définir des types personnalisés (typedef)

Utiliser les énumérations (enum) pour des états clairs

Gérer des données variables avec les unions

Utiliser des bitfields pour encoder efficacement des flags

Comprendre les modificateurs const, volatile, restrict et leur impact

📚 Concepts abordés
✅ 1. typedef : donner un nom à un type
c
Copier
Modifier
typedef struct s_point {
    int x, y;
} t_point;
→ Rend le code plus lisible et modulaire.

✅ 2. enum : listes de constantes
c
Copier
Modifier
typedef enum {
    STATE_IDLE,
    STATE_RUNNING,
    STATE_PAUSED
} t_state;
→ Remplace les #define par des valeurs symboliques liées à un type.

✅ 3. union : mémoire partagée entre champs
c
Copier
Modifier
union u_data {
    int i;
    float f;
    char *str;
};
→ Tous les membres partagent la même zone mémoire → utile pour des données variables.

✅ 4. Bitfields : économie de mémoire
c
Copier
Modifier
struct s_flags {
    unsigned int a : 1;
    unsigned int b : 1;
    unsigned int reserved : 6;
};
→ Permet de stocker plusieurs booléens ou indicateurs dans un seul octet.

✅ 5. const, volatile, restrict
const : interdit la modification

volatile : indique que la valeur peut changer sans que le code le voie (ex : registre matériel)

restrict : optimisation → pointeur ne chevauche pas d’autres (optimisations compilateur)

🧪 Exercices
📂 types/ex00 — Créer une structure point avec typedef
Créer un point 2D et une fonction affiche_point(t_point p).

📂 types/ex01 — Enumération pour un état de machine
Créer une fonction print_state(t_state) qui affiche "IDLE", "RUNNING" ou "PAUSED" selon la valeur.

📂 types/ex02 — Union générique
Créer une union u_token avec un int, un float, et un char*.
Écrire une fonction affiche_token(union u_token, char type).

📂 types/ex03 — Bitfields pour flags
Définir une structure t_flags avec des champs binaires.
Créer une fonction print_flags() pour afficher leur état binaire.

📂 types/ex04 — Utilisation de volatile
Créer une variable volatile int sensor_data; et une boucle qui la lit (simulation d’un registre externe).

🛠️ Bonus
Simuler une machine d’état avec enum + switch

Implémenter un parser avec union pour stocker différents types

Réaliser un mini flag register (inspiration CPU)






🧩 Module 9 — memory/allocators/ — Créer son propre système de gestion mémoire [📦 Niveau Expert]
📦 Module memory/allocators/ — Implémentation d’allocateurs mémoire personnalisés en C [📦 Expert]
🎯 Objectif pédagogique
Ce module va bien au-delà de l’utilisation de malloc/free. Il te plonge dans l’implémentation de ton propre système de gestion mémoire, comme le ferait un OS ou un runtime C. Tu vas :

Comprendre comment fonctionne réellement malloc

Implémenter un allocateur simple, puis plus avancé

Gérer la fragmentation, les zones libres, les alignements

Approcher des concepts comme les arenas, pools, buddy systems

Étudier la gestion du heap via sbrk, brk ou mmap

📚 Concepts abordés
✅ 1. sbrk() et gestion manuelle du heap
c
Copier
Modifier
void *heap = sbrk(0); // Pointeur actuel
sbrk(4096);           // Réserver 4 Ko
→ C’est la base de malloc.

✅ 2. Structure de bloc mémoire
c
Copier
Modifier
typedef struct block {
    size_t size;
    int is_free;
    struct block *next;
} block_t;
→ Permet de chaîner les blocs, et gérer les fragments.

✅ 3. Allocation / Libération
Implémentation d’un my_malloc() et my_free() :

Trouver un bloc libre de taille suffisante

Sinon, étendre le heap avec sbrk

Marquer un bloc comme occupé ou libre

✅ 4. Alignement mémoire
c
Copier
Modifier
#define ALIGN4(x) (((((x)-1)>>2)<<2)+4)
→ Garantit que chaque bloc commence à une adresse multiple de 4/8 octets.

✅ 5. Fragmentation & fusion
Après libération d’un bloc : fusionner avec les blocs libres adjacents pour éviter la fragmentation excessive.

✅ 6. Techniques avancées
Buddy allocator : blocs divisibles par 2

Arena allocator : bloc pré-réservé, à usage temporaire

Slab allocator : pour objets de taille fixe

Utilisation de mmap() au lieu de sbrk() (meilleure isolation)

🧪 Exercices
📂 memory/allocators/ex00 — Implémenter my_malloc
Créer un système minimal d’allocation : structure + my_malloc() qui réserve via sbrk().

📂 memory/allocators/ex01 — Implémenter my_free
Marquer les blocs comme disponibles, sans fusions.

📂 memory/allocators/ex02 — Fusion et réutilisation de blocs
Améliorer my_free() pour permettre la fusion des blocs libres contigus.

📂 memory/allocators/ex03 — Aligner les blocs (padding)
Forcer les blocs à être alignés (ex: sur 8 octets). Vérifier avec uintptr_t % 8.

📂 memory/allocators/ex04 — Afficher l’état du heap
Créer une fonction debug_heap() qui imprime :

Adresse de chaque bloc

Taille

Libre ou occupé

🛠️ Bonus avancé
Implémenter une version thread-safe (pthread_mutex)

Gérer plusieurs pools (ex : petites tailles, moyennes, grandes)

Créer un benchmark contre malloc




🧩 Module 6 — threads/ — Programmation concurrente en C (pthreads) [🧵 Niveau Avancé]
📦 Module threads/ — Threads POSIX, mutex, synchronisation et conditions de course [🧵 Avancé]
🎯 Objectif pédagogique
Ce module aborde la concurrence en C, c’est-à-dire l’exécution simultanée de plusieurs tâches. Tu vas apprendre à :

Créer et gérer des threads avec pthread_create

Synchroniser des accès mémoire avec des mutex

Détecter et éviter les conditions de course

Utiliser les sémaphores pour gérer l’accès à des ressources critiques

📚 Concepts abordés
✅ 1. Création d’un thread : pthread_create()
c
Copier
Modifier
#include <pthread.h>

void *task(void *arg) {
    printf("Thread lancé\n");
    return NULL;
}

int main() {
    pthread_t t;
    pthread_create(&t, NULL, task, NULL);
    pthread_join(t, NULL);
}
→ Chaque thread exécute une fonction.

✅ 2. Attente de fin de thread : pthread_join()
Assure que le thread s’est bien terminé avant de continuer.

✅ 3. Mutex (pthread_mutex_t)
Utilisés pour éviter que plusieurs threads accèdent à une donnée partagée en même temps.

c
Copier
Modifier
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&lock);
// section critique
pthread_mutex_unlock(&lock);
✅ 4. Conditions de course
Exemple :

c
Copier
Modifier
// Deux threads incrémentent la même variable
compteur++;
→ Peut produire des résultats erronés si non synchronisé.

✅ 5. Sémaphores (POSIX)
c
Copier
Modifier
#include <semaphore.h>

sem_t sem;
sem_init(&sem, 0, 1);

sem_wait(&sem);
// section critique
sem_post(&sem);
→ Alternative aux mutex, permet un compteur de ressources.

🧪 Exercices
📂 threads/ex00 — Créer un thread
Créer un programme qui lance un thread qui affiche "Je suis un thread".

📂 threads/ex01 — Plusieurs threads simples
Créer 5 threads qui affichent leur numéro respectif.

📂 threads/ex02 — Problème de synchronisation
Créer deux threads qui incrémentent une variable int x = 0; 10000 fois chacun.
Sans mutex → observer les valeurs erronées.
Avec mutex → corriger.

📂 threads/ex03 — Utilisation d’un mutex
Créer un thread_safe_log() qui écrit dans un fichier log.txt sans collision entre threads.

📂 threads/ex04 — Sémaphore comme file d’attente
Créer 3 threads producteurs qui écrivent dans un tampon partagé (tableau fixe)
et 1 thread consommateur qui lit les données.

🛠️ Bonus possible
Créer un mini-threadpool

Implémenter un sleep_sort (threads + sleep)

Observer la saturation de CPU avec htop







# Bloc 7 — Serveur Réseau TCP Boosté — Partie 0/?? (Introduction)
📚 Objectif global
Créer en C un serveur réseau TCP capable de :

Accepter plusieurs clients simultanés,

Gérer des commandes simples envoyées par les clients,

Répondre correctement et de façon asynchrone à chaque client,

Le tout sans bloquer les autres clients.

🔌 Tu vas apprendre à utiliser :

Élément système Utilité
socket() Créer une interface réseau
bind() Attacher une IP/port
listen() Mettre le socket en attente de connexions
accept() Accepter une connexion client
read() / recv() Lire les messages entrants
write() / send() Envoyer des réponses
select() Gérer plusieurs clients en parallèle
(bonus) poll() / epoll() Performances ++
🔁 Fonctionnement minimal du serveur
plaintext
Copier
Modifier
[client1] → ↘
[client2] → [socket serveur] → Gère les requêtes clients
[client3] → ↗
Chaque client se connecte et peut :

Envoyer une commande (PING, ECHO, etc.),

Recevoir une réponse adaptée.

🎯 Les fonctionnalités du projet

Étape Fonctionnalité
Partie 1 Créer un serveur TCP simple (1 client à la fois)
Partie 2 Gérer plusieurs clients via select()
Partie 3 Implémenter des commandes textuelles (protocole mini)
Partie 4 Structurer et stabiliser le code
Partie 5 Ajouter un client C pour tester proprement
Partie 6 Bonus: mode broadcast / chat multiclient
Partie 7 Bonus: gestion de fichiers ou mini-API (FTP style)
📦 Format des messages clients (exemples)
plaintext
Copier
Modifier
> PING
< PONG

> ECHO Salut
< Salut

> TIME
< [serveur répond avec l'heure]
📚 Structure de fichiers recommandée
plaintext
Copier
Modifier
tcp_server/
├── main.c
├── server.c
├── server.h
├── client_handler.c
├── protocol.c
├── utils.c
├── Makefile
📋 TDD général du projet

Étape Test
Lancement du serveur Port ouvert et écoute
Connexion d'un client via telnet ou netcat Acceptée
Plusieurs clients en parallèle Gérés sans bloquer
Envoi de message Serveur répond
Commande inconnue Erreur propre
Fermeture client Libération socket propre

# Bloc 7 — Partie 1 — Serveur TCP minimal en C (mono-client)
📚 Objectif immédiat
Coder un serveur TCP qui fait :

🔌 Écoute sur un port fixe,

🤝 Accepte 1 client entrant,

📥 Lit un message envoyé,

📤 Répond un message simple ("OK\n"),

❌ Ferme proprement la connexion.

🧱 Étapes de base

Étape Fonction Description
1 socket() Créer une socket réseau
2 bind() Associer à une IP + port
3 listen() Mettre la socket en mode écoute
4 accept() Accepter une connexion entrante
5 read() / write() Communiquer
6 close() Fermer proprement les sockets
📋 Code complet d'un serveur TCP mono-client (main.c)
c
Copier
Modifier
```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <netinet/in.h>
# include <sys/socket.h>

```
# define PORT 4242
# define BUFFER_SIZE 1024

int main(void)
{
```c
 int server_fd, client_fd;
 struct sockaddr_in address;
 socklen_t addrlen = sizeof(address);
 char buffer[BUFFER_SIZE] = {0};

```
c
 // 1. Créer socket
 server_fd = socket(AF_INET, SOCK_STREAM, 0);
 if (server_fd == -1)
 {
 perror("socket");
 exit(EXIT_FAILURE);
 }

```
c
 // 2. Préparer struct sockaddr_in
 address.sin_family = AF_INET;
 address.sin_addr.s_addr = INADDR_ANY; // accepte toutes les IP
 address.sin_port = htons(PORT); // convertir en format réseau

```
c
 // 3. Bind
 if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
 {
 perror("bind");
 exit(EXIT_FAILURE);
 }

```
c
 // 4. Listen
 if (listen(server_fd, 1) < 0)
 {
 perror("listen");
 exit(EXIT_FAILURE);
 }

```
c
 printf("🟢 Serveur prêt sur le port %d... Attente de connexion...\n", PORT);

```
c
 // 5. Accept
 client_fd = accept(server_fd, (struct sockaddr *)&address, &addrlen);
 if (client_fd < 0)
 {
 perror("accept");
 exit(EXIT_FAILURE);
 }

```
c
 printf("🤝 Client connecté\n");

```
c
 // 6. Lecture
 int bytes = read(client_fd, buffer, BUFFER_SIZE - 1);
 if (bytes > 0)
 {
 buffer[bytes] = '\0';
 printf("📥 Reçu: %s", buffer);
 // 7. Répondre
 write(client_fd, "OK\n", 3);
 }

```
c
 // 8. Fermer les sockets
 close(client_fd);
 close(server_fd);
 printf("❌ Connexion fermée\n");

```
c
 return 0;
}
📦 Compilation
bash
Copier
Modifier
gcc -Wall -Wextra -Werror -o server main.c
📋 Test avec un client simple
Dans un autre terminal :

```
bash
Copier
Modifier
nc localhost 4242
Tapez un message (ex: Hello serveur) ➔ tu dois recevoir: OK

📚 Concepts appris dans cette partie

Élément Appris
Socket Point d'entrée réseau
bind Fixe le port/IP
listen Met en attente de connexion
accept Gère une demande entrante
read/write Échange de données
close() Libération des ressources

# Bloc 7 — Partie 2 — Serveur TCP multiclient avec select()
📚 Objectif immédiat
Tu vas modifier ton serveur TCP pour :

Gérer plusieurs connexions clientes à la fois,

Lire les messages de n'importe quel client sans bloquer,

Répondre correctement à chacun.

Sans utiliser de threads ni de processus, uniquement select() !

📋 Pourquoi select() ?
Permet de surveiller plusieurs file descriptors (fd) en même temps,

Peut surveiller :

des sockets en lecture (read),

en écriture (write),

en erreur.

📦 Comment fonctionne select()

Étape Action
1 Créer un ensemble (fd_set) de sockets à surveiller
2 Appeler select() qui attend jusqu'à ce qu'un fd soit prêt
3 Quand select() détecte un événement, traiter uniquement les sockets actifs
📋 Nouveau flux du serveur TCP
plaintext
Copier
Modifier
1. Préparer fd_set avec server_fd et tous les clients connectés
2. select()
3. Si server_fd est prêt → nouvelle connexion
4. Si client_fd est prêt → lire son message
5. Répondre ou fermer client si besoin
📚 Code de serveur TCP multiclient avec select()
c
Copier
Modifier
```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <netinet/in.h>
# include <sys/socket.h>
# include <sys/select.h>

```
# define PORT 4242
# define BUFFER_SIZE 1024
# define MAX_CLIENTS 10

int main(void)
{
```c
 int server_fd, client_fd, max_fd, activity, new_socket;
 struct sockaddr_in address;
 socklen_t addrlen = sizeof(address);
 int clients[MAX_CLIENTS];
 fd_set readfds;
 char buffer[BUFFER_SIZE];
 int i;

```
c
 // Initialiser les clients
 for (i = 0; i < MAX_CLIENTS; i++)
 clients[i] = 0;

```
c
 // 1. Créer socket serveur
 server_fd = socket(AF_INET, SOCK_STREAM, 0);
 if (server_fd == -1)
 {
 perror("socket");
 exit(EXIT_FAILURE);
 }

```
c
 // 2. Bind
 address.sin_family = AF_INET;
 address.sin_addr.s_addr = INADDR_ANY;
 address.sin_port = htons(PORT);

```
 if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
 {
 perror("bind");
 exit(EXIT_FAILURE);
 }

```c
 // 3. Listen
 if (listen(server_fd, 3) < 0)
 {
 perror("listen");
 exit(EXIT_FAILURE);
 }

```
c
 printf("🟢 Serveur multi-clients démarré sur port %d\n", PORT);

```
 while (1)
 {
 FD_ZERO(&readfds);
 FD_SET(server_fd, &readfds);
 max_fd = server_fd;

```c
 // Ajouter les clients existants
 for (i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] > 0)
 FD_SET(clients[i], &readfds);

```
 if (clients[i] > max_fd)
 max_fd = clients[i];
 }

```c
 // 4. Attendre activité sur n'importe quel socket
 activity = select(max_fd + 1, &readfds, NULL, NULL, NULL);
 if (activity < 0)
 {
 perror("select");
 continue;
 }

```
c
 // 5. Nouvelle connexion
 if (FD_ISSET(server_fd, &readfds))
 {
 if ((new_socket = accept(server_fd, (struct sockaddr *)&address, &addrlen)) < 0)
 {
 perror("accept");
 exit(EXIT_FAILURE);
 }

```
c
 printf("🤝 Nouveau client connecté: socket fd %d\n", new_socket);

```
c
 for (i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] == 0)
 {
 clients[i] = new_socket;
 break;
 }
 }
 }

```
c
 // 6. Lire messages clients
 for (i = 0; i < MAX_CLIENTS; i++)
 {
 client_fd = clients[i];
 if (FD_ISSET(client_fd, &readfds))
 {
 int bytes = read(client_fd, buffer, BUFFER_SIZE);
 if (bytes <= 0)
 {
 // Déconnexion
 printf("❌ Client déconnecté: socket fd %d\n", client_fd);
 close(client_fd);
 clients[i] = 0;
 }
 else
 {
 buffer[bytes] = '\0';
 printf("📥 Message du client %d: %s", client_fd, buffer);
 send(client_fd, "OK\n", 3, 0);
 }
 }
 }
 }

```
c
 return 0;
}
📚 Concepts renforcés ici

```
Élément Ce qu'on apprend
fd_set Surveiller plusieurs sockets
select() Attendre plusieurs événements simultanément
Gestion dynamique des clients Ajouter/retirer proprement
Répondre individuellement Communication parallèle non bloquante
🎯 Mini Plan d'Action Partie 2
Préparer un tableau clients[],

Utiliser FD_SET pour surveiller server_fd + clients[],

Avec select(), gérer les connexions entrantes + messages,

Détecter les déconnexions,

Tester avec netcat (nc localhost 4242) plusieurs clients.

📋 TDD minimal Bloc 7 Partie 2

Test Ce qu'on attend
Connexion 1 client → dialogue OK
Connexion 3 clients → dialogue en parallèle OK
Déconnexion brutale d'un client Pas de crash
Envoi rapide de messages multiples Pas de perte

# Bloc 7 — Partie 3 — Implémenter un mini-protocole (PING, ECHO, TIME, etc.)
📚 Objectif immédiat
➔ Ajouter un système simple pour :

Comprendre des commandes texte envoyées par les clients,

Répondre avec des réponses adaptées,

Gérer les erreurs (commande inconnue).

📋 Commandes à implémenter

Commande Réponse attendue
PING PONG\n
ECHO <texte> <texte>\n
TIME Affiche l'heure du serveur
EXIT Ferme la connexion avec le client
(bonus) commande inconnue ERROR: Unknown command\n
🧠 Comment traiter un message reçu
Lire la ligne envoyée par le client,

Parser la commande principale (PING, ECHO, etc.),

Comparer avec les commandes connues,

Répondre avec send(),

(Si EXIT) fermer proprement le client.

📚 Ajout de la fonction handle_client_message()
Dans client_handler.c :

c
Copier
Modifier
```c
# include <stdio.h>
# include <string.h>
# include <unistd.h>
# include <time.h>

```
void handle_client_message(int client_fd, char *message)
{
 if (strncmp(message, "PING", 4) == 0)
 {
 send(client_fd, "PONG\n", 5, 0);
 }
 else if (strncmp(message, "ECHO ", 5) == 0)
 {
 send(client_fd, message + 5, strlen(message + 5), 0);
 send(client_fd, "\n", 1, 0);
 }
 else if (strncmp(message, "TIME", 4) == 0)
 {
 time_t now = time(NULL);
```c
 char *timestr = ctime(&now);
 send(client_fd, timestr, strlen(timestr), 0);
 }
 else if (strncmp(message, "EXIT", 4) == 0)
 {
 send(client_fd, "Bye!\n", 5, 0);
 close(client_fd);
 }
 else
 {
 send(client_fd, "ERROR: Unknown command\n", 23, 0);
 }
}
📋 Mise à jour du serveur dans main.c
Dans ta boucle principale, au lieu d'envoyer juste "OK\n", tu appelles :

```
c
Copier
Modifier
handle_client_message(client_fd, buffer);
📦 Nouveau flux complet
plaintext
Copier
Modifier
- Client envoie "PING"
- Serveur répond "PONG"
- Client envoie "ECHO Hello"
- Serveur répond "Hello"
- Client envoie "TIME"
- Serveur répond date/heure
- Client envoie "EXIT"
- Serveur ferme connexion
📚 Astuces

Problème courant Solution
Comparaison partielle (seulement les premiers mots) Utiliser strncmp() et tailles fixes
Gestion propre de EXIT Fermer client_fd immédiatement
Nettoyer les buffers avant d'écrire Toujours remettre \0 après read()
🎯 Mini plan d'action Partie 3
Lire les commandes des clients,

Appeler handle_client_message(client_fd, message),

Répondre selon la commande,

Fermer proprement après EXIT.

📋 TDD minimal Bloc 7 Partie 3

Client commande Réponse attendue
PING PONG\n
ECHO Salut Salut\n
TIME Heure actuelle
EXIT Déconnexion immédiate
HELLO ERROR: Unknown command\n

# Bloc 7 — Partie 4 — Refactorisation propre: serveur modulaire
📚 Objectif immédiat
Structurer ton code pour :

Le rendre plus propre,

Le rendre plus lisible,

Le rendre plus évolutif (ajout facile de nouvelles fonctionnalités).

📋 Pourquoi structurer ?

Raison Impact
Code lisible ✅ Plus facile à maintenir
Modulaire ✅ Ajout/suppression de fonctions rapide
Projet "pro" ✅ Ressemble à un vrai projet C d'entreprise
Evite le "spaghetti code" ✅ Meilleure scalabilité
📚 Nouvelle architecture du projet
plaintext
Copier
Modifier
tcp_server/
├── src/
│ ├── main.c # Initialisation serveur + boucle principale
│ ├── server.c # Gestion sockets serveur
│ ├── client_handler.c # Gestion lecture/écriture client
│ ├── protocol.c # Parsing et réponse aux commandes
│ ├── utils.c # Petites fonctions utilitaires
├── include/
│ ├── server.h
│ ├── client_handler.h
│ ├── protocol.h
│ ├── utils.h
├── Makefile
📚 Rôle de chaque fichier

Fichier Contenu
main.c Boucle principale, select(), gestion des fd
server.c Fonctions pour socket(), bind(), listen(), accept()
client_handler.c Fonctions pour lire/écrire sur les sockets clients
protocol.c Décodage des commandes reçues
utils.c Fonctions annexes (debug, logs, buffer tools...)
📋 Exemples de fonctions par fichier
📦 server.c
c
Copier
Modifier
```c
int create_server_socket(int port);
int accept_new_client(int server_fd);
📦 client_handler.c
c
Copier
Modifier
void handle_client_activity(int client_fd);
void close_client(int client_fd, int *clients);
📦 protocol.c
c
Copier
Modifier
void handle_client_message(int client_fd, char *message);
📦 utils.c
c
Copier
Modifier
void error_exit(const char *msg);
void clear_buffer(char *buffer, int size);
📚 Mise à jour de main.c
Ton main.c deviendra ultra léger :

```
c
Copier
Modifier
```c
# include "server.h"
# include "client_handler.h"
# include "utils.h"

```
int main(void)
{
```c
 int server_fd = create_server_socket(4242);
 int clients[MAX_CLIENTS] = {0};

```
 while (1)
 server_loop(server_fd, clients);

```c
 return 0;
}
(Le server_loop() gérera select(), acceptations et lectures clients.)

```
📋 Makefile propre
Makefile
Copier
Modifier
NAME = server

SRCS = src/main.c src/server.c src/client_handler.c src/protocol.c src/utils.c
OBJS = $(SRCS:.c=.o)
INCS = -Iinclude
CC = gcc
CFLAGS = -Wall -Wextra -Werror

all: $(NAME)

$(NAME): $(OBJS)
 $(CC) $(CFLAGS) $(INCS) -o $@ $^

clean:
 rm -f $(OBJS)

fclean: clean
 rm -f $(NAME)

re: fclean all
📚 Mini rappel: MAX_CLIENTS
À garder dans server.h ou un config.h :

c
Copier
Modifier
# define MAX_CLIENTS 10
# define BUFFER_SIZE 1024
🎯 Mini plan d'action Partie 4
Découper main.c en 3-4 modules,

Créer dossiers src/ et include/,

Faire un Makefile propre,

Tester que tout fonctionne toujours,

Préparer pour ajouts futurs (authentification, messages privés, etc.).

📋 TDD minimal Bloc 7 Partie 4

Vérification Attendu
Compilation sans warnings ✅
Serveur fonctionnel ✅
Clients multiples connectés simultanément ✅
PING, ECHO, TIME, EXIT fonctionnels ✅
Makefile re propre ✅

# Bloc 7 — Partie 5 — Créer ton propre client TCP en C
📚 Objectif immédiat
➔ Tu vas coder un programme qui :

Se connecte au serveur que tu as développé,

Envoie des commandes (PING, ECHO, TIME, EXIT...),

Reçoit et affiche les réponses du serveur,

Fonctionne dans une boucle interactive.

📋 Étapes principales du client

Étape Action
1 Créer une socket client
2 Connecter au serveur (connect())
3 Envoyer un message tapé par l'utilisateur
4 Lire la réponse du serveur
5 Répéter jusqu'à EXIT ou fermeture
📚 Code complet d'un petit client TCP (client.c)
c
Copier
Modifier
```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <netinet/in.h>
# include <sys/socket.h>
# include <arpa/inet.h>

```
# define PORT 4242
# define BUFFER_SIZE 1024

int main(void)
{
```c
 int sock = 0;
 struct sockaddr_in serv_addr;
 char buffer[BUFFER_SIZE] = {0};
 char input[BUFFER_SIZE] = {0};
 int bytes;

```
c
 // 1. Créer socket
 sock = socket(AF_INET, SOCK_STREAM, 0);
 if (sock < 0)
 {
 perror("socket");
 exit(EXIT_FAILURE);
 }

```
c
 // 2. Préparer adresse serveur
 serv_addr.sin_family = AF_INET;
 serv_addr.sin_port = htons(PORT);

```
c
 // 3. Convertir IP
 if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0)
 {
 printf("❌ Adresse invalide\n");
 return -1;
 }

```
c
 // 4. Connecter
 if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
 {
 perror("connect");
 exit(EXIT_FAILURE);
 }

```
c
 printf("🟢 Connecté au serveur sur 127.0.0.1:%d\n", PORT);

```
 while (1)
 {
```c
 printf("🖋️ > ");
 if (!fgets(input, BUFFER_SIZE, stdin))
 break;

```
c
 // Supprimer le '\n' de fgets
 input[strcspn(input, "\n")] = 0;

```
 if (send(sock, input, strlen(input), 0) < 0)
 {
 perror("send");
 break;
 }

 bytes = recv(sock, buffer, BUFFER_SIZE - 1, 0);
 if (bytes <= 0)
 {
```c
 printf("❌ Serveur déconnecté\n");
 break;
 }

```
 buffer[bytes] = '\0';
```c
 printf("📥 Réponse: %s", buffer);

```
 if (strcmp(input, "EXIT") == 0)
 break;
 }

 close(sock);
```c
 printf("🚪 Déconnecté\n");
 return 0;
}
📦 Compilation
bash
Copier
Modifier
gcc -Wall -Wextra -Werror -o client client.c
📚 Concepts appris ici

```
Élément Ce qu'on apprend
socket() Créer une connexion TCP client
connect() Se lier à une IP + port distant
send() / recv() Dialogue bidirectionnel
close() Fermer la socket proprement
Boucle interactive Simulation simple d'un terminal réseau
📋 Test complet

Étape Ce qui doit se passer
Lancer serveur (./server) 
Lancer client (./client) 
Taper PING Le serveur répond PONG
Taper ECHO Hello World Le serveur répète Hello World
Taper TIME Le serveur donne l'heure
Taper EXIT Le serveur ferme la connexion
🎯 Mini plan d'action Partie 5
Écrire client.c,

Connecter au serveur,

Envoyer/recevoir en boucle,

Gérer la commande EXIT,

Préparer pour un client plus "pro" ensuite si besoin.

📋 TDD minimal Bloc 7 Partie 5

Test Ce qu'on attend
Connexion au serveur ✅
Envoi de message ✅
Réception de réponse correcte ✅
Déconnexion propre ✅
Fermeture sur erreur ✅

# Bloc 7 — Partie 6 — Mode Chat Multiclient (Broadcast)
📚 Objectif immédiat
Améliorer ton serveur TCP pour :

📢 Quand un client envoie un message, le serveur retransmet ce message à tous les autres clients,

Gérer proprement les entrées/sorties pour tous,

Gérer les déconnexions sans casser tout.

📋 Fonctionnement du mode Chat

Action Comportement
Un client écrit un message Serveur relaie à tous les autres
Un client quitte (EXIT) Serveur ferme sa socket et informe les autres si besoin
Tous les messages sont diffusés Broadcast sauf vers l'expéditeur
📦 Comment modifier ton serveur
Tu dois :

Lire un message d'un client,

Le retransmettre à tous les autres clients connectés.

📋 Fonction broadcast_message()
Dans client_handler.c par exemple :

c
Copier
Modifier
```c
# include <string.h>
# include <unistd.h>
# include "server.h"

```
void broadcast_message(int sender_fd, int *clients, char *message)
{
```c
 for (int i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] > 0 && clients[i] != sender_fd)
 {
 send(clients[i], message, strlen(message), 0);
 }
 }
}
📚 Mise à jour dans ta boucle principale
Quand tu reçois un message d'un client :

```
c
Copier
Modifier
```c
int bytes = read(client_fd, buffer, BUFFER_SIZE);
if (bytes <= 0)
{
 // Déconnexion
 printf("❌ Client déconnecté: socket fd %d\n", client_fd);
 close(client_fd);
 clients[i] = 0;
}
else
{
 buffer[bytes] = '\0';
 printf("📥 Message du client %d: %s", client_fd, buffer);

```
 if (strncmp(buffer, "EXIT", 4) == 0)
 {
 send(client_fd, "Bye!\n", 5, 0);
 close(client_fd);
 clients[i] = 0;
 }
 else
 {
 broadcast_message(client_fd, clients, buffer);
 }
}
📚 Important

Piège courant Solution
Envoyer au client qui a écrit Vérifie clients[i] != sender_fd
Oublier \0 dans buffer Toujours terminer buffer[bytes] = '\0'
Ne pas fermer les sockets mortes Toujours close() et clients[i] = 0 si déconnecté
📋 Exemple de dialogue entre 3 clients
plaintext
Copier
Modifier
Client 1 ➔ Hello
Client 2 ➔ Reçoit: Hello
Client 3 ➔ Reçoit: Hello

Client 2 ➔ Hi there!
Client 1 ➔ Reçoit: Hi there!
Client 3 ➔ Reçoit: Hi there!
📦 Tu peux aussi ajouter une étiquette d'expéditeur (bonus)
Exemple dans broadcast_message() :

c
Copier
Modifier
```c
char temp[BUFFER_SIZE];
snprintf(temp, sizeof(temp), "Client %d: %s", sender_fd, message);
Et ensuite envoyer temp au lieu de message ➔ plus propre !

```
📋 TDD minimal Bloc 7 Partie 6

Test Attendu
Client 1 écrit Client 2 et 3 reçoivent
Client 2 écrit Client 1 et 3 reçoivent
Client 3 déconnecte Pas d'erreur, les autres continuent
Client flood rapide Serveur continue proprement

# Bloc 7 — Partie 7 — Commandes avancées pour Chat (/msg, /who)
📚 Objectif immédiat
Ton serveur va maintenant :

Gérer les messages privés (/msg <id> <message>),

Permettre à un client de lister tous les clients connectés (/who).

➔ Devenir un mini-IRC simplifié ! 🚀

📋 Commandes à implémenter

Commande Comportement
/msg <client_id> <message> Envoie un message privé à un seul client
/who Renvoie la liste des IDs de tous les clients connectés
Autre Message inconnu ➔ ERROR: Unknown command\n
📦 Mise à jour dans handle_client_message()
Remplace la gestion simple par une gestion avancée des commandes :

📋 Nouveau handle_client_message()
c
Copier
Modifier
```c
# include <stdio.h>
# include <string.h>
# include <unistd.h>
# include "server.h"

```
void handle_client_message(int client_fd, int *clients, char *message)
{
```c
 char temp[BUFFER_SIZE];
 int target_fd;
 int target_id;
 char *msg_start;

```
 if (strncmp(message, "/msg ", 5) == 0)
 {
```c
 // /msg <client_id> <message>
 target_id = atoi(message + 5);
 msg_start = strchr(message + 5, ' ');
 if (msg_start)
 {
 msg_start++; // avancer après l'espace
 for (int i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] == target_id)
 {
 snprintf(temp, sizeof(temp), "[privé de %d]: %s\n", client_fd, msg_start);
 send(clients[i], temp, strlen(temp), 0);
 return;
 }
 }
 send(client_fd, "❌ Client inconnu\n", 18, 0);
 }
 else
 {
 send(client_fd, "❌ Format: /msg <id> <message>\n", 30, 0);
 }
 }
 else if (strncmp(message, "/who", 4) == 0)
 {
 strcpy(temp, "👥 Clients connectés: ");
 for (int i = 0; i < MAX_CLIENTS; i++)
 {
 if (clients[i] > 0)
 {
 char id[10];
 snprintf(id, sizeof(id), "%d ", clients[i]);
 strcat(temp, id);
 }
 }
 strcat(temp, "\n");
 send(client_fd, temp, strlen(temp), 0);
 }
 else
 {
 send(client_fd, "ERROR: Unknown command\n", 23, 0);
 }
}
📚 Explication simple

```
Cas Action
/msg <id> <text> Trouve le client ayant cet ID, lui envoie le message privé
/who Envoie la liste de tous les clients connectés
Commande inconnue Envoie une erreur simple
📋 Utilisation pratique par les utilisateurs
Exemple conversation :
plaintext
Copier
Modifier
Client 1 ➔ /who
Serveur ➔ 👥 Clients connectés: 4 5 6

Client 4 ➔ /msg 5 Salut toi !
Client 5 ➔ reçoit "[privé de 4]: Salut toi !"
📦 Mise à jour de la boucle serveur
Dans ta boucle principale, au lieu de juste diffuser :

c
Copier
Modifier
if (buffer[0] == '/')
 handle_client_message(client_fd, clients, buffer);
else
 broadcast_message(client_fd, clients, buffer);
➔ On traite les commandes spéciales (/msg, /who), sinon on diffuse à tout le monde.

🎯 Mini plan d'action Partie 7
Modifier handle_client_message() pour comprendre /msg et /who,

Ajuster la boucle principale pour appeler correctement,

Tester plusieurs clients,

Gérer erreur propre si mauvais format.

📋 TDD minimal Bloc 7 Partie 7

Commande Résultat attendu
/who Liste des IDs connectés
/msg <id> Hello Message privé correct
/msg <id> sans texte Erreur de format
/msg id_inexistant Erreur "Client inconnu"
Commande inconnue Erreur standard

# Bloc 7 — Partie 8/8 — Finalisation du serveur: Robustesse & Propreté
📚 Objectif immédiat
➔ Stabiliser totalement ton serveur :

✅ Détecter proprement les déconnexions inattendues (client qui quitte brutalement),

✅ Ajouter un timeout d'inactivité (bonus),

✅ Éviter toute fuite mémoire ou socket ouverte,

✅ Rendre les erreurs visibles clairement,

✅ Avoir un Makefile propre et une structure finale propre.

📋 Points critiques à corriger / ajouter
1. Déconnexion brutale (CTRL+C, crash client)
Dans ta lecture (read() ou recv()), bytes == 0 signifie client déconnecté.

➔ Déjà géré si tu as :

c
Copier
Modifier
if (bytes <= 0)
{
```c
 printf("❌ Client déconnecté: socket fd %d\n", client_fd);
 close(client_fd);
 clients[i] = 0;
}
✔️ Rien d'autre à faire !

```
2. Timeout d'inactivité (bonus)
➔ En option, avec select(), tu peux fixer un timeout sur la boucle principale.

Ajout simple :

c
Copier
Modifier
struct timeval timeout;
timeout.tv_sec = 300; // 5 minutes
timeout.tv_usec = 0;
Puis utiliser :

c
Copier
Modifier
select(max_fd + 1, &readfds, NULL, NULL, &timeout);
➔ Si aucun client ne bouge pendant 5 minutes ➔ tu peux décider d'envoyer un message d'inactivité ou fermer les connexions.

3. Messages d'erreur propres
Partout où un send(), recv(), ou accept() échoue ➔ afficher un perror().

Exemple :

c
Copier
Modifier
if ((new_socket = accept(server_fd, (struct sockaddr *)&address, &addrlen)) < 0)
{
 perror("accept");
 continue;
}
4. Makefile final
Makefile propre avec debug facile :

Makefile
Copier
Modifier
NAME = server
NAME_CLIENT = client

SRCS_SERVER = src/main.c src/server.c src/client_handler.c src/protocol.c src/utils.c
SRCS_CLIENT = client/client.c

OBJS_SERVER = $(SRCS_SERVER:.c=.o)
OBJS_CLIENT = $(SRCS_CLIENT:.c=.o)

INCS = -Iinclude
CC = gcc
CFLAGS = -Wall -Wextra -Werror

all: $(NAME) $(NAME_CLIENT)

$(NAME): $(OBJS_SERVER)
 $(CC) $(CFLAGS) $(INCS) -o $@ $^

$(NAME_CLIENT): $(OBJS_CLIENT)
 $(CC) $(CFLAGS) -o $@ $^

clean:
 rm -f $(OBJS_SERVER) $(OBJS_CLIENT)

fclean: clean
 rm -f $(NAME) $(NAME_CLIENT)

re: fclean all
📚 Structure finale recommandée
plaintext
Copier
Modifier
tcp_server/
├── src/
│ ├── main.c
│ ├── server.c
│ ├── server.h
│ ├── client_handler.c
│ ├── client_handler.h
│ ├── protocol.c
│ ├── protocol.h
│ ├── utils.c
│ ├── utils.h
├── client/
│ ├── client.c
├── include/
│ ├── config.h (MAX_CLIENTS, BUFFER_SIZE)
├── Makefile
📋 Tests finaux avant validation

Test Ce qui doit être OK
Connexion 5 clients simultanés ✅
Broadcast messages ✅
Message privé (/msg) ✅
Liste connectés (/who) ✅
Déconnexion brutale client Pas de crash
Timeout inactivité (option) Déconnecte proprement
Valgrind (pas de fuites sockets) ✅
Norme 42 (-Wall -Wextra -Werror) ✅
🎯 Résultat final
✅ Tu as un vrai serveur TCP multiclient Chat :

Gestion multi-clients sans thread,

Commandes /msg, /who, EXIT,

Timeouts (bonus),

Code propre et bien modulaire.

# Bloc 8 — Développement d'un Mini Moteur 3D en C avec OpenGL
📚 Objectif global
Créer à la main :

Un moteur de rendu 3D,

En C pur,

Basé sur OpenGL + GLFW (librairies basiques pour ouverture de fenêtre et affichage),

Sans utiliser de moteur externe (pas Unity, pas Unreal).

📋 Étapes principales du projet

Étape Description
Partie 1 Créer une fenêtre OpenGL
Partie 2 Afficher un triangle simple
Partie 3 Charger des modèles 3D basiques
Partie 4 Ajouter une caméra mobile (vue FPS ou orbitale)
Partie 5 Éclairages simples
Partie 6 Textures sur les objets
Partie 7 Bonus: scène complète, skybox, UI simple
📚 Compétences que tu vas acquérir

Compétence Utilité
Programmation graphique 3D ✅
Matrices 3D (MVP: Model-View-Projection) ✅
Programmation événementielle (clavier/souris) ✅
Gestion mémoire avancée pour ressources 3D ✅
Optimisation du rendu ✅
Bases solides pour OpenGL, Vulkan, Metal... ✅
📦 Matériel requis

Logiciel Détail
OpenGL (déjà inclus sur Linux / Mac) Affichage 3D
GLFW Ouverture de fenêtre, gestion input
GLAD (optionnel) Pour charger les fonctions OpenGL modernes
gcc Compilation classique
Makefile propre Comme d'habitude !
📚 Structure du projet recommandée
plaintext
Copier
Modifier
mini_3d_engine/
├── src/
│ ├── main.c # Démarrage moteur
│ ├── window.c # Création fenêtre + gestion événements
│ ├── renderer.c # Rendu de base (triangles, modèles)
│ ├── shader.c # Chargement et utilisation de shaders
│ ├── camera.c # Mouvement caméra
│ ├── model.c # Gestion modèles 3D
│ ├── texture.c # Application de textures
├── shaders/
│ ├── basic.vert # Shader de vertex
│ ├── basic.frag # Shader de fragment
├── include/
│ ├── engine.h
│ ├── window.h
│ ├── renderer.h
│ ├── shader.h
│ ├── camera.h
│ ├── model.h
│ ├── texture.h
├── Makefile
📋 Objectifs d'affichage

Cible Description
🎯 Partie 1 Ouvrir une fenêtre noire sans crash
🎯 Partie 2 Dessiner un triangle coloré
🎯 Partie 3 Charger un modèle .obj basique
🎯 Partie 4 Contrôler une caméra FPS (WASD + souris)
🎯 Partie 5 Ajouter lumière simple (Phong, Blinn)
🎯 Partie 6 Appliquer textures sur modèles
🎯 Partie 7 Charger plusieurs objets dans une scène complète
📚 Petites bases que tu dois connaître avant de commencer
Un vertex est un point 3D (x,y,z),

Un triangle est 3 vertex liés,

Un shader est un petit programme qui dit comment afficher les pixels,

Une matrice MVP est la combinaison qui transforme tes objets en vue caméra.

🎯 Mini plan d'action global du Bloc 8
Initialiser GLFW et créer une fenêtre,

Dessiner un triangle OpenGL,

Charger/afficher des modèles 3D simples,

Déplacer la caméra,

Éclairer la scène,

Appliquer des textures,

Finaliser avec une petite scène complète.

# Bloc 8 — Partie 1 — Créer une fenêtre OpenGL avec GLFW
📚 Objectif immédiat
Tu vas :

Initialiser la bibliothèque GLFW,

Créer une fenêtre vide,

Ouvrir une connexion OpenGL,

Laisser la fenêtre ouverte tant que l'utilisateur ne la ferme pas.

📦 Ce qu'est GLFW

Élément Utilité
GLFW Librairie légère pour créer fenêtres OpenGL et capturer les événements clavier/souris
📋 Ce qu'on veut obtenir maintenant
Une fenêtre vide noire,

Qui reste ouverte jusqu'à ce que tu cliques sur [X] pour fermer.

📚 Installer GLFW
Sur Linux (Ubuntu/Debian) :

bash
Copier
Modifier
sudo apt-get install libglfw3 libglfw3-dev
Sur Mac :

bash
Copier
Modifier
brew install glfw
Sous Windows ➔ je te donnerai les instructions si tu veux.

📋 Code complet pour créer une fenêtre (main.c)
c
Copier
Modifier
```c
# include <GLFW/glfw3.h>
# include <stdio.h>

```
int main(void)
{
 if (!glfwInit())
 {
 fprintf(stderr, "❌ Erreur d'initialisation GLFW\n");
```c
 return -1;
 }

```
c
 // Spécifier la version OpenGL
 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

```
c
 // Créer une fenêtre
 GLFWwindow* window = glfwCreateWindow(800, 600, "Mini 3D Engine", NULL, NULL);
 if (!window)
 {
 fprintf(stderr, "❌ Erreur de création de fenêtre\n");
 glfwTerminate();
 return -1;
 }

```
c
 // Lier la fenêtre au contexte OpenGL courant
 glfwMakeContextCurrent(window);

```
c
 // Boucle principale
 while (!glfwWindowShouldClose(window))
 {
 // Couleur de fond
 glClearColor(0.1f, 0.1f, 0.2f, 1.0f);
 glClear(GL_COLOR_BUFFER_BIT);

```
c
 // Afficher le rendu
 glfwSwapBuffers(window);
 glfwPollEvents();
 }

```
 glfwDestroyWindow(window);
 glfwTerminate();
```c
 return 0;
}
📦 Compilation
bash
Copier
Modifier
gcc -Wall -Wextra -Werror main.c -lglfw -lGL -lm -ldl -pthread -o mini3d
(options légèrement différentes sur Mac, je peux t'aider si besoin)

```
📚 Que fait ce code

Étape Action
glfwInit() Initialise la bibliothèque
glfwCreateWindow() Crée une fenêtre
glfwMakeContextCurrent() Associe OpenGL à la fenêtre
Boucle principale Continue à afficher jusqu'à fermeture
glClearColor() Définit la couleur de fond
glClear() Efface l'écran à chaque frame
glfwSwapBuffers() Affiche le nouveau contenu
glfwPollEvents() Gère les clics, clavier, etc
glfwDestroyWindow() et glfwTerminate() Nettoyage propre
🎯 Mini plan d'action Partie 1
Installer GLFW (si pas fait),

Écrire et compiler main.c,

Ouvrir ta première fenêtre OpenGL,

Vérifier qu'elle reste ouverte sans crash.

📋 TDD minimal Bloc 8 Partie 1

Test Ce qui doit se passer
Lancer l'exécutable Fenêtre vide apparaît
Cliquer sur fermer Fenêtre disparaît proprement
Aucun crash ✅

# Bloc 8 — Partie 2 — Dessiner un triangle en OpenGL
📚 Objectif immédiat
Tu vas :

Envoyer des données de vertex à ta carte graphique,

Afficher un triangle simple en couleur,

Comprendre comment la "pipeline graphique" fonctionne.

📋 Concepts importants ici

Terme Description
Vertex Un point (x, y, z) en 3D
VBO (Vertex Buffer Object) Mémoire pour stocker les vertex
VAO (Vertex Array Object) Configuration pour expliquer OpenGL comment lire le VBO
Shader Petit programme qui décide de l'apparence finale
Pipeline graphique Chemin du vertex brut → pixel affiché
📦 Données pour un simple triangle
On veut dessiner ce triangle :

bash
Copier
Modifier
 ▲
 / \
 /___\
En coordonnées OpenGL :

c
Copier
Modifier
float vertices[] = {
 0.0f, 0.5f, 0.0f, // Sommet haut
 -0.5f, -0.5f, 0.0f, // Bas gauche
 0.5f, -0.5f, 0.0f // Bas droite
};
📚 Nouveau code complet (main.c amélioré)
c
Copier
Modifier
```c
# include <GLFW/glfw3.h>
# include <stdio.h>

```
# define WIDTH 800
# define HEIGHT 600

const char *vertexShaderSource = "# version 330 core\n"
 "layout (location = 0) in vec3 aPos;\n"
 "void main() {\n"
 " gl_Position = vec4(aPos, 1.0);\n"
 "}\0";

const char *fragmentShaderSource = "# version 330 core\n"
 "out vec4 FragColor;\n"
 "void main() {\n"
 " FragColor = vec4(0.5, 0.8, 0.2, 1.0);\n"
 "}\n\0";

int main(void)
{
 if (!glfwInit())
```c
 return -1;

```
 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

 GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "Mini 3D Engine", NULL, NULL);
 if (!window)
 {
 glfwTerminate();
```c
 return -1;
 }
 glfwMakeContextCurrent(window);

```
c
 // Définir les vertex du triangle
 float vertices[] = {
 0.0f, 0.5f, 0.0f, 
 -0.5f, -0.5f, 0.0f, 
 0.5f, -0.5f, 0.0f
 };

```
c
 unsigned int VBO, VAO;
 glGenVertexArrays(1, &VAO);
 glGenBuffers(1, &VBO);

```
c
 // Lier le VAO
 glBindVertexArray(VAO);

```
c
 // Lier et remplir le VBO
 glBindBuffer(GL_ARRAY_BUFFER, VBO);
 glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

```
c
 // Spécifier comment lire les données
 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
 glEnableVertexAttribArray(0);

```
c
 // Compiler le vertex shader
 unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
 glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
 glCompileShader(vertexShader);

```
c
 // Compiler le fragment shader
 unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
 glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
 glCompileShader(fragmentShader);

```
c
 // Créer le shader program
 unsigned int shaderProgram = glCreateProgram();
 glAttachShader(shaderProgram, vertexShader);
 glAttachShader(shaderProgram, fragmentShader);
 glLinkProgram(shaderProgram);

```
c
 // Supprimer les shaders une fois liés
 glDeleteShader(vertexShader);
 glDeleteShader(fragmentShader);

```
c
 // Boucle principale
 while (!glfwWindowShouldClose(window))
 {
 glClearColor(0.1f, 0.1f, 0.2f, 1.0f);
 glClear(GL_COLOR_BUFFER_BIT);

```
c
 // Utiliser le shader et dessiner
 glUseProgram(shaderProgram);
 glBindVertexArray(VAO);
 glDrawArrays(GL_TRIANGLES, 0, 3);

```
 glfwSwapBuffers(window);
 glfwPollEvents();
 }

 glDeleteVertexArrays(1, &VAO);
 glDeleteBuffers(1, &VBO);

 glfwDestroyWindow(window);
 glfwTerminate();
```c
 return 0;
}
📦 Compilation
bash
Copier
Modifier
gcc -Wall -Wextra -Werror main.c -lglfw -lGL -lm -ldl -pthread -o mini3d
📚 Ce que tu fais dans ce code

```
Étape Action
Créer Vertex Shader Pour positionner les points
Créer Fragment Shader Pour colorer les pixels
Charger Vertex dans un VBO Stocker points en GPU
Configurer VAO Définir comment lire VBO
Boucle OpenGL Dessiner en continu
🎯 Mini plan d'action Partie 2
Préparer les vertex du triangle,

Compiler et lier shaders,

Envoyer les données vers la carte graphique,

Dessiner avec glDrawArrays().

📋 TDD minimal Bloc 8 Partie 2

Test Ce qui doit être visible
Lancer l'exécutable Fenêtre 800x600
Triangle vert clair centré ✅
Pas de crash au clic fermeture ✅

# Bloc 8 — Partie 3 — Charger un modèle 3D .obj
📚 Objectif immédiat
Tu vas :

Lire un fichier .obj très simple,

Extraire les positions des vertex,

Envoyer ces vertex à OpenGL,

Afficher le modèle 3D au lieu d'un simple triangle.

📋 Qu'est-ce qu'un fichier .obj ?
Un .obj (Wavefront OBJ) est un format texte simple contenant :

Les positions (v x y z),

Les faces (f v1 v2 v3) qui lient les vertex entre eux pour créer des triangles.

Exemple très basique :

plaintext
Copier
Modifier
v 0.0 0.5 0.0
v -0.5 -0.5 0.0
v 0.5 -0.5 0.0
f 1 2 3
(Un triangle exactement comme le précédent mais depuis un fichier.)

📚 Étapes pour charger un .obj

Étape Action
1 Lire les lignes du fichier texte
2 Récupérer les v (positions 3D)
3 Récupérer les f (faces, indices)
4 Générer un VBO/VAO OpenGL comme avant
5 Dessiner normalement
📦 Code simple pour lire un .obj
📋 Fonction basique pour parser .obj (model.c)
c
Copier
Modifier
```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include "model.h"

```
# define MAX_VERTICES 1000

void load_obj(const char *filename, float *vertices, int *vertex_count)
{
 FILE *file = fopen(filename, "r");
 if (!file)
 {
 perror("fopen");
 exit(EXIT_FAILURE);
 }

```c
 char line[128];
 int count = 0;

```
 while (fgets(line, sizeof(line), file))
 {
 if (line[0] == 'v' && line[1] == ' ')
 {
 float x, y, z;
 sscanf(line, "v %f %f %f", &x, &y, &z);
 vertices[count++] = x;
 vertices[count++] = y;
 vertices[count++] = z;
 }
 }

 fclose(file);
 *vertex_count = count / 3; // Chaque vertex = 3 floats
}
📋 Header associé (model.h)
c
Copier
Modifier
# ifndef MODEL_H
# define MODEL_H

```c
void load_obj(const char *filename, float *vertices, int *vertex_count);

```
# endif
📚 Comment utiliser ça dans main.c
📋 Ajout dans main.c
Remplacer la définition du tableau vertices[] par une lecture .obj.

Exemple :

c
Copier
Modifier
```c
# include "model.h"

```
float vertices[MAX_VERTICES];
```c
int vertex_count;

```
load_obj("triangle.obj", vertices, &vertex_count);

```c
// Puis envoyer les vertices comme avant
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, vertex_count * 3 * sizeof(float), vertices, GL_STATIC_DRAW);
Et pour dessiner :

```
c
Copier
Modifier
glDrawArrays(GL_TRIANGLES, 0, vertex_count);
📚 Important

Point À retenir
Un .obj peut contenir énormément de vertex Utiliser un tableau assez grand
Cette méthode lit uniquement positions, pas couleurs, pas normales, pas textures (ça viendra plus tard)
Chaque f doit être triangulaire (f 1 2 3) pour ce parseur simplifié 
📋 Exemple fichier triangle.obj
(À créer dans ton projet !)

plaintext
Copier
Modifier
v 0.0 0.5 0.0
v -0.5 -0.5 0.0
v 0.5 -0.5 0.0
f 1 2 3
🎯 Mini plan d'action Partie 3
Créer model.c + model.h,

Charger un .obj simple,

Lier dans ton pipeline OpenGL,

Dessiner dynamiquement un modèle.

📋 TDD minimal Bloc 8 Partie 3

Test Ce qui doit être visible
Fenêtre s'ouvre ✅
Modèle du .obj affiché (triangle) ✅
Aucune fuite mémoire / crash ✅

# Bloc 8 — Partie 4 — Déplacement et contrôle de caméra (FPS / Orbitale)
📚 Objectif immédiat
Tu vas :

Implémenter une caméra contrôlable par clavier (WASD) et souris,

Pouvoir te déplacer autour de ton modèle,

Découvrir les matrices de transformation 3D (MVP: Model-View-Projection).

📋 Concepts à comprendre ici

Terme Description
View Matrix Position et orientation de la caméra dans le monde
Projection Matrix Comment convertir 3D → 2D sur ton écran
WASD Déplacement sur les axes
Matrices Mathématiques pour manipuler les points en espace 3D
📦 Outils utilisés

Bibliothèque Utilité
GLFW Détection clavier / souris
GLM (option) Bibliothèque de maths 3D en C (peut être optionnel pour débuter)
(Tu peux commencer sans GLM avec tes propres fonctions, plus tard on optimisera.)

📚 Comment fonctionne une caméra simple
Stocke sa position (x, y, z),

Stocke sa direction (regard, angle yaw/pitch),

Déplace la position selon les touches clavier,

Change la direction avec la souris.

📋 Base de structure camera.h
c
Copier
Modifier
# ifndef CAMERA_H
# define CAMERA_H

typedef struct s_camera
{
 float pos_x, pos_y, pos_z;
 float yaw, pitch;
 float speed;
 float sensitivity;
} t_camera;

```c
void init_camera(t_camera *camera);
void process_keyboard(t_camera *camera, int key);
void process_mouse(t_camera *camera, double xoffset, double yoffset);
void get_view_matrix(t_camera *camera, float *view);

```
# endif
📋 Exemple d'implémentation rapide camera.c
c
Copier
Modifier
```c
# include "camera.h"
# include <math.h>

```
void init_camera(t_camera *camera)
{
 camera->pos_x = 0.0f;
 camera->pos_y = 0.0f;
 camera->pos_z = 3.0f;
 camera->yaw = -90.0f;
 camera->pitch = 0.0f;
 camera->speed = 0.05f;
 camera->sensitivity = 0.1f;
}

void process_keyboard(t_camera *camera, int key)
{
 float front_x = cosf(camera->yaw * (3.14159f/180.0f));
 float front_z = sinf(camera->yaw * (3.14159f/180.0f));

 if (key == GLFW_KEY_W)
 {
 camera->pos_x += front_x * camera->speed;
 camera->pos_z += front_z * camera->speed;
 }
 if (key == GLFW_KEY_S)
 {
 camera->pos_x -= front_x * camera->speed;
 camera->pos_z -= front_z * camera->speed;
 }
 if (key == GLFW_KEY_A)
 {
 camera->pos_x -= front_z * camera->speed;
 camera->pos_z += front_x * camera->speed;
 }
 if (key == GLFW_KEY_D)
 {
 camera->pos_x += front_z * camera->speed;
 camera->pos_z -= front_x * camera->speed;
 }
}

```c
// (Version simplifiée - souris plus tard !)
📚 Comment brancher dans main.c
📋 Ajout dans boucle principale
c
Copier
Modifier
if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
 process_keyboard(&camera, GLFW_KEY_W);
if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
 process_keyboard(&camera, GLFW_KEY_S);
if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
 process_keyboard(&camera, GLFW_KEY_A);
if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
 process_keyboard(&camera, GLFW_KEY_D);
📦 Modification de ta View Matrix (affichage)
➔ Tu dois recalculer la matrice de vue à chaque frame selon la position de ta caméra.

```
(On ajoutera get_view_matrix() dans Partie 5 avec matrices propres.)

📋 Résultat attendu

Action Résultat
Appuyer sur W Avancer dans la scène
Appuyer sur S Reculer
Appuyer sur A/D Se déplacer à gauche/droite
Souris (plus tard) Bouger la vue
🎯 Mini plan d'action Partie 4
Créer camera.h + camera.c,

Stocker position et angles de la caméra,

Implémenter WASD simple,

Mettre à jour à chaque frame dans ta boucle.

📋 TDD minimal Bloc 8 Partie 4

Test Ce qui doit marcher
Touche W/S/A/D Déplacement visible (pour l'instant simple)
Pas de crash sur input clavier ✅
Caméra déplacée chaque frame ✅

# Bloc 8 — Partie 5 — Caméra FPS complète (Yaw, Pitch, Matrices 3D)
📚 Objectif immédiat
Tu vas :

Permettre de contrôler la caméra avec la souris (orientation libre),

Générer la vraie vue 3D via une matrice de vue (View Matrix),

Fusionner le tout pour un déplacement fluide et naturel.

📋 Concepts essentiels ici

Terme Description
Yaw Rotation horizontale (gauche/droite)
Pitch Rotation verticale (haut/bas)
View Matrix Transforme la scène par rapport à la caméra
LookAt Fonction spéciale qui construit la vue
📚 Comment ça marche concrètement

Action Conséquence
Déplacer la souris à droite La caméra tourne à droite
Déplacer la souris en haut La caméra regarde vers le haut
Matrice vue Calcule les bonnes transformations automatiquement
📋 Mise à jour de camera.h
c
Copier
Modifier
# ifndef CAMERA_H
# define CAMERA_H

typedef struct s_camera
{
 float pos_x, pos_y, pos_z;
 float front_x, front_y, front_z;
 float up_x, up_y, up_z;
 float yaw, pitch;
 float speed;
 float sensitivity;
} t_camera;

```c
void init_camera(t_camera *camera);
void process_keyboard(t_camera *camera, int key);
void process_mouse(t_camera *camera, float xoffset, float yoffset);
void get_view_matrix(t_camera *camera, float *view);

```
# endif
📚 Dans camera.c
📋 Initialisation complète
c
Copier
Modifier
void init_camera(t_camera *camera)
{
 camera->pos_x = 0.0f;
 camera->pos_y = 0.0f;
 camera->pos_z = 3.0f;
 camera->front_x = 0.0f;
 camera->front_y = 0.0f;
 camera->front_z = -1.0f;
 camera->up_x = 0.0f;
 camera->up_y = 1.0f;
 camera->up_z = 0.0f;
 camera->yaw = -90.0f;
 camera->pitch = 0.0f;
 camera->speed = 0.05f;
 camera->sensitivity = 0.1f;
}
📋 Gestion du clavier
(Déjà fait partie 4, à améliorer ensuite si besoin)

📋 Gestion de la souris
c
Copier
Modifier
```c
# include <math.h>

```
void process_mouse(t_camera *camera, float xoffset, float yoffset)
{
 xoffset *= camera->sensitivity;
 yoffset *= camera->sensitivity;

 camera->yaw += xoffset;
 camera->pitch += yoffset;

```c
 // Limiter le pitch pour éviter de retourner
 if (camera->pitch > 89.0f)
 camera->pitch = 89.0f;
 if (camera->pitch < -89.0f)
 camera->pitch = -89.0f;

```
c
 // Calculer la nouvelle direction
 camera->front_x = cosf(camera->yaw * (3.14159f/180.0f)) * cosf(camera->pitch * (3.14159f/180.0f));
 camera->front_y = sinf(camera->pitch * (3.14159f/180.0f));
 camera->front_z = sinf(camera->yaw * (3.14159f/180.0f)) * cosf(camera->pitch * (3.14159f/180.0f));
}
📋 Calcul de la View Matrix (sans GLM)
c
Copier
Modifier
void get_view_matrix(t_camera *camera, float *view)
{
 // (Construction d'une matrice LookAt simplifiée)
 // À coder en détail dans Partie 6 pour la rendre propre !

```
c
 // Ici pour l'instant ➔ on mettra un appel "dummy" pour se préparer
}
📚 Dans main.c
📋 Ajout du callback souris
Avant la boucle principale :

```
c
Copier
Modifier
glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
(Cache et capture la souris dans la fenêtre.)

Définir un callback :

c
Copier
Modifier
void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{
 static float lastX = WIDTH / 2.0f;
 static float lastY = HEIGHT / 2.0f;
```c
 static int firstMouse = 1;
 float xoffset, yoffset;

```
 if (firstMouse)
 {
 lastX = xpos;
 lastY = ypos;
 firstMouse = 0;
 }

 xoffset = xpos - lastX;
 yoffset = lastY - ypos; // inversé car coordonnée écran différente

 lastX = xpos;
 lastY = ypos;

 process_mouse(&camera, xoffset, yoffset);
}
L'enregistrer :

c
Copier
Modifier
glfwSetCursorPosCallback(window, mouse_callback);
📋 Résultat attendu

Action Résultat
Bouger souris droite/gauche Tourner caméra horizontalement
Bouger souris haut/bas Monter/descendre vue
Déplacer avec W/A/S/D Se déplacer librement dans la scène
🎯 Mini plan d'action Partie 5
Ajouter process_mouse() pour yaw/pitch,

Capturer mouvement souris,

Mettre à jour front direction caméra,

Bouger librement dans la scène 3D.

📋 TDD minimal Bloc 8 Partie 5

Test Ce qui doit fonctionner
Bouger la souris Tourner la vue
Déplacer avec W/A/S/D Se déplacer tout en conservant la vue
Aucune inversion bizarre ✅
Fluide et naturel ✅

# Bloc 8 — Partie 6 — View Matrix (LookAt) + Perspective Projection
📚 Objectif immédiat
Tu vas :

Générer une View Matrix correcte basée sur ta position caméra,

Générer une Projection Matrix perspective (champ de vision réaliste),

Envoyer ces matrices aux shaders pour afficher ta scène 3D proprement.

📋 Concepts essentiels ici

Terme Description
View Matrix "Où est la caméra et où regarde-t-elle ?"
Projection Matrix "Comment voir en 3D sur un écran 2D (perspective)"
Uniforms Variables globales envoyées aux shaders depuis ton programme C
📚 Comment ça marche visuellement
mathematica
Copier
Modifier
World Space (3D) --> [View Matrix] --> Camera Space (relative) --> [Projection Matrix] --> Screen Space (2D)
📋 1. Construire la View Matrix (LookAt)
Nous allons créer notre propre fonction lookAt().

📋 Implémentation dans camera.c
c
Copier
Modifier
```c
# include <math.h>

```
void normalize(float *x, float *y, float *z)
{
 float length = sqrtf(*x * *x + *y * *y + *z * *z);
 if (length != 0)
 {
 *x /= length;
 *y /= length;
 *z /= length;
 }
}

void cross(float ax, float ay, float az, float bx, float by, float bz, float *rx, float *ry, float *rz)
{
 *rx = ay * bz - az * by;
 *ry = az * bx - ax * bz;
 *rz = ax * by - ay * bx;
}

void get_view_matrix(t_camera *camera, float *view)
{
 float center_x = camera->pos_x + camera->front_x;
 float center_y = camera->pos_y + camera->front_y;
 float center_z = camera->pos_z + camera->front_z;

 float f_x = center_x - camera->pos_x;
 float f_y = center_y - camera->pos_y;
 float f_z = center_z - camera->pos_z;
 normalize(&f_x, &f_y, &f_z);

 float s_x, s_y, s_z;
 cross(f_x, f_y, f_z, camera->up_x, camera->up_y, camera->up_z, &s_x, &s_y, &s_z);
 normalize(&s_x, &s_y, &s_z);

 float u_x, u_y, u_z;
 cross(s_x, s_y, s_z, f_x, f_y, f_z, &u_x, &u_y, &u_z);

```c
 // Matrice LookAt
 view[0] = s_x;
 view[1] = u_x;
 view[2] = -f_x;
 view[3] = 0.0f;

```
 view[4] = s_y;
 view[5] = u_y;
 view[6] = -f_y;
 view[7] = 0.0f;

 view[8] = s_z;
 view[9] = u_z;
 view[10] = -f_z;
 view[11] = 0.0f;

 view[12] = -(s_x * camera->pos_x + s_y * camera->pos_y + s_z * camera->pos_z);
 view[13] = -(u_x * camera->pos_x + u_y * camera->pos_y + u_z * camera->pos_z);
 view[14] = f_x * camera->pos_x + f_y * camera->pos_y + f_z * camera->pos_z;
 view[15] = 1.0f;
}
📋 2. Créer la Projection Matrix
➔ Perspective standard :

c
Copier
Modifier
void get_projection_matrix(float *projection, float fov, float aspect, float near, float far)
{
 float tan_half_fov = tanf(fov / 2.0f);

 projection[0] = 1.0f / (aspect * tan_half_fov);
 projection[1] = 0.0f;
 projection[2] = 0.0f;
 projection[3] = 0.0f;

 projection[4] = 0.0f;
 projection[5] = 1.0f / tan_half_fov;
 projection[6] = 0.0f;
 projection[7] = 0.0f;

 projection[8] = 0.0f;
 projection[9] = 0.0f;
 projection[10] = -(far + near) / (far - near);
 projection[11] = -1.0f;

 projection[12] = 0.0f;
 projection[13] = 0.0f;
 projection[14] = -(2.0f * far * near) / (far - near);
 projection[15] = 0.0f;
}
📚 Et dans main.c
📋 Envoyer les matrices aux shaders
Dans ta boucle principale (à chaque frame) :

c
Copier
Modifier
float view[16];
float projection[16];

get_view_matrix(&camera, view);
get_projection_matrix(projection, 45.0f * (3.14159f/180.0f), (float)WIDTH/(float)HEIGHT, 0.1f, 100.0f);

```c
// Maintenant tu dois envoyer view[] et projection[] aux shaders
📋 Ajout dans les shaders
📋 Vertex shader amélioré
glsl
Copier
Modifier
# version 330 core
layout (location = 0) in vec3 aPos;

```
uniform mat4 view;
uniform mat4 projection;

void main()
{
 gl_Position = projection * view * vec4(aPos, 1.0);
}
📚 Envoi côté C (OpenGL)
Après glUseProgram(shaderProgram) :

c
Copier
Modifier
```c
int viewLoc = glGetUniformLocation(shaderProgram, "view");
int projLoc = glGetUniformLocation(shaderProgram, "projection");

```
glUniformMatrix4fv(viewLoc, 1, GL_FALSE, view);
glUniformMatrix4fv(projLoc, 1, GL_FALSE, projection);
📋 Résultat attendu

Action Effet
Déplacer caméra La vue change en 3D naturellement
Bouger souris Tourner le regard dans toutes les directions
Perspective réaliste ✅
🎯 Mini plan d'action Partie 6
Coder get_view_matrix() et get_projection_matrix(),

Ajouter uniforms dans shaders,

Envoyer view et projection matrices à chaque frame,

Tester en volant dans ta scène !

📋 TDD minimal Bloc 8 Partie 6

Test Ce qui doit fonctionner
Déplacement avec profondeur visible ✅
Rotation caméra fluide ✅
Effet de perspective correct ✅
Aucun artefact graphique ✅

# Bloc 8 — Partie 7 — Ajouter un éclairage simple (Phong Lighting)
📚 Objectif immédiat
Tu vas :

Simuler la lumière sur tes modèles,

Calculer des ombres douces et brillances,

Utiliser les normales pour rendre ta scène réaliste.

📋 Concepts essentiels ici

Terme Description
Normale Vecteur perpendiculaire à une surface, utilisé pour l'éclairage
Phong Lighting Modèle qui combine: Ambient + Diffuse + Specular light
Shader Lighting Tous les calculs de lumière sont faits dans le vertex shader ou fragment shader
📚 Rappel du modèle Phong

Terme Effet
Ambient Lumière de base qui vient de partout
Diffuse Lumière directe sur une surface orientée vers la source
Specular Reflet brillant selon la position de l'observateur
📋 1. Étendre les Vertex pour contenir des normales
📋 Nouveau tableau vertex
Chaque sommet aura :

3 coordonnées (x, y, z),

3 normales (nx, ny, nz).

Exemple :

c
Copier
Modifier
float vertices[] = {
```c
 // positions // normales
 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f,
 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f,
 0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f
};
(normales pointant vers l'avant Z+ pour un triangle plat)

```
📋 Mise à jour VAO/VBO
Dans main.c :

c
Copier
Modifier
```c
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

```
c
// Deuxième attribut: normales
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);
📋 2. Modifier tes Shaders
📋 Vertex Shader (basic.vert)
glsl
Copier
Modifier
# version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

```
out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
 FragPos = vec3(model * vec4(aPos, 1.0));
 Normal = mat3(transpose(inverse(model))) * aNormal; // transformation normale
 gl_Position = projection * view * vec4(FragPos, 1.0);
}
📋 Fragment Shader (basic.frag)
glsl
Copier
Modifier
# version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
```c
 // Ambient
 float ambientStrength = 0.1;
 vec3 ambient = ambientStrength * lightColor;

```
c
 // Diffuse
 vec3 norm = normalize(Normal);
 vec3 lightDir = normalize(lightPos - FragPos);
 float diff = max(dot(norm, lightDir), 0.0);
 vec3 diffuse = diff * lightColor;

```
c
 // Specular
 float specularStrength = 0.5;
 vec3 viewDir = normalize(viewPos - FragPos);
 vec3 reflectDir = reflect(-lightDir, norm);
 float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
 vec3 specular = specularStrength * spec * lightColor;

```
 vec3 result = (ambient + diffuse + specular) * objectColor;
 FragColor = vec4(result, 1.0);
}
📚 Côté C - envoyer les uniformes
Avant de dessiner chaque frame :

c
Copier
Modifier
```c
// Position de la lumière et de la caméra
int lightPosLoc = glGetUniformLocation(shaderProgram, "lightPos");
int viewPosLoc = glGetUniformLocation(shaderProgram, "viewPos");
int lightColorLoc = glGetUniformLocation(shaderProgram, "lightColor");
int objectColorLoc = glGetUniformLocation(shaderProgram, "objectColor");

```
glUniform3f(lightPosLoc, 1.2f, 1.0f, 2.0f);
glUniform3f(viewPosLoc, camera.pos_x, camera.pos_y, camera.pos_z);
glUniform3f(lightColorLoc, 1.0f, 1.0f, 1.0f); // lumière blanche
glUniform3f(objectColorLoc, 0.6f, 0.6f, 0.8f); // objet bleu/gris
📋 Résultat attendu

Action Résultat
Un triangle illuminé ✅
Plus lumineux quand il fait face à la lumière ✅
Réflexion spéculaire si angle correct ✅
Ombre douce sur les côtés ✅
🎯 Mini plan d'action Partie 7
Modifier vertices[] pour contenir des normales,

Modifier VAO/VBO pour lire position + normale,

Changer shaders pour utiliser Phong Lighting,

Envoyer toutes les nouvelles uniforms.

📋 TDD minimal Bloc 8 Partie 7

Test Ce qui doit marcher
Triangle éclairé avec nuances réalistes ✅
Déplacement caméra change la lumière perçue ✅
Rotation lumière → ombres différentes ✅
Brillance visible sur bons angles ✅

# Bloc 8 — Partie 8 — Textures sur les modèles 3D (JPG/PNG)
📚 Objectif immédiat
Tu vas :

Charger une image (JPG ou PNG),

L'envoyer à la carte graphique comme texture,

Mapper correctement cette texture sur tes modèles 3D.

📋 Concepts essentiels ici

Terme Description
UV Mapping Chaque vertex reçoit des coordonnées 2D (u,v) pour mapper la texture
Texture Unit Emplacement mémoire pour lier une image sur GPU
Sampler2D Type spécial dans les shaders pour accéder aux textures
📚 Comment ça fonctionne

Étape Description
Charger une image Obtenir un tableau de pixels
Créer une texture OpenGL Transférer l'image sur la carte graphique
Ajouter coordonnées UV aux vertex Dire à OpenGL comment appliquer l'image
Utiliser un sampler2D dans le fragment shader Lire la couleur correspondante pour chaque pixel
📋 1. Ajouter des coordonnées UV aux vertex
📋 Nouveau tableau de vertex
Chaque sommet aura :

3 positions (x, y, z),

3 normales (nx, ny, nz),

2 UVs (u, v).

Exemple :

c
Copier
Modifier
float vertices[] = {
```c
 // pos // normal // texcoords
 0.5f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, // top right
 0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, // bottom right
 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom left
 -0.5f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f // top left 
};
unsigned int indices[] = { 0, 1, 3, 1, 2, 3 };
(Cette fois, 4 vertices et 2 triangles pour former un carré.)

```
📋 Mise à jour VAO/VBO
c
Copier
Modifier
```c
// pos
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

```
c
// normal
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);

```
c
// texcoords
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
glEnableVertexAttribArray(2);
📋 2. Charger l'image en C
Utiliser la lib simple stb_image.h (gratuite et légère).

```
📋 Ajouter stb_image.h
Télécharger stb_image.h :
https://raw.githubusercontent.com/nothings/stb/master/stb_image.h

Dans un fichier .c :

c
Copier
Modifier
# define STB_IMAGE_IMPLEMENTATION
```c
# include "stb_image.h"
📋 Créer une texture OpenGL
c
Copier
Modifier
unsigned int texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);

```
c
// Paramètres de texture
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

```
c
// Charger l'image
int width, height, nrChannels;
unsigned char *data = stbi_load("textures/mon_image.jpg", &width, &height, &nrChannels, 0);
if (data)
{
 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
 glGenerateMipmap(GL_TEXTURE_2D);
}
else
{
 printf("❌ Erreur chargement texture\n");
}
stbi_image_free(data);
📋 3. Modifier tes shaders
📋 Vertex Shader (ajouter TexCoords)
glsl
Copier
Modifier
layout (location = 2) in vec2 aTexCoords;

```
out vec2 TexCoords;

void main()
{
 TexCoords = aTexCoords;
 gl_Position = projection * view * vec4(aPos, 1.0);
}
📋 Fragment Shader (utiliser sampler2D)
glsl
Copier
Modifier
in vec2 TexCoords;

uniform sampler2D texture1;

void main()
{
 vec3 texColor = texture(texture1, TexCoords).rgb;
 FragColor = vec4(texColor, 1.0);
}
📋 4. Côté C - Activer la texture
Avant de dessiner :

c
Copier
Modifier
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture);

```c
// Puis utiliser le shader
glUseProgram(shaderProgram);
glUniform1i(glGetUniformLocation(shaderProgram, "texture1"), 0);
📋 Résultat attendu

```
Action Résultat
Fenêtre s'ouvre ✅
Un carré affichant l'image comme texture ✅
Déplacement et rotation possibles ✅
🎯 Mini plan d'action Partie 8
Modifier tes vertex pour contenir UV,

Charger une texture avec stb_image.h,

Lier la texture dans OpenGL,

Modifier shaders pour afficher textures,

Tester en déplaçant caméra.

📋 TDD minimal Bloc 8 Partie 8

Test Ce qui doit marcher
Texture chargée correctement ✅
Texture visible sur le modèle ✅
Déplacement caméra montre la texture sous différents angles ✅
Aucun crash même si image manquante ✅

# Bloc 8 — Partie 9 — Créer une Skybox 3D
📚 Objectif immédiat
Tu vas :

Créer une Skybox (un "cube géant" texturé autour de ton monde),

Donner l'impression d'un univers immense,

Utiliser une cubemap (6 images pour le ciel).

📋 Concepts essentiels ici

Terme Description
Skybox Un cube immense avec une image de ciel sur chaque face
Cubemap Texture spéciale composée de 6 faces pour le cube
Projections La Skybox est dessinée sans translation (elle suit la caméra sans déplacement)
📚 Comment fonctionne une Skybox

Action Ce qui se passe
Dessiner un cube autour de la caméra ✅
Appliquer une cubemap comme texture ✅
Désactiver translation dans la view matrix ✅
Toujours dessiner la Skybox en premier ✅
📋 1. Créer ton modèle de Skybox (Cube)
📋 Vertices pour un cube
c
Copier
Modifier
float skyboxVertices[] = {
```c
 // positions 
 -1.0f, 1.0f, -1.0f,
 -1.0f, -1.0f, -1.0f,
 1.0f, -1.0f, -1.0f,
 1.0f, -1.0f, -1.0f,
 1.0f, 1.0f, -1.0f,
 -1.0f, 1.0f, -1.0f,

```
 -1.0f, -1.0f, 1.0f,
 -1.0f, -1.0f, -1.0f,
 -1.0f, 1.0f, -1.0f,
 -1.0f, 1.0f, -1.0f,
 -1.0f, 1.0f, 1.0f,
 -1.0f, -1.0f, 1.0f,

 1.0f, -1.0f, -1.0f,
 1.0f, -1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, -1.0f,
 1.0f, -1.0f, -1.0f,

 -1.0f, -1.0f, 1.0f,
 -1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, -1.0f, 1.0f,
 -1.0f, -1.0f, 1.0f,

 -1.0f, 1.0f, -1.0f,
 1.0f, 1.0f, -1.0f,
 1.0f, 1.0f, 1.0f,
 1.0f, 1.0f, 1.0f,
 -1.0f, 1.0f, 1.0f,
 -1.0f, 1.0f, -1.0f,

 -1.0f, -1.0f, -1.0f,
 -1.0f, -1.0f, 1.0f,
 1.0f, -1.0f, -1.0f,
 1.0f, -1.0f, -1.0f,
 -1.0f, -1.0f, 1.0f,
 1.0f, -1.0f, 1.0f
};
📋 2. Charger une Cubemap
📋 Créer une Cubemap OpenGL
c
Copier
Modifier
```c
unsigned int cubemapTexture;
glGenTextures(1, &cubemapTexture);
glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);

```
c
int width, height, nrChannels;
unsigned char *data;
char *faces[6] = {
 "skybox/right.jpg",
 "skybox/left.jpg",
 "skybox/top.jpg",
 "skybox/bottom.jpg",
 "skybox/front.jpg",
 "skybox/back.jpg"
};

```
c
for (unsigned int i = 0; i < 6; i++)
{
 data = stbi_load(faces[i], &width, &height, &nrChannels, 0);
 if (data)
 {
 glTexImage2D(
 GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 
 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data
 );
 stbi_image_free(data);
 }
 else
 {
 printf("❌ Erreur chargement skybox: %s\n", faces[i]);
 stbi_image_free(data);
 }
}

```
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
📋 3. Shader pour Skybox
📋 Vertex Shader (skybox.vert)
glsl
Copier
Modifier
# version 330 core
layout (location = 0) in vec3 aPos;

out vec3 TexCoords;

uniform mat4 view;
uniform mat4 projection;

void main()
{
 TexCoords = aPos;
 vec4 pos = projection * view * vec4(aPos, 1.0);
 gl_Position = pos.xyww;
}
📋 Fragment Shader (skybox.frag)
glsl
Copier
Modifier
# version 330 core
out vec4 FragColor;

in vec3 TexCoords;

uniform samplerCube skybox;

void main()
{
 FragColor = texture(skybox, TexCoords);
}
📋 4. Affichage spécial pour la Skybox
Changer ta View Matrix pour enlever la position caméra: ➔ utiliser seulement la rotation.

c
Copier
Modifier
mat4 view = mat4(mat3(viewMatrix)); // Supprimer la translation
Désactiver le depth writing temporairement avant de dessiner la Skybox :

c
Copier
Modifier
glDepthFunc(GL_LEQUAL);
drawSkybox();
glDepthFunc(GL_LESS);
📋 Résultat attendu

Action Résultat
Fenêtre s'ouvre ✅
Ciel visible tout autour ✅
Tourner la caméra Le ciel bouge naturellement
Déplacer la caméra Le ciel reste à la même distance (infini)
🎯 Mini plan d'action Partie 9
Créer VAO/VBO pour cube skybox,

Charger 6 faces cubemap,

Modifier viewMatrix pour Skybox,

Dessiner Skybox avant tout autre élément.

📋 TDD minimal Bloc 8 Partie 9

Test Ce qui doit fonctionner
Skybox visible au démarrage ✅
Pas d'artefacts visuels ✅
Rotation caméra fluide sur ciel ✅
Déplacement caméra ne change pas la Skybox ✅

# Bloc 8 — Finalisation du moteur 3D
📚 Résumé rapide de ce que tu sais désormais faire

Module Ce que tu maîtrises
OpenGL setup Créer et gérer des fenêtres OpenGL en C
Affichage 3D Dessiner des modèles (triangles, objets)
Contrôle caméra Clavier + souris pour vue libre FPS
Shaders Créer vertex et fragment shaders modernes
Lighting Implémenter un éclairage Phong complet
Textures Charger et afficher des images sur des modèles
Skybox Entourer ta scène d'un univers infini avec cubemap
📋 Structure de projet final
Voici comment ton moteur 3D est proprement structuré :

plaintext
Copier
Modifier
mini_3d_engine/
├── src/
│ ├── main.c # Boucle principale
│ ├── window.c / .h # Fenêtre GLFW
│ ├── shader.c / .h # Shaders (load, compile, use)
│ ├── camera.c / .h # Gestion de la caméra
│ ├── model.c / .h # Chargement des modèles (.obj simplifié)
│ ├── skybox.c / .h # Chargement + affichage de Skybox
│ ├── texture.c / .h # Gestion des textures
├── include/
│ ├── Tous les .h
├── shaders/
│ ├── basic.vert
│ ├── basic.frag
│ ├── skybox.vert
│ ├── skybox.frag
├── textures/
│ ├── images (.jpg / .png)
│ ├── skybox faces
├── Makefile
├── README.md (explication du projet)
📋 To-do pour un projet prêt à livrer

À faire Explication
Makefile ultra propre Avec targets all, clean, fclean, re
README.md clair Expliquer installation + commandes principales
Arborescence fichiers clean src/, shaders/, textures/, include/
Rendu stable Pas de crash même si ressource manquante
Norme C (si applicable) Bonus pour style professionnel
🎯 Mini bilan final
✅ Tu as recréé manuellement tout ce qu'un moteur de base propose :

OpenGL core,

Gestion camera FPS,

Lighting Phong,

Skybox environnement,

Chargement d'objets + textures.

C'est à 80% de ce qu'un moteur minimal commercial style "Godot Engine Core" pourrait représenter !

🏆 En bonus tu peux ajouter après :

Idée bonus Complexité
Charger des modèles .obj complexes avec textures UV complètes 🧠🧠
Gérer l'animation (skeletal / bones) 🧠🧠🧠
Optimiser en utilisant VBO/VAO/UBO avancés 🧠🧠
Ajout d'un vrai système de collisions 🧠🧠
Shadow mapping (ombres dynamiques) 🧠🧠🧠

🧩 Module 14 — threads/ — Programmation multithreadée avec pthread [🧵 Niveau Avancé]
📦 Module threads/ — Multithreading, synchronisation, et gestion de la concurrence en C
🎯 Objectif pédagogique
Ce module t’apprend à écrire des programmes concurrents et synchronisés, grâce à la bibliothèque POSIX pthread. Tu vas apprendre à :

Créer et gérer des threads

Synchroniser leur accès avec des mutex, sémaphores, barrières

Identifier et résoudre les race conditions

Implémenter des workers, des pipelines, ou des problèmes classiques (producteurs/consommateurs, lecteurs/écrivains)

📚 Concepts abordés
✅ 1. pthread_create, pthread_join
c
Copier
Modifier
pthread_t tid;
pthread_create(&tid, NULL, my_function, arg);
pthread_join(tid, NULL);
→ Lance un thread qui exécute une fonction en parallèle.

✅ 2. Variables partagées et problèmes de concurrence
c
Copier
Modifier
int global = 0;
void *f(void *arg) { global++; }
→ Plusieurs threads modifiant global → comportement indéfini, race condition.

✅ 3. Mutex (pthread_mutex_t)
c
Copier
Modifier
pthread_mutex_lock(&m);
global++;
pthread_mutex_unlock(&m);
→ Protège les sections critiques.

✅ 4. Sémaphores (sem_t)
c
Copier
Modifier
sem_wait(&sem);
critical_section();
sem_post(&sem);
→ Limite l’accès à une ressource partagée à N threads.

✅ 5. Autres outils
pthread_detach() : laisse un thread s’auto-libérer

pthread_cond_t : conditionnelles

Barrières (pthread_barrier_t) : synchroniser plusieurs threads à un point donné

🧪 Exercices
📂 threads/ex00 — Créer 3 threads et les faire travailler
Créer 3 threads qui affichent un message en parallèle. Utiliser pthread_create et pthread_join.

📂 threads/ex01 — Incrémentation concurrente
Incrémenter une variable globale depuis 100 threads.
Sans mutex → observer le résultat incorrect.

📂 threads/ex02 — Corriger avec mutex
Ajouter un pthread_mutex_t pour rendre l’incrémentation sûre.

📂 threads/ex03 — Problème producteur / consommateur
Implémenter un buffer partagé avec un producteur et un consommateur, synchronisés via mutex et conditionnelle.

📂 threads/ex04 — Exécution en tâche de fond (detach)
Créer un thread détaché qui affiche une animation, pendant que le programme principal continue.

🛠️ Bonus
Réaliser une file de tâches (worker pool)

Implémenter un serveur multi-threads

Créer un compteur de mots multi-threadé sur gros fichier texte

🧩 Module 15 — realtime/ — Simulation de systèmes temps réel et réactifs [⏱️ Niveau Avancé]
📦 Module realtime/ — Réagir en temps réel, simuler des systèmes vivants ou synchrones
🎯 Objectif pédagogique
Ce module t’apprend à créer des systèmes qui réagissent au temps ou à des événements, en simulant le comportement temps réel d’un processus, d’un système embarqué ou d’un moteur logique. Tu vas :

Maîtriser les délais, les rafraîchissements cadencés, la synchronisation au temps système

Implémenter des états évolutifs et des réactions conditionnelles

Écrire des systèmes interactifs simples (ex: feux de circulation, moteurs, senseurs)

📚 Concepts abordés
✅ 1. Boucle temps réel / boucle de simulation
c
Copier
Modifier
while (1) {
    update_state();
    render();
    usleep(100000); // pause 100 ms = 10 FPS
}
→ Boucle avec rythme fixe, appelée toutes les X ms.

✅ 2. gettimeofday, clock_gettime, time.h
Obtenir un timestamp (time(NULL))

Calculer un delta de temps

Attendre jusqu’à atteindre un instant donné

✅ 3. Événements temporels
Déclencher une action si une durée est dépassée :

c
Copier
Modifier
if (current_time - start_time > 5.0) {
    activate();
}
✅ 4. États dynamiques
Créer des automates à états finis (FSM) ou des timers logiques (ex : feux tricolores).

🧪 Exercices
📂 realtime/ex00 — Chronomètre basique
Afficher un compteur de secondes en temps réel.

📂 realtime/ex01 — Clignotement
Faire clignoter une LED (ASCII) toutes les 500 ms.

css
Copier
Modifier
[ ON ]
[OFF ]
📂 realtime/ex02 — Feu de circulation
Simuler un feu avec états VERT -> ORANGE -> ROUGE, chacun durant un temps précis.

📂 realtime/ex03 — Détecteur de seuil
Simuler un capteur : quand une variable dépasse un seuil pendant X secondes, déclencher une alerte.

📂 realtime/ex04 — Animation cadencée
Créer une boucle qui anime un ASCII art image par image à 10 FPS.

🛠️ Bonus
Créer une alarme programmable

Simuler un automate industriel

Intégrer la logique à un DSL ou un moteur d’agents




🧩 Module 11 — standard_c_lib/ — Réimplémenter les fonctions standards de la libc [📚 Niveau Moyen à Expert]
📦 Module standard_c_lib/ — Mieux comprendre la libc en la recréant soi-même
🎯 Objectif pédagogique
Ce module a pour but de désacraliser la bibliothèque standard (libc) en te faisant réécrire ses fonctions clés. Cela t’amène à :

Comprendre comment fonctionne la recherche, le tri, la tokenisation, etc.

Appliquer des concepts d’algorithmes sur des cas concrets

Découvrir des comportements subtils de fonctions très utilisées

Réduire ta dépendance aux bibliothèques

📚 Concepts abordés
✅ 1. qsort() — Tri générique
Réimplémentation d’un tri à comparaison, générique via void*, utilisant un pointeur vers fonction :

c
Copier
Modifier
void ft_qsort(void *base, size_t nmemb, size_t size,
              int (*compar)(const void *, const void *));
✅ 2. bsearch() — Recherche binaire
c
Copier
Modifier
void *ft_bsearch(const void *key, const void *base,
                 size_t nmemb, size_t size,
                 int (*compar)(const void *, const void *));
✅ 3. strtok() — Découpage d’une chaîne
c
Copier
Modifier
char *ft_strtok(char *str, const char *delim);
Gère un pointeur statique pour avancer dans la chaîne.

✅ 4. atoi() et itoa()
Conversion de chaîne vers entier (atoi), et entier vers chaîne (itoa).

✅ 5. memset, memcpy, memcmp
Manipulation de blocs mémoire bruts (void*).

🧪 Exercices
📂 standard_c_lib/ex00 — Réécrire ft_atoi()
Gérer :

signes + / -

espaces

overflow minimal (INT_MAX, INT_MIN)

📂 standard_c_lib/ex01 — Réécrire ft_strtok()
Créer une version capable de découper "a,b,c" avec "," comme séparateur.
⚠️ Gérer le pointeur statique.

📂 standard_c_lib/ex02 — Réécrire ft_qsort()
Tri générique de n’importe quel tableau (ex : int[], char*[]) avec une fonction de comparaison.

📂 standard_c_lib/ex03 — Réécrire ft_bsearch()
Recherche binaire dans un tableau trié, générique avec void*.

📂 standard_c_lib/ex04 — memcpy / memset / memcmp
Créer trois fonctions de manipulation mémoire bas-niveau.

🛠️ Bonus
Comparer performance ft_qsort vs qsort

Réécrire strchr, strrchr, strstr

Implémenter une mini-libc minimaliste embarquable




🧩 Module 7 — archi_prog/ — Architecture mémoire et compilation [🧠 Niveau Fondamental / Avancé]
📦 Module archi_prog/ — Comprendre l’architecture mémoire, la compilation et le linking [🧠 Fondamental]
🎯 Objectif pédagogique
Ce module est essentiel pour maîtriser le cycle de vie complet d’un programme C, depuis la source jusqu’à l’exécutable, en passant par les sections mémoire et le linking. Tu vas apprendre à :

Visualiser la mémoire (pile, heap, bss, data, text)

Suivre le cycle de compilation : .c → .o → exécutable

Comprendre le rôle du linker (édition de liens)

Créer et utiliser des librairies statiques (.a) et dynamiques (.so)

Manipuler et lire les métadonnées d’un binaire ELF

📚 Concepts abordés
✅ 1. Sections mémoire
Section Contenu
.text Code machine (fonctions compilées)
.data Variables globales initialisées
.bss  Variables globales non initialisées
heap  Mémoire dynamique (malloc)
stack Variables locales (pile)

🔍 À visualiser avec readelf -S ou objdump -h.

✅ 2. Cycle de compilation
bash
Copier
Modifier
gcc -c prog.c     # compilation → prog.o
gcc prog.o -o prog  # linking → exécutable
🔧 Distinguer :

Compilation (analyse + génération assembleur)

Assemblage (assembleur → binaire)

Linking (rassemble tous les objets)

✅ 3. Librairies statiques .a
bash
Copier
Modifier
ar rcs libmymath.a add.o sub.o
gcc main.c -L. -lmymath
→ Copiée dans l’exécutable au linking.

✅ 4. Librairies dynamiques .so
bash
Copier
Modifier
gcc -fPIC -shared -o libmymath.so add.o sub.o
gcc main.c -L. -lmymath
export LD_LIBRARY_PATH=.
→ Chargée dynamiquement à l’exécution.

✅ 5. Commandes utiles
nm prog : symboles

ldd prog : dépendances dynamiques

objdump -d prog : désassemblage

readelf -h prog : en-tête ELF

🧪 Exercices
📂 archi_prog/ex00 — Affichage des sections mémoire
Créer un programme avec :

c
Copier
Modifier
int global = 42;
static int stat = 0;
char *heap = malloc(10);
int main(void) {
    int local = 1;
    static int mystatic = 5;
}
Utiliser nm ou objdump pour repérer .data, .bss, .heap, .stack.

📂 archi_prog/ex01 — Compilation manuelle
Compiler manuellement en plusieurs étapes :

bash
Copier
Modifier
gcc -c part1.c
gcc -c part2.c
gcc part1.o part2.o -o final
📂 archi_prog/ex02 — Librairie statique
Créer un mini .a avec une fonction ft_add(), l’inclure dans un projet.

📂 archi_prog/ex03 — Librairie dynamique
Créer une .so partagée, puis exécuter un programme qui s’y relie dynamiquement.

📂 archi_prog/ex04 — Analyse ELF
Compiler un programme simple et afficher :

les sections ELF

les symboles

les adresses de fonctions

🛠️ Bonus possible
Désassembler un programme avec objdump -d

Créer un loader ELF minimal

Lire la pile après un crash (ulimit -c unlimited + gdb core)


🧩 Module 12 — preprocessor/ — Préprocesseur C, macros et portabilité [📎 Niveau Moyen à Avancé]
📦 Module preprocessor/ — Maîtriser les directives du préprocesseur et les macros C
🎯 Objectif pédagogique
Ce module t’initie à un des mécanismes fondamentaux du langage C, souvent mal compris : le préprocesseur. Tu vas :

Maîtriser les directives comme #define, #ifdef, #pragma, etc.

Créer des macros paramétrées et sûres

Gérer la portabilité avec des macros conditionnelles

Comprendre comment le compilateur voit vraiment ton code

📚 Concepts abordés
✅ 1. #define, #ifdef, #ifndef, #undef
c
Copier
Modifier
#define PI 3.1415
#ifdef DEBUG
    printf("Debug mode\n");
#endif
→ Permet de conditionner des morceaux de code à la compilation.

✅ 2. Macros avec paramètres
c
Copier
Modifier
#define SQUARE(x) ((x)*(x))
⚠️ Attention aux doubles évaluations : SQUARE(a++) → produit 2 incréments !

✅ 3. __FILE__, __LINE__, __DATE__, __TIME__
c
Copier
Modifier
printf("Erreur dans %s à la ligne %d\n", __FILE__, __LINE__);
→ Fournit des infos de debug compilées dans le binaire.

✅ 4. #pragma, #error, #warning
c
Copier
Modifier
#pragma once
#error "Cette version du compilateur n'est pas supportée"
→ Influence le comportement du compilateur.

✅ 5. Macros conditionnelles pour portabilité
c
Copier
Modifier
#ifdef _WIN32
    #define OS "Windows"
#elif __linux__
    #define OS "Linux"
#else
    #define OS "Inconnu"
#endif
→ Permet d’adapter le code aux plateformes (cross-compilation).

✅ 6. Inclusion sécurisée : Include guards
c
Copier
Modifier
#ifndef MY_HEADER_H
#define MY_HEADER_H

// code

#endif
→ Empêche les inclusions multiples.

🧪 Exercices
📂 preprocessor/ex00 — Définir une constante #define
Créer un programme qui utilise #define PI pour afficher la circonférence d’un cercle.

📂 preprocessor/ex01 — Macro SQUARE
Créer une macro SQUARE(x) et l’utiliser sur plusieurs expressions. Ajouter un printf(__LINE__).

📂 preprocessor/ex02 — Inclusion conditionnelle
Créer un fichier os_name.h qui définit une chaîne OS_NAME selon l’OS détecté (_WIN32, __linux__, __APPLE__...).

📂 preprocessor/ex03 — Utiliser #pragma et #error
Créer un fichier qui affiche une erreur si __STDC__ n’est pas défini (non standard C).

📂 preprocessor/ex04 — Include guard propre
Créer un fichier .h avec un #ifndef et une macro d’inclusion unique.

🛠️ Bonus
Réaliser une mini-lib portable avec détection automatique de l’OS

Créer une macro de logging stylée LOG(msg) qui affiche le message, le fichier, et la ligne





🧩 Module 8 — safety/ — Robustesse, sécurité mémoire, erreurs système [🛡️ Niveau Fondamental à Avancé]
📦 Module safety/ — Sécuriser un programme C et prévenir les erreurs critiques [🛡️ Sécurité & Robustesse]
🎯 Objectif pédagogique
Ce module t’apprend à écrire du code C robuste, sécurisé et prévisible, en anticipant :

Les dépassements de mémoire (buffer overflow)

Les erreurs systèmes (errno, perror, strerror)

Les comportements indéfinis (segfault, dangling pointer, etc.)

Les protections mémoire modernes (ASLR, stack canary, NX)

C’est le fondement de toute programmation fiable, notamment en systèmes embarqués, en sécurité, ou en réseau.

📚 Concepts abordés
✅ 1. Buffer overflow
c
Copier
Modifier
char buffer[8];
strcpy(buffer, "Ceci est trop long"); // Overflow → danger
→ Peut corrompre la pile, détourner l’exécution (ret2libc, etc.).

✅ 2. Segfault et undefined behavior
c
Copier
Modifier
char *ptr = NULL;
*ptr = 'a';  // SEGFAULT
→ Résultat : crash du programme ou comportement imprévisible.

✅ 3. Gestion des erreurs système : errno, perror, strerror
c
Copier
Modifier
#include <errno.h>
#include <stdio.h>
#include <string.h>
open("inexistant.txt", O_RDONLY);
perror("Erreur"); // Affiche le message d'erreur associé
✅ 4. Stack canary (protection contre overflow)
Activé via :

bash
Copier
Modifier
gcc -fstack-protector-all
→ Empêche l’écriture hors des variables locales de corrompre le retour d’une fonction.

✅ 5. ASLR (Address Space Layout Randomization)
Protection du système d’exploitation :

L’adresse de la pile change à chaque exécution

Empêche les attaques prévisibles basées sur les adresses

🔍 À tester via cat /proc/sys/kernel/randomize_va_space

🧪 Exercices
📂 safety/ex00 — Déclencher un buffer overflow
Écrire une fonction vulnérable (unsafe_copy()) et l’appeler avec une chaîne trop longue.
Afficher le crash attendu ou le comportement anormal.

📂 safety/ex01 — Corriger avec strncpy
Réécrire la fonction précédente avec strncpy() ou memcpy() + taille contrôlée.

📂 safety/ex02 — Lire et interpréter errno
Forcer une erreur (open("foo.txt") sur fichier inexistant), afficher errno avec perror() et strerror(errno).

📂 safety/ex03 — Crash volontaire (NULL pointer)
Créer un programme qui provoque un segfault, puis l’exécuter avec gdb pour afficher la backtrace.

📂 safety/ex04 — Compilation avec -fstack-protector
Compiler un programme vulnérable avec et sans -fstack-protector-all → observer la différence (protection détectée ou non).

🛠️ Bonus
Lire un core dump avec gdb core

Mesurer la robustesse avec valgrind ou AddressSanitizer

Comparer comportement avec ASLR activé/désactivé

🧩 Module 13 — dsl/ — Créer un langage interne (mini DSL) et son interpréteur [🧬 Niveau Avancé / Créatif]
📦 Module dsl/ — Créer un langage simple (DSL) et l'interpréteur associé en C
🎯 Objectif pédagogique
Ce module t’initie à la création d’un langage spécifique à ton programme (DSL — Domain Specific Language), et t’enseigne à :

Concevoir une grammaire simple (avec commandes print, goto, pause, etc.)

Écrire un interpréteur qui lit et exécute des scripts .txt

Structurer un état d’exécution, avec labels, variables, pointeurs d’instruction

Simuler des comportements de machines d’état ou scripts systèmes

📚 Concepts abordés
✅ 1. Structure d’un langage simple
Créer des instructions élémentaires comme :

arduino
Copier
Modifier
set A 42
print A
pause 1000
goto start
Chaque ligne est une commande, avec des arguments.

✅ 2. Interpréteur de ligne
Lire un fichier .dsl ligne par ligne avec fgets(), découper les mots avec strtok(), et exécuter dynamiquement l’action correspondante.

✅ 3. Système de labels et goto
Construire une map (label -> ligne) au chargement, pour pouvoir faire des sauts conditionnels dans le script.

✅ 4. Variables typées (int, string)
Gérer des variables stockées dans une table (char *name -> valeur) avec un petit système de type.

✅ 5. Machine d’état simple
Créer une structure :

c
Copier
Modifier
typedef struct {
    int running;
    int instruction_ptr;
    var_table_t vars;
} dsl_context_t;
L’interpréteur évolue ligne par ligne en manipulant cet état.

🧪 Exercices
📂 dsl/ex00 — Lire et interpréter print
Créer une fonction execute_line(char *line) qui reconnaît :

dsl
Copier
Modifier
print Hello
print 42
Et affiche le message brut.

📂 dsl/ex01 — Ajouter set et variables
Gérer :

dsl
Copier
Modifier
set A 10
print A
→ Implémenter une map var_name -> valeur (avec une struct dynamique).

📂 dsl/ex02 — Ajouter goto et label
Script :

dsl
Copier
Modifier
label start
print Start
goto start
Créer un interpréteur qui saute à une ligne nommée.

📂 dsl/ex03 — Ajouter pause
dsl
Copier
Modifier
pause 1000
→ Fait dormir l’interpréteur pendant 1000 ms avec usleep().

📂 dsl/ex04 — Ajouter if conditionnel
dsl
Copier
Modifier
set X 5
if X > 3 goto big
→ Comparer, et conditionner le saut.

🛠️ Bonus
Créer une commande input pour lire une valeur depuis le terminal

Ajouter un compteur de temps global (tick)

Autoriser les commentaires avec #




# Bloc 9 — Projet Graphique: Renderer PBR & Shaders avancés
📚 Objectif global
Ton moteur va évoluer pour :

Utiliser des shaders réalistes basés sur la physique réelle (PBR),

Gérer différents matériaux: métal, bois, pierre, etc.,

Ajouter plusieurs lumières dynamiques (point lights, directional lights),

Créer une architecture de moteur modulaire (Renderer, Assets, Scene, etc.).

📋 Concepts avancés à apprendre ici

Terme Description
PBR (Physically Based Rendering) Simule la vraie lumière du monde réel (réflexions, rugosité)
Albedo, Normal Map, Roughness Map, Metallic Map Images servant à décrire comment la lumière interagit avec chaque matériau
BRDF (Bidirectional Reflectance Distribution Function) Formule mathématique pour modéliser la lumière sur les surfaces
HDR (High Dynamic Range) Travailler avec des couleurs au-delà de 0.0–1.0 pour plus de réalisme
Gamma Correction Corriger la luminosité pour correspondre à la vision humaine
📋 Étapes principales du Bloc 9

Partie Objectif
9.1 Revoir structure OpenGL: modules Renderer, Asset Manager
9.2 Recréer pipeline shaders pour support PBR
9.3 Charger textures PBR (albedo, normal, roughness, metallic)
9.4 Éclairer avec plusieurs types de lumières dynamiques
9.5 Support HDR rendering et gamma correction
9.6 Scène test avec plusieurs objets et matériaux
9.7 Bonus: Ajout de réflexion de l'environnement (IBL - Image-Based Lighting)
📚 Architecture recommandée du moteur
plaintext
Copier
Modifier
engine/
├── src/
│ ├── main.c
│ ├── renderer/
│ │ ├── renderer.c/.h
│ │ ├── shader.c/.h
│ │ ├── camera.c/.h
│ │ ├── lighting.c/.h
│ ├── assets/
│ │ ├── model_loader.c/.h
│ │ ├── texture_loader.c/.h
│ ├── scene/
│ │ ├── scene.c/.h
├── shaders/
│ ├── pbr.vert
│ ├── pbr.frag
│ ├── skybox.vert
│ ├── skybox.frag
├── resources/
│ ├── models/
│ ├── textures/
│ │ ├── wood_albedo.png
│ │ ├── wood_normal.png
│ │ ├── wood_metallic.png
│ │ ├── wood_roughness.png
│ │ ├── skybox/
├── Makefile
├── README.md
📚 Ce que tu vas maîtriser à la fin de ce Bloc 9

Compétence Niveau
OpenGL avancé ✅✅✅
Shaders complexes ✅✅✅
Modélisation matériaux réalistes (PBR) ✅✅✅
HDR & Gamma Correction ✅✅
Asset management propre ✅✅
Préparation à Vulkan/DirectX ultérieurement ✅
📋 Mini preview du premier shader PBR (extrait simplifié)
glsl
Copier
Modifier
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
```c
 return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

```
void main()
{
 vec3 N = normalize(Normal);
 vec3 V = normalize(cameraPos - FragPos);
 vec3 L = normalize(lightPos - FragPos);

 vec3 H = normalize(V + L);

 float distance = length(lightPos - FragPos);
 float attenuation = 1.0 / (distance * distance);

 float NdotL = max(dot(N, L), 0.0);

 vec3 radiance = lightColor * attenuation;

```c
 // Cook-Torrance BRDF
 vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
 vec3 specular = ...; // (calcul complet à suivre)
 
```
c
 // Final color
 FragColor = vec4((ambient + diffuse + specular) * albedo, 1.0);
}
(On détaillera chaque élément très précisément au fur et à mesure.)

```
🎯 Plan immédiat
Bloc 9 Partie 1: Restructuration de ton moteur + prépa shaders PBR

Séparer proprement renderer/, assets/, scene/

Préparer shaders de base pour PBR

Tester que tout compile proprement en OpenGL 3.3+

# Bloc 9 — Partie 1 — Restructurer proprement ton moteur 3D
📚 Objectif immédiat
Tu vas :

Séparer proprement ton projet en modules clairs,

Préparer la structure Renderer / Assets / Scene,

Commencer à préparer les shaders PBR.

📋 Pourquoi restructurer ?

Raison Pourquoi c'est crucial
Lisibilité Tu sais tout de suite où trouver quoi
Maintenance Tu peux modifier Renderer sans toucher Assets
Scalabilité Tu peux ajouter facilement Skybox, Post-processing, Particules...
Propreté pro C'est ce que font tous les vrais moteurs (Unity, Unreal, Godot)
📋 Nouvelle Arborescence du Projet
plaintext
Copier
Modifier
mini_3d_engine/
├── src/
│ ├── main.c # Point d'entrée principal
│
│ ├── renderer/
│ │ ├── renderer.c/.h # Système global de rendu
│ │ ├── shader.c/.h # Chargement et utilisation de shaders
│ │ ├── camera.c/.h # Gestion caméra (FPS, Orbitale)
│ │ ├── lighting.c/.h # Gestion des lumières (point light, directional)
│
│ ├── assets/
│ │ ├── model_loader.c/.h # Chargement de modèles 3D (.obj, futur .gltf)
│ │ ├── texture_loader.c/.h # Chargement textures 2D et cubemaps
│
│ ├── scene/
│ │ ├── scene.c/.h # Gestion de la scène, des objets et transformations
│
├── shaders/
│ ├── pbr.vert # Vertex shader PBR
│ ├── pbr.frag # Fragment shader PBR
│ ├── skybox.vert
│ ├── skybox.frag
│
├── resources/
│ ├── models/
│ ├── textures/
│ │ ├── bois_albedo.png
│ │ ├── bois_normal.png
│ │ ├── bois_roughness.png
│ │ ├── bois_metallic.png
│ │ ├── skybox/
│ │ ├── right.jpg, left.jpg, etc.
│
├── include/
│ ├── Tous les headers (.h)
│
├── Makefile # Compilation
├── README.md # Explication du moteur
📋 Module par Module
📚 renderer/
renderer.c/.h ➔ Initialiser OpenGL, régler les modes, dessiner les scènes.

shader.c/.h ➔ Charger un shader depuis des fichiers .vert et .frag, le compiler et le linker.

camera.c/.h ➔ FPS + Orbit caméra.

lighting.c/.h ➔ Gérer types de lumières (directional, point lights, spotlights plus tard).

📚 assets/
model_loader.c/.h ➔ Lire .obj (et plus tard .gltf) ➔ envoyer dans VBO/VAO.

texture_loader.c/.h ➔ Charger images .png/.jpg via stb_image, création de textures.

📚 scene/
scene.c/.h ➔ Créer et gérer plusieurs objets (transformations individuelles, matériaux attachés, etc.).

📚 Makefile minimal prévu
Makefile
Copier
Modifier
NAME = mini3d

SRCS = src/main.c \
 src/renderer/renderer.c \
 src/renderer/shader.c \
 src/renderer/camera.c \
 src/renderer/lighting.c \
 src/assets/model_loader.c \
 src/assets/texture_loader.c \
 src/scene/scene.c

INCS = -Isrc -Iinclude
CC = gcc
CFLAGS = -Wall -Wextra -Werror -g
LIBS = -lglfw -lGL -ldl -lm -pthread

OBJ = $(SRCS:.c=.o)

all: $(NAME)

$(NAME): $(OBJ)
 $(CC) $(CFLAGS) $(OBJ) -o $(NAME) $(LIBS)

clean:
 rm -f $(OBJ)

fclean: clean
 rm -f $(NAME)

re: fclean all
📋 Tâches immédiates après restructuration

À faire Explication
Migrer camera.c, shader.c, etc. dans renderer/ ✅
Créer assets/ et scene/ même vide pour l'instant ✅
S'assurer que make re fonctionne sans erreur ✅
🎯 Mini plan d'action Bloc 9 Partie 1
Restructurer tout le projet selon l'architecture ci-dessus,

Corriger les includes (# include "renderer/shader.h", etc.),

Adapter ton Makefile proprement,

Valider compilation (make, pas d'erreur),

Préparer pour Bloc 9 Partie 2: Premier Shader PBR !

📋 TDD minimal Bloc 9 Partie 1

Test Ce qui doit marcher
make re fonctionne et lance ton moteur ✅
Organisation des fichiers clean et respectée ✅
Aucun warning ou erreur ✅

# Bloc 9 — Partie 2 — Premier Shader PBR (Physically Based Rendering)
📚 Objectif immédiat
Tu vas :

Comprendre la structure d'un shader PBR,

Écrire un vertex shader pour préparer les données,

Écrire un fragment shader pour le calcul réaliste de la lumière,

Tester ton premier rendu réaliste avec réflexions et matériaux physiques.

📋 Rappel rapide sur PBR

Élément Rôle
Albedo Couleur de base de l'objet (diffuse)
Metallic Indique si la surface est métallique (1.0) ou non (0.0)
Roughness Détermine la "rugosité" de la surface (lisse ou mate)
Normal Influence la direction des réflexions locales
F0 (Fresnel) Réflexion au contact entre matériaux différents
📋 Organisation rapide
shaders/pbr.vert

shaders/pbr.frag

📋 1. Vertex Shader PBR (pbr.vert)
glsl
Copier
Modifier
# version 330 core

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
 FragPos = vec3(model * vec4(aPos, 1.0));
 Normal = mat3(transpose(inverse(model))) * aNormal;
 TexCoords = aTexCoords;
 gl_Position = projection * view * vec4(FragPos, 1.0);
}
📋 2. Fragment Shader PBR (pbr.frag)
Version simplifiée pour commencer (une seule lumière, pas encore d'IBL) :

glsl
Copier
Modifier
# version 330 core

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

```c
// Matériaux
uniform sampler2D albedoMap;
uniform sampler2D normalMap;
uniform sampler2D metallicMap;
uniform sampler2D roughnessMap;

```
c
// Lumière
uniform vec3 lightPos;
uniform vec3 lightColor;

```
c
// Vue
uniform vec3 camPos;

```
c
// Constantes PBR
const float PI = 3.14159265359;

```
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
```c
 return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

```
void main()
{
 vec3 albedo = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2)); // correction gamma
 float metallic = texture(metallicMap, TexCoords).r;
 float roughness = texture(roughnessMap, TexCoords).r;

 vec3 N = normalize(Normal);
 vec3 V = normalize(camPos - FragPos);
 vec3 L = normalize(lightPos - FragPos);
 vec3 H = normalize(V + L);

 float distance = length(lightPos - FragPos);
 float attenuation = 1.0 / (distance * distance);
 vec3 radiance = lightColor * attenuation;

```c
 // Cook-Torrance BRDF
 float NDF = max(pow(dot(N, H), roughness * roughness), 0.001); // Simplifié
 float G = 0.5; // Simplifié
 vec3 F0 = mix(vec3(0.04), albedo, metallic);
 vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);

```
 vec3 nominator = NDF * G * F;
 float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;
 vec3 specular = nominator / denominator;

 vec3 kS = F;
 vec3 kD = vec3(1.0) - kS;
 kD *= 1.0 - metallic;

 float NdotL = max(dot(N, L), 0.0);

 vec3 Lo = (kD * albedo / PI + specular) * radiance * NdotL;

 vec3 ambient = vec3(0.03) * albedo * 0.1;

 vec3 color = ambient + Lo;

```c
 // Gamma correction
 color = pow(color, vec3(1.0/2.2));

```
 FragColor = vec4(color, 1.0);
}
📚 Explication rapide de ce Fragment Shader

Section Rôle
Récupère albedo, roughness, metallic 📚 Lecture des textures
Calcule vecteurs N, V, L, H 📚 Bases de l'éclairage
Applique modèle Cook-Torrance BRDF 📚 Calcul réaliste de lumière
Mélange spéculaire et diffuse selon matériau 📚 Réalisme des surfaces
Ajoute lumière ambiante douce 📚 Pour éviter objets totalement noirs
Correction gamma 📚 Adapter au moniteur humain
📋 Dans main.c / renderer.c
Charger toutes les textures :

wood_albedo.png

wood_normal.png

wood_roughness.png

wood_metallic.png

Lier les uniforms :

c
Copier
Modifier
glUniform1i(glGetUniformLocation(shaderProgram, "albedoMap"), 0);
glUniform1i(glGetUniformLocation(shaderProgram, "normalMap"), 1);
glUniform1i(glGetUniformLocation(shaderProgram, "metallicMap"), 2);
glUniform1i(glGetUniformLocation(shaderProgram, "roughnessMap"), 3);

```c
// Activer les textures
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, albedoTexture);

```
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, normalTexture);

glActiveTexture(GL_TEXTURE2);
glBindTexture(GL_TEXTURE_2D, metallicTexture);

glActiveTexture(GL_TEXTURE3);
glBindTexture(GL_TEXTURE_2D, roughnessTexture);
📋 Résultat attendu

Action Résultat
Ton objet 3D est réaliste ✅
Surface métallique / plastique différente ✅
Réflexions visibles selon angle caméra ✅
Déplacement lumière change comportement ✅
🎯 Mini plan d'action Bloc 9 Partie 2
Créer pbr.vert et pbr.frag,

Modifier shaders actifs dans OpenGL,

Lier textures PBR,

Observer rendu réaliste 🎨.

📋 TDD minimal Bloc 9 Partie 2

Test Ce qui doit être réussi
Chargement textures OK ✅
Shader compile sans erreurs ✅
Rendu visuel correct selon matériaux ✅
Pas d'artefacts (NaN pixels) ✅

# Bloc 9 — Partie 3 — Lumières dynamiques multiples
📚 Objectif immédiat
Tu vas :

Gérer plusieurs sources de lumière en même temps (comme dans un vrai moteur de jeu),

Implémenter Point Lights et Directional Lights,

Rendre ta scène beaucoup plus vivante et immersive.

📋 Types de lumières à gérer

Type de lumière Description
Directional Light Simule le soleil ➔ lumière venant d'une direction constante
Point Light Lampe ou flamme ➔ lumière depuis un point précis dans l'espace
📋 Comment ça marche

Type Ce qui change
Directional Seule direction importante (ex: lumière du soleil)
Point Light Position ET atténuation (distance influence la force)
📚 1. Définir les structures dans le Shader
📋 Dans pbr.frag :
glsl
Copier
Modifier
# define NR_POINT_LIGHTS 4

struct PointLight {
 vec3 position;
 vec3 color;
};

uniform PointLight pointLights[NR_POINT_LIGHTS];
uniform vec3 dirLightDirection;
uniform vec3 dirLightColor;
📋 2. Ajouter la contribution de chaque lumière
📋 Directional Light (Soleil)
glsl
Copier
Modifier
```c
// Directional light contribution
vec3 L = normalize(-dirLightDirection);
vec3 H = normalize(V + L);

```
float NdotL = max(dot(N, L), 0.0);
vec3 radiance = dirLightColor; // Pas d'atténuation pour Directional Light

```c
// Ajout contribution
Lo += (kD * albedo / PI + specular) * radiance * NdotL;
📋 Boucle sur les Point Lights
glsl
Copier
Modifier
for (int i = 0; i < NR_POINT_LIGHTS; ++i)
{
 vec3 L = normalize(pointLights[i].position - FragPos);
 vec3 H = normalize(V + L);
 float distance = length(pointLights[i].position - FragPos);
 float attenuation = 1.0 / (distance * distance);
 vec3 radiance = pointLights[i].color * attenuation;

```
 float NdotL = max(dot(N, L), 0.0);
 Lo += (kD * albedo / PI + specular) * radiance * NdotL;
}
📚 3. Côté C — Envoyer les lumières
📋 Exemple pour envoyer 4 Point Lights
c
Copier
Modifier
```c
char uniformName[64];
for (int i = 0; i < 4; i++)
{
 snprintf(uniformName, sizeof(uniformName), "pointLights[%d].position", i);
 glUniform3f(glGetUniformLocation(shaderProgram, uniformName),
 pointLightPositions[i].x, pointLightPositions[i].y, pointLightPositions[i].z);

```
 snprintf(uniformName, sizeof(uniformName), "pointLights[%d].color", i);
 glUniform3f(glGetUniformLocation(shaderProgram, uniformName),
 pointLightColors[i].x, pointLightColors[i].y, pointLightColors[i].z);
}
📋 Exemple pour envoyer la Directional Light
c
Copier
Modifier
glUniform3f(glGetUniformLocation(shaderProgram, "dirLightDirection"), -0.2f, -1.0f, -0.3f);
glUniform3f(glGetUniformLocation(shaderProgram, "dirLightColor"), 1.0f, 1.0f, 1.0f);
📋 Résultat attendu

Action Résultat
Scène illuminée par plusieurs sources ✅
Point lights visibles et influençant différents objets ✅
Directional light (comme le soleil) affectant tout ✅
Déplacement caméra montre zones d'ombre/lumière naturelles ✅
🎯 Mini plan d'action Bloc 9 Partie 3
Définir les structures PointLight et Directional dans shaders,

Adapter la boucle de calcul dans pbr.frag,

Envoyer les lumières depuis ton code C,

Tester en temps réel plusieurs sources de lumière.

📋 TDD minimal Bloc 9 Partie 3

Test Ce qui doit marcher
Jusqu'à 4+ Point Lights visibles ✅
Directional Light fonctionnelle ✅
Déplacement caméra influence rendu ✅
Pas de gros artefact ou NaN visuel ✅

# Bloc 9 — Partie 4 — HDR et Gamma Correction
📚 Objectif immédiat
Tu vas :

Passer ton moteur en rendu haute dynamique (HDR),

Appliquer une gamma correction correcte,

Obtenir un rendu ultra réaliste comparable à ce qu'on voit dans les moteurs professionnels.

📋 Pourquoi HDR et Gamma Correction ?

Terme Pourquoi c'est important
HDR Permet d'avoir des lumières plus intenses sans saturation, effets naturels
Gamma Correction Corrige la perception lumineuse pour l'œil humain
➔ Sans gamma, tes objets seront trop sombres ou trop brillants de manière irréaliste.

📚 Comment ça fonctionne techniquement

Étape Action
1. Dessiner toute la scène dans un Framebuffer HDR (format flottant) 
2. Appliquer gamma correction (pow(color, 1/2.2)) lors du post-processing 
📋 1. Créer un Framebuffer HDR
Dans renderer.c :

c
Copier
Modifier
```c
unsigned int hdrFBO;
glGenFramebuffers(1, &hdrFBO);
glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);

```
c
// Créer une texture couleur flottante
unsigned int colorBuffer;
glGenTextures(1, &colorBuffer);
glBindTexture(GL_TEXTURE_2D, colorBuffer);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, WIDTH, HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);

```
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorBuffer, 0);

```c
// Créer et attacher un Renderbuffer Depth
unsigned int rboDepth;
glGenRenderbuffers(1, &rboDepth);
glBindRenderbuffer(GL_RENDERBUFFER, rboDepth);
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, WIDTH, HEIGHT);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth);

```
c
// Vérifier framebuffer
if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
 printf("❌ Framebuffer HDR non complet\n");
glBindFramebuffer(GL_FRAMEBUFFER, 0);
📋 2. Modifier la boucle principale
Avant de rendre ta scène :

```
c
Copier
Modifier
glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

```c
// Rendu normal ici...
// Draw all objects
Après avoir tout dessiné :

```
c
Copier
Modifier
glBindFramebuffer(GL_FRAMEBUFFER, 0); // Retour à l'écran
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

```c
// Activer ton shader de post-processing (simple quad)
// Passer la texture HDR (colorBuffer) en input
// Appliquer gamma correction ici
📋 3. Shader de Post-Processing
📋 Vertex Shader post.vert
glsl
Copier
Modifier
# version 330 core
layout (location = 0) in vec2 aPos;
layout (location = 1) in vec2 aTexCoords;

```
out vec2 TexCoords;

void main()
{
 TexCoords = aTexCoords;
 gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);
}
📋 Fragment Shader post.frag
glsl
Copier
Modifier
# version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D hdrBuffer;
uniform bool hdr;
uniform float exposure;

void main()
{
 const float gamma = 2.2;
 vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;

 if(hdr)
 {
```c
 // tone mapping
 vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);
 // gamma correction
 mapped = pow(mapped, vec3(1.0/gamma));
 FragColor = vec4(mapped, 1.0);
 }
 else
 {
 // Sans HDR
 vec3 mapped = pow(hdrColor, vec3(1.0/gamma));
 FragColor = vec4(mapped, 1.0);
 }
}
📋 4. Côté C - Contrôler HDR / Gamma dynamiquement
Tu peux ajouter une variable toggle :

```
c
Copier
Modifier
bool hdr = true;
float exposure = 1.0f;

```c
// Input clavier
if (glfwGetKey(window, GLFW_KEY_H) == GLFW_PRESS)
 hdr = !hdr;

```
if (glfwGetKey(window, GLFW_KEY_KP_ADD) == GLFW_PRESS)
 exposure += 0.01f;
if (glfwGetKey(window, GLFW_KEY_KP_SUBTRACT) == GLFW_PRESS)
 exposure -= 0.01f;
Et l'envoyer au shader :

c
Copier
Modifier
glUniform1i(glGetUniformLocation(postShader, "hdr"), hdr);
glUniform1f(glGetUniformLocation(postShader, "exposure"), exposure);
📋 Résultat attendu

Action Résultat
Lumières naturelles sans saturer ✅
Contrôle du contraste avec exposure ✅
Gamma correction visible (moins "plat") ✅
Peut désactiver HDR à la volée ✅
🎯 Mini plan d'action Bloc 9 Partie 4
Créer framebuffer HDR + texture flottante,

Ajouter post-processing shader simple,

Appliquer tone mapping + gamma correction,

Tester visuellement différentes expositions.

📋 TDD minimal Bloc 9 Partie 4

Test Ce qui doit marcher
Scene rendu via HDR framebuffer ✅
Rendu avec lumière réaliste ✅
Toggle HDR fonctionne avec touche ✅
Gamma correction visible et naturelle ✅

# Bloc 9 — Partie 5 — Système complet de Matériaux
📚 Objectif immédiat
Tu vas :

Donner à chaque objet 3D ses propres textures et propriétés,

Créer un système Material pour stocker albedo, roughness, metallic, normal map,

Permettre à ton moteur d'afficher différents matériaux en même temps sur plusieurs objets.

📋 Pourquoi un "Material System" est indispensable

Raison Pourquoi c'est nécessaire
Flexibilité Chaque objet peut avoir son propre aspect sans recompiler les shaders
Performance Réduction des changements de shaders inutiles
Réalisme Mélanger matériaux métal, plastique, bois, roche dans la même scène
Scène complexe Gerer plusieurs objets dynamiques proprement
📋 Architecture prévue du système Matériaux
plaintext
Copier
Modifier
src/assets/
├── material.c/.h --> Définir structure de Material + création + liaison aux shaders
📋 1. Définir un Material
📋 Dans material.h
c
Copier
Modifier
# ifndef MATERIAL_H
# define MATERIAL_H

typedef struct s_material
{
```c
 unsigned int albedo;
 unsigned int normal;
 unsigned int metallic;
 unsigned int roughness;
} t_material;

```
c
t_material *create_material(const char *albedoPath, const char *normalPath, const char *metallicPath, const char *roughnessPath);
void bind_material(t_material *material);

```
# endif
📋 Dans material.c
c
Copier
Modifier
```c
# include "material.h"
# include "texture_loader.h" // fonction pour charger textures
# include <stdlib.h>

```
t_material *create_material(const char *albedoPath, const char *normalPath, const char *metallicPath, const char *roughnessPath)
{
 t_material *material = malloc(sizeof(t_material));
 if (!material)
```c
 return NULL;
 material->albedo = load_texture(albedoPath);
 material->normal = load_texture(normalPath);
 material->metallic = load_texture(metallicPath);
 material->roughness = load_texture(roughnessPath);
 return material;
}

```
void bind_material(t_material *material)
{
 glActiveTexture(GL_TEXTURE0);
 glBindTexture(GL_TEXTURE_2D, material->albedo);

 glActiveTexture(GL_TEXTURE1);
 glBindTexture(GL_TEXTURE_2D, material->normal);

 glActiveTexture(GL_TEXTURE2);
 glBindTexture(GL_TEXTURE_2D, material->metallic);

 glActiveTexture(GL_TEXTURE3);
 glBindTexture(GL_TEXTURE_2D, material->roughness);
}
📚 2. Utiliser un Material dans la scène
Dans ton scene.c :

Chaque objet aura maintenant un t_material *material;

Par exemple :

c
Copier
Modifier
typedef struct s_object3d
{
```c
 unsigned int vao;
 unsigned int vbo;
 unsigned int ebo;
 t_material *material;
 // Transform (position, rotation, scale) peut être ici aussi
} t_object3d;
📋 3. Pendant le rendu
Avant de dessiner chaque objet :

```
c
Copier
Modifier
bind_material(object->material);
glDrawElements(GL_TRIANGLES, object->indexCount, GL_UNSIGNED_INT, 0);
Chaque objet utilisera alors ses propres textures, tout en restant sur le même shader PBR global !

📋 Résultat attendu

Action Résultat
Différents matériaux sur différents objets ✅
Aucun bug visuel ou artefact ✅
Matériaux changés facilement (bois, métal, roche, etc.) ✅
🎯 Mini plan d'action Bloc 9 Partie 5
Créer material.h et material.c,

Donner un t_material * à chaque objet 3D,

Charger des textures différentes par objet,

Lier et dessiner les matériaux au moment du draw.

📋 TDD minimal Bloc 9 Partie 5

Test Ce qui doit marcher
Plusieurs objets avec matériaux différents ✅
Switch de matériaux sans recompiler shader ✅
Textures respectées pour chaque objet ✅

# Bloc 9 — Partie 6 — Activer Normal Mapping dynamique
📚 Objectif immédiat
Tu vas :

Utiliser des normal maps pour ajouter du relief sans géométrie supplémentaire,

Calculer la matrice TBN (Tangent, Bitangent, Normal),

Afficher des surfaces qui réagissent à la lumière comme si elles avaient du volume réel.

📋 Pourquoi utiliser le Normal Mapping ?

Bump Mapping / Normal Mapping Avantages
Normal Mapping Simule la lumière réagissant à des détails 3D sans ajouter de polygones
Performant Ne coûte rien en géométrie (GPU friendly)
Réaliste Donne de la profondeur visuelle même sur des plans plats
📋 1. Ce qu'il faut ajouter aux vertices
Tu dois :

Ajouter tangent et bitangent à chaque sommet,

Calculer la matrice TBN pour transformer la normal map correctement.

Chaque vertex devient :

c
Copier
Modifier
```c
// pos // normal // texcoord // tangent // bitangent
x, y, z, nx, ny, nz, u, v, tx, ty, tz, bx, by, bz
➡️ Total de 14 floats par vertex !

```
📋 2. Calcul des Tangents & Bitangents
Fais ce calcul une fois après avoir chargé ton modèle .obj, pour chaque triangle :

c
Copier
Modifier
```c
// Entrée: pos1, pos2, pos3 — uv1, uv2, uv3
vec3 edge1 = pos2 - pos1;
vec3 edge2 = pos3 - pos1;
vec2 deltaUV1 = uv2 - uv1;
vec2 deltaUV2 = uv3 - uv1;

```
float f = 1.0 / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);

vec3 tangent;
tangent.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
tangent.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
tangent.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);
normalize(tangent);

vec3 bitangent;
bitangent.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);
bitangent.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);
bitangent.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);
normalize(bitangent);
📋 3. Vertex Shader pbr.vert (mis à jour)
Ajoute en entrée :

glsl
Copier
Modifier
layout (location = 3) in vec3 aTangent;
layout (location = 4) in vec3 aBitangent;
Et dans le shader :

glsl
Copier
Modifier
out vec3 FragPos;
out vec2 TexCoords;
out mat3 TBN;

void main()
{
 vec3 T = normalize(mat3(model) * aTangent);
 vec3 B = normalize(mat3(model) * aBitangent);
 vec3 N = normalize(mat3(model) * aNormal);
 TBN = mat3(T, B, N);

 FragPos = vec3(model * vec4(aPos, 1.0));
 TexCoords = aTexCoords;
 gl_Position = projection * view * vec4(FragPos, 1.0);
}
📋 4. Fragment Shader pbr.frag (mis à jour)
Remplace :

glsl
Copier
Modifier
vec3 N = normalize(Normal); // ⛔ ancien code
par :

glsl
Copier
Modifier
vec3 normalMap = texture(normalMap, TexCoords).rgb;
normalMap = normalMap * 2.0 - 1.0; // Transform 0–1 -> -1 to 1
vec3 N = normalize(TBN * normalMap); // ✅ Vrai relief !
📚 Résultat attendu

Action Résultat
Surface "plate" semble avoir des bosses ✅
Réagit à la lumière selon angle caméra ✅
Relief change avec les tangents et la texture ✅
🎯 Mini plan d'action Bloc 9 Partie 6
Ajouter tangents/bitangents aux vertex,

Calculer TBN matrix dans vertex shader,

Lire la normal map dans fragment shader,

Appliquer le mapping dynamique.

📋 TDD minimal Bloc 9 Partie 6

Test Ce qui doit marcher
Surface avec normal map réagit correctement à la lumière ✅
Sans normal map, rendu reste OK ✅
Rotation caméra modifie bien le relief ✅
Aucun artefact visuel (noirs ou cassés) ✅

# Bloc 9 — Partie 7 — Image-Based Lighting (IBL)
📚 Objectif immédiat
Tu vas :

Ajouter un système de réflexion réaliste basé sur ta Skybox (cubemap),

Intégrer IBL Diffuse et IBL Specular (simplifié au départ),

Améliorer visuellement tous tes matériaux sans nouvelle géométrie ni lumière dynamique.

📋 Qu'est-ce que l'IBL ?

Élément Description
IBL = Image-Based Lighting Utiliser une image HDR (skybox) comme source de lumière globale
Réflexions réelles Les matériaux reflètent le ciel, l'environnement
Économie de calcul Pas besoin de 10 lampes pour simuler un éclairage naturel
Immersion ++ Refléter ce qui est autour dans l'objet comme un miroir flou ou parfait
📋 Deux composants IBL

Type But
IBL Diffuse Teinte générale issue de l'environnement
IBL Specular Réflexions plus ou moins brillantes (dépend du roughness)
On commence ici par un IBL simplifié statique (très bon rendu, très peu de calcul).

📋 Étapes générales à suivre
Charger ta Skybox (déjà fait ✅)

La convertir en irradiance map (basse résolution, floutée pour IBL diffuse)

La convertir en prefilter map (pour IBL specular)

Utiliser un BRDF LUT (lookup texture) pour corriger la brillance

Intégrer tout ça dans ton pbr.frag

📋 1. Charger Skybox HDR (format .hdr)
Tu dois utiliser une skybox HDRI (pas juste une image .jpg !)

Exemple HDRI :
👉 https://polyhaven.com/hdris — Gratuit

Charge-la avec stbi_loadf() (au lieu de stbi_load classique) :

c
Copier
Modifier
float *data = stbi_loadf("resources/hdr/newport_loft.hdr", &width, &height, &nrComponents, 0);
Et utilise GL_RGB16F pour la texture OpenGL.

📋 2. Générer la irradiance map
Une fois la skybox chargée :

c
Copier
Modifier
glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);
glFramebufferTexture2D(...); // target irradianceMap

```c
// Lancer un shader spécial de convolution
// Résolution: 32x32 (ou même 16x16)
💡 Ce shader prend la skybox, floute les directions et génère la lumière ambiante par face.

```
📋 3. Générer la prefilter map
Même idée que pour irradiance, mais :

Résolution plus grande (128x128),

Shader + complexe: préfiltre selon roughness.

📋 4. Générer la BRDF LUT texture
Ce n'est pas une image → c'est une texture 2D (512×512) générée une seule fois avec un shader.

Ce LUT sert à corriger l'intensité des réflexions spéculaires dans pbr.frag.

📋 5. Intégrer dans pbr.frag
Ajoute :

glsl
Copier
Modifier
uniform samplerCube irradianceMap;
uniform samplerCube prefilterMap;
uniform sampler2D brdfLUT;
Et modifie ton calcul :

glsl
Copier
Modifier
```c
// IBL Diffuse
vec3 irradiance = texture(irradianceMap, N).rgb;
vec3 diffuseIBL = irradiance * albedo;

```
c
// IBL Specular
vec3 R = reflect(-V, N);
float roughness = ...;
vec3 prefilteredColor = textureLod(prefilterMap, R, roughness * MAX_LOD).rgb;

```
vec2 brdf = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;
vec3 specularIBL = prefilteredColor * (F * brdf.x + brdf.y);

```c
// Final color
vec3 color = ambient + Lo + diffuseIBL + specularIBL;
📋 Résultat attendu

```
Action Résultat
Matériaux reflètent la Skybox ✅
Surfaces métalliques = miroirs réalistes ✅
Matières mates = diffus mais teintées par environnement ✅
Rotation caméra = reflet réaliste ✅
Aucun artefact de lumière en intérieur ✅
🎯 Mini plan d'action Bloc 9 Partie 7
Charger une HDR Skybox (.hdr)

Générer 3 textures dérivées :

Irradiance Map

Prefilter Map

BRDF LUT

Modifier pbr.frag pour ajouter IBL

Tester sur plusieurs objets

📋 TDD minimal Bloc 9 Partie 7

Test Ce qui doit être fonctionnel
Reflets dynamiques selon la Skybox ✅
Surfaces métalliques montrent miroir (flou/net) ✅
Brillance correcte avec BRDF LUT ✅
Diffuse naturel même sans lumière directe ✅

# Bloc 9 — Partie 8 — Instancing OpenGL (dessiner 10 000 objets d'un coup)
📚 Objectif immédiat
Tu vas :

Utiliser l'OpenGL Instancing pour dessiner des centaines / milliers d'objets identiques avec des positions différentes,

Apprendre à envoyer des matrices de transformation pour chaque instance,

Booster les performances pour simuler foules, forêts, pluie, étoiles...

📋 Pourquoi utiliser Instancing ?

Sans Instancing Avec Instancing
glDrawElements() appelé 10 000 fois Appelé une seule fois
Chaque objet → CPU + GPU Calcul CPU une fois → GPU fait tout
Super lent ⚡ Ultra rapide
📋 Exemple typique d'usage

Projet Utilisation
Forêt 1 arbre x 10 000 positions
Système solaire 1 planète x 100 satellites
Champ d'astéroïdes 1 rocher x 1000 instances
Particules 1 sprite / bill x 100 000
📋 1. Ajouter un VBO de matrices (par instance)
Dans renderer.c :

c
Copier
Modifier
```c
unsigned int instanceVBO;
glGenBuffers(1, &instanceVBO);
glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(glm::mat4) * amount, modelMatrices, GL_STATIC_DRAW);
modelMatrices[] est un tableau de glm::mat4 (ou équivalent float[16]) contenant toutes les positions, rotations, échelles.

```
📋 2. Attacher les matrices à ton VAO (en tant qu'attributs par instance)
Un mat4 = 4 vec4 → 4 glVertexAttribPointer

c
Copier
Modifier
```c
for (int i = 0; i < 4; i++) {
 glEnableVertexAttribArray(3 + i);
 glVertexAttribPointer(3 + i, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float) * i * 4));
 glVertexAttribDivisor(3 + i, 1); // 1 = par instance
}
📋 3. Modifier ton Vertex Shader pour inclure model par instance
Dans pbr.vert :

```
glsl
Copier
Modifier
layout (location = 3) in mat4 instanceModel;

uniform mat4 view;
uniform mat4 projection;

void main()
{
 vec4 worldPosition = instanceModel * vec4(aPos, 1.0);
 FragPos = vec3(worldPosition);
 gl_Position = projection * view * worldPosition;

 Normal = mat3(transpose(inverse(instanceModel))) * aNormal;
 TexCoords = aTexCoords;
}
📋 4. Côté dessin (main.c ou scene.c)
Au lieu de faire une boucle :

c
Copier
Modifier
```c
for (int i = 0; i < 10000; i++)
 glDrawElements(...);
Fais simplement :

```
c
Copier
Modifier
glDrawElementsInstanced(GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, 0, instanceCount);
Boom 💥: 1 appel, 10 000 objets rendus.

📋 Résultat attendu

Action Résultat
10 000 objets visibles ✅
FPS élevé (si pas de post-process lourd) ✅
Chaque objet positionné différemment ✅
Pas de lag CPU ✅
🎯 Mini plan d'action Bloc 9 Partie 8
Générer un tableau de modelMatrices (positions aléatoires par exemple),

Créer un VBO avec ces matrices,

Lier ce VBO comme des attributs d'instance,

Modifier le shader pour utiliser la matrice par objet,

Dessiner via glDrawElementsInstanced.

📋 TDD minimal Bloc 9 Partie 8

Test Ce qui doit marcher
Tous les objets sont visibles ✅
Chaque objet a une transformation unique ✅
Un seul appel de rendu ✅
Aucun crash ou artefact graphique ✅

# Bloc 9 — Partie 9 — Architecture de Scène: Entity Component System (ECS)
📚 Objectif immédiat
Tu vas :

Construire une architecture modulaire extensible pour gérer des milliers d'objets dynamiques,

Implémenter un système Entity / Component / System comme dans Unity ou Godot,

Contrôler facilement transformations, matériaux, comportements et rendu de chaque objet.

📋 Pourquoi utiliser un ECS ?

Sans ECS Avec ECS
Objets en struct fixes imbriquées Objets dynamiques avec composants indépendants
Difficile à maintenir Super flexible et modulaire
Code spaghetti Code clair, par type de logique
Ajouter un composant = casser le reste Ajouter un composant = plug and play ✅
📋 Concepts de base

Élément Rôle
Entity Identifiant unique (souvent juste un uint)
Component Donnée (Transform, Material, Physics...)
System Logique (rendering, update, collision...)
📋 Exemple visuel
plaintext
Copier
Modifier
Entity 1: [Transform] + [Renderable] + [Material]
Entity 2: [Transform] + [Physics]
Entity 3: [Transform] + [Light] + [Material]
Chaque System itère uniquement sur les entités qui ont les bons composants.

📋 1. Créer les bases dans scene/
📋 entity.h
c
Copier
Modifier
# ifndef ENTITY_H
# define ENTITY_H

```c
typedef unsigned int Entity;
# define MAX_ENTITIES 10000

```
c
Entity create_entity(void);
void destroy_entity(Entity e);

```
# endif
📋 component.h
c
Copier
Modifier
# ifndef COMPONENT_H
# define COMPONENT_H

```c
# include "entity.h"

```
typedef struct {
 float position[3];
 float rotation[3];
 float scale[3];
} Transform;

typedef struct {
```c
 unsigned int vao;
 unsigned int index_count;
} Renderable;

```
typedef struct {
```c
 unsigned int material_id;
} MaterialComponent;

```
c
void add_transform(Entity e, Transform t);
void add_renderable(Entity e, Renderable r);
void add_material(Entity e, MaterialComponent m);

```
Transform* get_transform(Entity e);
Renderable* get_renderable(Entity e);
MaterialComponent* get_material(Entity e);

# endif
📋 scene.h
c
Copier
Modifier
# ifndef SCENE_H
# define SCENE_H

```c
void init_scene(void);
void update_scene(float dt);
void render_scene(void);

```
# endif
📋 2. Exemple d'utilisation dans ton moteur
c
Copier
Modifier
Entity asteroid = create_entity();

Transform t = {{10.0f, 2.0f, -50.0f}, {0, 0, 0}, {1.0f, 1.0f, 1.0f}};
Renderable r = {asteroid_vao, index_count};
MaterialComponent m = {material_id};

add_transform(asteroid, t);
add_renderable(asteroid, r);
add_material(asteroid, m);
📋 3. render_system.c (un "System")
c
Copier
Modifier
void render_scene(void)
{
```c
 for (Entity e = 0; e < MAX_ENTITIES; e++)
 {
 if (has_transform(e) && has_renderable(e) && has_material(e))
 {
 Transform* t = get_transform(e);
 Renderable* r = get_renderable(e);
 MaterialComponent* m = get_material(e);

```
c
 // Générer model matrix depuis t
 // Lier m->material_id
 // Lancer draw pour r->vao
 }
 }
}
📚 Résultat attendu

```
Action Résultat
Ajouter un objet = 3 appels add_...() ✅
Chaque entité a sa logique propre ✅
Système modulable: ajouter Composant Physics plus tard ✅
Code clair, propre, scalable ✅
🎯 Mini plan d'action Bloc 9 Partie 9
Créer Entity, Component, System modules,

Init 10 entités avec différents composants,

Implémenter le système de rendu proprement,

Ajouter la possibilité d'avoir des transformations individuelles.

📋 TDD minimal Bloc 9 Partie 9

Test Ce qui doit marcher
Ajouter une entité et lui assigner 3 composants ✅
Le render_system détecte et dessine l'objet ✅
La structure supporte 1000+ entités ✅
Aucun couplage entre composants ✅

# Bloc 9 — Partie 10 — Moteur Temps Réel: Input, Physique & Mouvements dans ECS
📚 Objectif immédiat
Tu vas :

Ajouter la gestion du temps (deltaTime),

Intégrer les mouvements physiques dans les entités (vitesse, gravité...),

Rendre les objets dynamiques (input clavier, animation, comportements dans le monde 3D).

📋 Composants à ajouter

Nom du composant Contenu
Velocity Vecteur de vitesse (x, y, z)
InputController Touches associées à l'entité (player, NPC)
Timer (facultatif) Chronomètre d'action (attaque, respawn, etc.)
📋 1. Nouveau composant: Velocity
📋 Dans component.h
c
Copier
Modifier
typedef struct {
 float x;
 float y;
 float z;
} Velocity;

```c
void add_velocity(Entity e, Velocity v);
Velocity* get_velocity(Entity e);
bool has_velocity(Entity e);
📋 2. Nouveau système: physics_system.c
c
Copier
Modifier
void update_physics(float dt)
{
 for (Entity e = 0; e < MAX_ENTITIES; e++)
 {
 if (has_transform(e) && has_velocity(e))
 {
 Transform* t = get_transform(e);
 Velocity* v = get_velocity(e);

```
 t->position[0] += v->x * dt;
 t->position[1] += v->y * dt;
 t->position[2] += v->z * dt;
 }
 }
}
📋 3. Nouveau composant: InputController (pour joueur)
c
Copier
Modifier
typedef struct {
```c
 int forward_key;
 int back_key;
 int left_key;
 int right_key;
 float speed;
} InputController;

```
c
void add_input(Entity e, InputController c);
InputController* get_input(Entity e);
bool has_input(Entity e);
📋 4. Système: input_system.c
c
Copier
Modifier
void update_input(GLFWwindow* window, float dt)
{
 for (Entity e = 0; e < MAX_ENTITIES; e++)
 {
 if (has_input(e) && has_velocity(e))
 {
 InputController* ctrl = get_input(e);
 Velocity* vel = get_velocity(e);

```
 vel->x = 0;
 vel->z = 0;

 if (glfwGetKey(window, ctrl->forward_key) == GLFW_PRESS)
 vel->z -= ctrl->speed;
 if (glfwGetKey(window, ctrl->back_key) == GLFW_PRESS)
 vel->z += ctrl->speed;
 if (glfwGetKey(window, ctrl->left_key) == GLFW_PRESS)
 vel->x -= ctrl->speed;
 if (glfwGetKey(window, ctrl->right_key) == GLFW_PRESS)
 vel->x += ctrl->speed;

```c
 // Tu peux ajouter Y si besoin (saut)
 }
 }
}
📋 5. Boucle principale (main loop)
c
Copier
Modifier
float lastTime = glfwGetTime();
while (!glfwWindowShouldClose(window))
{
 float currentTime = glfwGetTime();
 float deltaTime = currentTime - lastTime;
 lastTime = currentTime;

```
 glfwPollEvents();

 update_input(window, deltaTime);
 update_physics(deltaTime);
 update_scene(deltaTime);
 render_scene();

 glfwSwapBuffers(window);
}
📋 Résultat attendu

Action Résultat
Le joueur peut bouger un objet avec le clavier ✅
Chaque objet avec Velocity bouge naturellement ✅
Ajouter un saut ou une chute devient simple ✅
Le temps réel est stable et fluide ✅
🎯 Mini plan d'action Bloc 9 Partie 10
Créer les composants Velocity et InputController,

Ajouter les systèmes update_physics() et update_input(),

Brancher ça à ta boucle de jeu (avec deltaTime),

Créer un objet "Player" qui réagit au clavier 🎮

📋 TDD minimal Bloc 9 Partie 10

Test Ce qui doit fonctionner
Déplacement via touches ✅
Mouvements fluides et temps réel ✅
Vitesse ajustable facilement ✅
Système scalable à des NPCs, ennemis, balles, etc. ✅
✅ Bloc 9 — Partie 10 terminé proprement !
Ton moteur est maintenant entièrement interactif, temps réel et orienté jeu 🎯🔥

# Bloc 10 — Projet Simulation de Jeu Réel (sur ton moteur) [🟢 Facile]
🎮 Titre provisoire: Project_ZeroAlpha

📚 Objectif global
Créer un prototype de jeu complet et jouable, à choisir parmi :

Prototype Description Difficulté
🪐 Shoot Spatial 3D Tu pilotes un vaisseau dans l'espace, tu tires, tu esquives, tu gagnes. 🔥🔥
🦾 Jeu de Plateforme FPS Tu explores un monde 3D, tu sautes, tu résous des puzzles. 🔥🔥🔥
⚔️ Prototype ARÈNE TPS Tu joues un personnage qui se bat dans une arène à la 3ᵉ personne. 🔥🔥🔥🔥
👾 Jeu minimal Rogue-like 3D Tu explores, lootes, meurs, recommences. 🔥🔥🔥
💡 Tu pourras TOUS les faire ensuite, mais on commence avec UN prototype bien structuré.

✅ Par défaut: Shoot Spatial 3D
Si tu ne choisis pas, on part là-dessus: simple, nerveux, parfait pour valider ton moteur.

📋 Étapes globales

Étape Objectif
10.1 Créer le joueur (vaisseau, contrôles, caméra)
10.2 Créer les ennemis + vagues aléatoires
10.3 Gérer tirs, projectiles, collisions
10.4 Afficher HUD (vie, score, armes)
10.5 Ajouter explosion, sons, feedbacks
10.6 Menu pause, restart, victoire/défaite
10.7 Export build stable Linux (et plus tard Windows ?)
🗂️ Organisation du projet
plaintext
Copier
Modifier
game_project_zero/
├── src/
│ ├── game/ # logiques spécifiques au jeu
│ │ ├── player.c/.h
│ │ ├── enemy.c/.h
│ │ ├── bullet.c/.h
│ │ ├── hud.c/.h
│ │ ├── game_state.c/.h
│ ├── engine/ # ton moteur OpenGL actuel
├── assets/
│ ├── models/ # vaisseau, ennemis, projectiles
│ ├── textures/
│ ├── sounds/
│ ├── shaders/
├── include/
├── Makefile
🧠 Système utilisé

Élément Moteur
Rendu OpenGL PBR avec IBL
ECS Oui (Entity, Component, System)
Input GLFW + système maison
Physique Simple: AABB collisions, vitesse
UI Textes et barres via primitives 2D (à venir)
🧩 Composants typiques du jeu

Composant Description
Transform Position, rotation, échelle
Velocity Direction et vitesse
InputController Pour le joueur
AIController Pour les ennemis
Health Points de vie
Bullet Dégâts, vitesse, collision
ScoreTag Permet de compter les points
📋 Prêt pour: Bloc 10 — Partie 1 [🟢 Facile]
✅ Bloc 10 Partie 1 — Créer ton joueur [🟢 Facile]
Tu vas :

Créer une entité Player,

Ajouter composants: Transform, Velocity, InputController, Health, Renderable,

Contrôler ses déplacements (ZQSD ou Flèches),

Lier la caméra à la position du joueur (TPS ou cockpit).

# Bloc 10 — Partie 1 — Créer le Joueur [🟢 Facile]: Contrôles, Apparence, Caméra
🎯 Objectif de cette partie
Tu vas :

Créer une entité Player dans l'ECS,

Lui donner un vaisseau visible, contrôlable au clavier,

Ajouter une caméra liée au joueur (mode cockpit ou suivi TPS),

Le rendre prêt à tirer plus tard (Partie 2).

📚 Composants utilisés pour Player

Composant Rôle
Transform Position dans le monde 3D
Velocity Mouvement contrôlé
InputController Lié aux touches clavier
Renderable Apparence du vaisseau (VAO + mesh)
MaterialComponent Apparence visuelle PBR
CameraFollow (bonus) Caméra suit automatiquement cette entité
📋 Étapes concrètes
1️⃣ Créer l'entité dans game/player.c
c
Copier
Modifier
```c
# include "entity.h"
# include "component.h"
# include "player.h"

```
Entity player;

void create_player(void)
{
 player = create_entity();

 Transform t = {{0.0f, 0.0f, 0.0f}, {0, 0, 0}, {1, 1, 1}};
 Velocity v = {0, 0, 0};
 InputController ctrl = {
 .forward_key = GLFW_KEY_W,
 .back_key = GLFW_KEY_S,
 .left_key = GLFW_KEY_A,
 .right_key = GLFW_KEY_D,
 .speed = 20.0f
 };

 Renderable r = {load_player_vao(), player_index_count};
 MaterialComponent m = {load_player_material()};

 add_transform(player, t);
 add_velocity(player, v);
 add_input(player, ctrl);
 add_renderable(player, r);
 add_material(player, m);
}
2️⃣ Lier la caméra au joueur
Dans camera_follow_system.c :

c
Copier
Modifier
void update_camera_follow(float dt)
{
 if (has_transform(player))
 {
 Transform* t = get_transform(player);
 set_camera_position(t->position[0], t->position[1] + 2.0f, t->position[2] + 10.0f);
 look_at(t->position); // fonction à écrire
 }
}
3️⃣ Brancher le tout
Dans main.c ou game_state.c :

c
Copier
Modifier
create_player();

while (!glfwWindowShouldClose(window))
{
 float dt = compute_delta_time();

 glfwPollEvents();
 update_input(window, dt);
 update_physics(dt);
 update_camera_follow(dt);
 render_scene();

 glfwSwapBuffers(window);
}
📋 Résultat attendu

Action Résultat
Un vaisseau visible au centre ✅
Contrôlable avec ZQSD ✅
La caméra suit de près ou derrière ✅
Vitesse fluide et responsive ✅
🔧 Exemple VAO minimal du vaisseau (temporaire)
Tu peux commencer par charger un simple cube .obj ou quad en OpenGL avec une couleur de test.

🎯 Mini-TDD Bloc 10 Partie 1 [🟢 Facile]

Test Ce qui doit marcher
Appui sur Z avance le joueur ✅
Appui sur D tourne à droite ✅
La caméra suit correctement ✅
Aucun lag, aucun artefact visuel ✅

# Bloc 10 — Partie 2 — Tirs et projectiles du Joueur [🟢 Facile]
📚 Objectif immédiat
Tu vas :

Permettre au joueur de tirer en appuyant sur une touche,

Créer des projectiles dynamiques (missiles, lasers, balles),

Faire avancer automatiquement les projectiles,

Préparer les bases pour les collisions contre les ennemis.

📋 Composants supplémentaires nécessaires

Composant Rôle
Projectile Identifie une entité comme projectile
Velocity Contrôle la vitesse du projectile
Renderable Pour afficher un modèle de laser
Transform Position du projectile dans l'espace
📋 1. Ajouter Projectile dans component.h
c
Copier
Modifier
typedef struct {
 float damage;
 Entity owner;
} Projectile;

```c
void add_projectile(Entity e, Projectile p);
Projectile* get_projectile(Entity e);
bool has_projectile(Entity e);
📋 2. Code pour tirer un projectile dans player.c
Quand le joueur appuie sur une touche (espace par exemple) :

```
c
Copier
Modifier
void shoot_projectile(Entity shooter)
{
 if (!has_transform(shooter))
```c
 return;

```
 Entity bullet = create_entity();

 Transform* shooterTransform = get_transform(shooter);
 Transform t = {
 {shooterTransform->position[0], shooterTransform->position[1], shooterTransform->position[2]},
 {0.0f, 0.0f, 0.0f},
 {0.2f, 0.2f, 0.2f}
 };

 Velocity v = {0.0f, 0.0f, -100.0f}; // Va tout droit vers le "devant"
 Renderable r = {load_bullet_vao(), bullet_index_count};
 MaterialComponent m = {load_bullet_material()};
 Projectile p = {.damage = 10.0f, .owner = shooter};

 add_transform(bullet, t);
 add_velocity(bullet, v);
 add_renderable(bullet, r);
 add_material(bullet, m);
 add_projectile(bullet, p);
}
📋 3. Gestion de l'Input pour tirer
Dans ton update_input(window, dt) :

c
Copier
Modifier
static double lastShotTime = 0.0;
double currentTime = glfwGetTime();

if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS && currentTime - lastShotTime > 0.25)
{
 shoot_projectile(player);
 lastShotTime = currentTime;
}
(Un délai de 0.25s entre deux tirs pour éviter spam.)

📋 4. Avancer les projectiles (déjà géré par update_physics())
Grâce à ton Velocity, les projectiles avancent automatiquement !

➔ Tu n'as rien de spécial à ajouter côté mouvement. ✅

📋 5. Détruire les projectiles trop éloignés (nettoyage)
Ajoute dans update_physics() :

c
Copier
Modifier
if (has_projectile(e))
{
 Transform* t = get_transform(e);
 if (t->position[2] < -100.0f || t->position[2] > 100.0f)
 destroy_entity(e);
}
Pour éviter qu'ils existent à l'infini dans l'espace.

📚 Résultat attendu

Action Résultat
Appui sur Espace ➔ création d'un laser ✅
Le laser avance automatiquement ✅
Le laser disparaît après 100 unités ✅
Tir fluide sans freeze du moteur ✅
🎯 Mini plan d'action Bloc 10 Partie 2 [🟢 Facile]
Ajouter Projectile en tant que composant,

Permettre au joueur de tirer via Espace,

Générer entités projectiles en temps réel,

Gérer le mouvement + destruction automatique.

📋 TDD minimal Bloc 10 Partie 2 [🟢 Facile]

Test Ce qui doit fonctionner
Tirs visibles et alignés avec le vaisseau ✅
Déplacement fluide des projectiles ✅
Tirs désactivés après une certaine distance ✅
Aucun crash ou fuite mémoire ✅

# Bloc 10 — Partie 3 — Générer Ennemis et Vagues d'Attaque [🟢 Facile]
📚 Objectif immédiat
Tu vas :

Créer des entités ennemies dynamiques,

Les placer en formation ou aléatoirement dans l'espace,

Leur donner un comportement basique (avancer / foncer vers toi),

Préparer la logique de vagues successives.

📋 Composants des Ennemis

Composant Rôle
Transform Position 3D de l'ennemi
Velocity Déplacement automatique
Renderable Apparence (modèle 3D d'ennemi)
MaterialComponent Aspect visuel (textures, shaders)
Health Points de vie
EnemyTag Pour les identifier comme ennemis
📋 1. Ajouter EnemyTag dans component.h
c
Copier
Modifier
typedef struct {
```c
 int waveNumber;
} EnemyTag;

```
c
void add_enemy(Entity e, EnemyTag et);
bool has_enemy(Entity e);
EnemyTag* get_enemy(Entity e);
📋 2. Créer un générateur d'ennemis dans enemy.c
c
Copier
Modifier
void spawn_enemy(float x, float y, float z, int wave)
{
 Entity enemy = create_entity();

```
 Transform t = {{x, y, z}, {0, 0, 0}, {1.0f, 1.0f, 1.0f}};
 Velocity v = {0.0f, 0.0f, 5.0f}; // Viens vers toi
 Renderable r = {load_enemy_vao(), enemy_index_count};
 MaterialComponent m = {load_enemy_material()};
 EnemyTag et = {wave};
 Health h = {100}; // 100 PV par défaut

 add_transform(enemy, t);
 add_velocity(enemy, v);
 add_renderable(enemy, r);
 add_material(enemy, m);
 add_enemy(enemy, et);
 add_health(enemy, h);
}
📋 3. Gérer la génération de vagues
Dans wave_manager.c :

c
Copier
Modifier
```c
static int current_wave = 0;
static float time_since_last_wave = 0.0f;

```
void update_wave_manager(float dt)
{
 time_since_last_wave += dt;

 if (time_since_last_wave > 10.0f) // Toutes les 10 secondes
 {
 current_wave++;
 time_since_last_wave = 0.0f;

```c
 int number_of_enemies = 5 + current_wave * 2;

```
c
 for (int i = 0; i < number_of_enemies; i++)
 {
 float x = (rand() % 40) - 20;
 float y = (rand() % 10) - 5;
 float z = -100.0f; // Toujours loin en avant
 spawn_enemy(x, y, z, current_wave);
 }
 }
}
📋 4. Intégrer dans ta boucle principale
Dans main.c :

```
c
Copier
Modifier
update_wave_manager(deltaTime);
Ajouté juste avant render_scene().

📋 5. (Optionnel) Détruire les ennemis arrivés au bout
Dans update_physics() :

c
Copier
Modifier
if (has_enemy(e))
{
 Transform* t = get_transform(e);
 if (t->position[2] > 10.0f) // Passe derrière toi ?
 destroy_entity(e);
}
📋 Résultat attendu

Action Résultat
Apparition d'ennemis toutes les 10 secondes ✅
Ennemis se déplacent vers toi automatiquement ✅
Vagues deviennent plus grandes à chaque fois ✅
Pas de lag visible si vague < 100 ennemis ✅
🎯 Mini plan d'action Bloc 10 Partie 3 [🟢 Facile]
Ajouter EnemyTag et Health,

Créer fonction spawn_enemy(x, y, z, wave),

Créer un gestionnaire de vagues update_wave_manager(),

Nettoyer les ennemis hors de la scène.

📋 TDD minimal Bloc 10 Partie 3 [🟢 Facile]

Test Ce qui doit marcher
Apparition régulière d'ennemis ✅
Déplacement fluide vers le joueur ✅
Vagues de plus en plus difficiles ✅
Pas d'ennemis fantômes persistants ✅

# Bloc 10 — Partie 4 — Système de Collisions et Destruction d'Ennemis [🟢 Facile]
📚 Objectif immédiat
Tu vas :

Détecter les collisions entre projectiles et ennemis,

Infliger des dégâts via le composant Health,

Détruire l'ennemi ou le projectile en conséquence,

Préparer les effets visuels et le score pour la Partie 5.

📋 Composants nécessaires

Composant Rôle
Projectile Identifie un projectile (avec source & dégâts)
EnemyTag Identifie un ennemi
Health Pour retirer les PV
Transform Permet de déterminer la position (collision)
📋 1. Ajouter un système de collision simple
Dans collision_system.c :

c
Copier
Modifier
float distance_squared(float* a, float* b)
{
 float dx = a[0] - b[0];
 float dy = a[1] - b[1];
 float dz = a[2] - b[2];
```c
 return dx * dx + dy * dy + dz * dz;
}

```
void update_projectile_collisions(void)
{
```c
 for (Entity proj = 0; proj < MAX_ENTITIES; proj++)
 {
 if (!has_projectile(proj) || !has_transform(proj)) continue;

```
 Transform* pt = get_transform(proj);
 Projectile* p = get_projectile(proj);

```c
 for (Entity e = 0; e < MAX_ENTITIES; e++)
 {
 if (!has_enemy(e) || !has_transform(e) || !has_health(e)) continue;

```
 Transform* et = get_transform(e);

 if (distance_squared(pt->position, et->position) < 1.0f) // Rayon = 1 unité
 {
```c
 // Appliquer les dégâts
 Health* h = get_health(e);
 h->value -= p->damage;

```
c
 // Détruire projectile
 destroy_entity(proj);

```
c
 // Ennemi mort ?
 if (h->value <= 0)
 {
 destroy_entity(e);
 // Ajouter score plus tard
 }

```
 break; // Un projectile touche un seul ennemi
 }
 }
 }
}
📋 2. Appeler ce système dans la boucle principale
Dans main.c (ou équivalent) :

c
Copier
Modifier
update_projectile_collisions(); // Après update_physics()
📋 3. Créer Health dans component.h
c
Copier
Modifier
typedef struct {
 float value;
} Health;

```c
void add_health(Entity e, Health h);
Health* get_health(Entity e);
bool has_health(Entity e);
📋 4. Visuel (temporaire)
Tu peux afficher dans la console :

```
c
Copier
Modifier
```c
printf("[+] Enemy hit! Remaining HP: %.1f\n", h->value);
Ou plus tard, afficher une explosion (Partie 5).

```
📚 Résultat attendu

Action Résultat
Projectile touche ennemi ➔ ennemi perd PV ✅
Ennemi meurt si PV ≤ 0 ✅
Projectile disparaît à l'impact ✅
Aucun bug ou crash ✅
🎯 Mini plan d'action Bloc 10 Partie 4 [🟢 Facile]
Créer le système update_projectile_collisions,

Ajouter composant Health,

Gérer dégât + destruction entité,

Appeler le système à chaque frame.

📋 TDD minimal Bloc 10 Partie 4 [🟢 Facile]

Test Ce qui doit marcher
Collision correcte même à grande vitesse ✅
Plusieurs ennemis peuvent être touchés ✅
Score prêt à être incrémenté (à suivre) ✅
Aucun objet "zombie" restant sur scène ✅

# Bloc 10 — Partie 5 — HUD, Score et Effets visuels [🟢 Facile]
📚 Objectif immédiat
Tu vas :

Afficher un HUD complet avec score, vies, vague actuelle,

Ajouter une explosion visuelle ou effet de disparition à la mort des ennemis,

Gérer le système de score, de vies et de fin de partie (game over).

📋 Éléments à gérer maintenant

Élément Type Objectif
Score Variable globale ou composant PlayerScore +10 points par ennemi
Vies Variable globale ou composant PlayerHealth -1 si ennemi te dépasse
HUD Dessin 2D (texte ou primitives) Affichage à l'écran
Explosion Entité temporaire ou effet visuel simple Feedback de destruction
✅ Étape 1 — Ajouter le score (via composant)
📋 Dans component.h
c
Copier
Modifier
typedef struct {
```c
 int score;
 int lives;
} PlayerStatus;

```
c
void add_player_status(Entity e, PlayerStatus s);
PlayerStatus* get_player_status(Entity e);
bool has_player_status(Entity e);
📋 Lors de la création du joueur (create_player())
c
Copier
Modifier
PlayerStatus status = {0, 3}; // 3 vies au départ
add_player_status(player, status);
✅ Étape 2 — Incrémenter le score quand un ennemi meurt
Dans update_projectile_collisions() (là où l'ennemi est détruit) :

```
c
Copier
Modifier
PlayerStatus* s = get_player_status(player);
if (s)
 s->score += 10;
✅ Étape 3 — Perdre une vie si un ennemi passe derrière le joueur
Dans update_physics() :

c
Copier
Modifier
if (has_enemy(e))
{
 Transform* t = get_transform(e);
 if (t->position[2] > 10.0f) // Ennemi a dépassé le joueur
 {
 PlayerStatus* s = get_player_status(player);
 if (s)
 s->lives--;

 destroy_entity(e);
 }
}
✅ Étape 4 — Gérer le Game Over
Dans ta boucle principale :

c
Copier
Modifier
if (has_player_status(player))
{
 PlayerStatus* s = get_player_status(player);
 if (s->lives <= 0)
 {
```c
 printf("GAME OVER - Score: %d\n", s->score);
 running = false;
 }
}
✅ Étape 5 — Afficher le HUD (score + vies)
📋 Option simple: via printf() en console
c
Copier
Modifier
printf("Score: %d | Vies: %d | Vague: %d\r", s->score, s->lives, current_wave);
📋 Option avancée: afficher texte en 2D via OpenGL (à venir)
Tu pourras utiliser :

```
Soit des sprites 2D OpenGL,

Soit une mini-lib comme stb_easy_font ou bitmap font
(ajouté plus tard dans Bloc 11 si tu veux) [🟢 Facile]

✅ Étape 6 — Ajouter une "explosion" visuelle
📋 Dans enemy_death() (ou dans update_projectile_collisions())
c
Copier
Modifier
Entity fx = create_entity();
Transform t = *get_transform(enemy);
Renderable r = {load_explosion_vao(), explosion_index_count};
MaterialComponent m = {load_explosion_material()};

add_transform(fx, t);
add_renderable(fx, r);
add_material(fx, m);
Et détruis l'explosion après 0.5s (avec un timer ou via fx_lifetime_system()).

📋 Résultat attendu

Action Résultat
Score augmente quand tu détruis un ennemi ✅
Tu perds une vie si un ennemi t'échappe ✅
Le HUD affiche Score, Vies et Vague actuelle ✅
Une explosion rapide est jouée à chaque mort ✅
Le jeu s'arrête proprement si lives == 0 ✅
🎯 Mini plan d'action Bloc 10 Partie 5 [🟢 Facile]
Ajouter composant PlayerStatus (score, vies),

Afficher score & vies via console ou HUD,

Ajouter mini explosion à la mort,

Gérer GAME OVER en cas de 0 vie.

📋 TDD minimal Bloc 10 Partie 5 [🟢 Facile]

Test Ce qui doit être visible
Score = nombre d'ennemis détruits × 10 ✅
Vies décrémentées si ennemi passe ✅
Affichage Score / Vies réactif ✅
Jeu se termine si vies <= 0 ✅

# Bloc 10 — Partie 6 — Menu Pause, Victoire, Défaite, Restart [🟢 Facile]
📚 Objectif immédiat
Tu vas :

Implémenter un système d'état de jeu (Running, Paused, GameOver, Victory),

Permettre de mettre le jeu en pause avec ECHAP,

Afficher écrans de fin (gagné ou perdu),

Proposer un redémarrage (Restart) sans relancer l'application.

📋 États du jeu
c
Copier
Modifier
typedef enum {
 STATE_RUNNING,
 STATE_PAUSED,
 STATE_GAMEOVER,
 STATE_VICTORY
} GameState;

GameState current_state = STATE_RUNNING;
📋 1. Gérer le pause avec ECHAP
Dans update_input() :

c
Copier
Modifier
```c
static int esc_last = GLFW_RELEASE;
int esc_now = glfwGetKey(window, GLFW_KEY_ESCAPE);

```
if (esc_now == GLFW_PRESS && esc_last == GLFW_RELEASE)
{
 if (current_state == STATE_RUNNING)
 current_state = STATE_PAUSED;
 else if (current_state == STATE_PAUSED)
 current_state = STATE_RUNNING;
}
esc_last = esc_now;
📋 2. Afficher pause (version console ou plus tard graphique)
c
Copier
Modifier
if (current_state == STATE_PAUSED)
{
```c
 printf("\n⏸️ JEU EN PAUSE — Appuie sur [ECHAP] pour reprendre\n");
 return;
}
📋 3. Passer en STATE_GAMEOVER
Dans ta boucle principale ou dans update_health() :

```
c
Copier
Modifier
PlayerStatus* status = get_player_status(player);
if (status && status->lives <= 0)
 current_state = STATE_GAMEOVER;
📋 4. Détecter la victoire
Exemple: si score >= 500, tu gagnes :

c
Copier
Modifier
if (status->score >= 500)
 current_state = STATE_VICTORY;
📋 5. Afficher écran de fin (console pour l'instant)
c
Copier
Modifier
if (current_state == STATE_GAMEOVER)
{
```c
 printf("\n💀 GAME OVER ! Score: %d\n", status->score);
 printf("Appuie sur [R] pour recommencer\n");
}

```
if (current_state == STATE_VICTORY)
{
```c
 printf("\n🏆 VICTOIRE ! Score: %d\n", status->score);
 printf("Appuie sur [R] pour recommencer\n");
}
📋 6. Implémenter Restart (R)
Dans update_input() :

```
c
Copier
Modifier
if ((current_state == STATE_GAMEOVER || current_state == STATE_VICTORY) &&
 glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS)
{
 reset_game();
 current_state = STATE_RUNNING;
}
Et dans reset_game() :

c
Copier
Modifier
void reset_game(void)
{
 destroy_all_entities(); // fonction à écrire

 current_wave = 0;
 create_player();
```c
 // Réinitialiser score, vies, vague, etc.
}
📚 Résultat attendu

```
Action Résultat
ECHAP ➔ met le jeu en pause ou le relance ✅
0 vie ➔ GAME OVER avec message ✅
Score max ➔ VICTOIRE avec message ✅
Appuyer sur R ➔ tout recommence proprement ✅
🎯 Mini plan d'action Bloc 10 Partie 6 [🟢 Facile]
Implémenter GameState global,

Ajouter pause, game over, victoire,

Afficher messages à l'écran (console ou HUD),

Ajouter R pour recommencer le jeu.

📋 TDD minimal Bloc 10 Partie 6 [🟢 Facile]

Test Ce qui doit marcher
Pause / Reprise avec ECHAP ✅
GAME OVER si lives == 0 ✅
VICTOIRE si score >= X ✅
Redémarrage sans crash ✅

# Bloc 10 — Partie 7 — Build Linux propre et Organisation du projet [🟢 Facile]
📚 Objectif immédiat
Tu vas :

Structurer ton projet final,

Créer un Makefile solide,

Ajouter un script Bash pour compiler/lancer automatiquement (build_and_run.sh),

Préparer ton projet pour le test, la diffusion, ou l'évolution future.

📋 1. Arborescence finale du projet
plaintext
Copier
Modifier
game_project_zero/
├── src/
│ ├── engine/ # OpenGL, Render, Input, ECS
│ ├── game/ # Player, Enemy, Bullet, HUD, Menu, State
├── include/
│ ├── engine/ # Headers moteur
│ ├── game/ # Headers gameplay
├── assets/
│ ├── models/ # .obj
│ ├── textures/ # .png, .jpg
│ ├── shaders/ # .vert, .frag
│ ├── sounds/ # effets audios
├── build/ # Binaires et objets
├── Makefile # Build principal
├── build_and_run.sh # Script compilation + exécution
├── README.md # Explication rapide
📋 2. Makefile solide
Exemple de base :

Makefile
Copier
Modifier
NAME = project_zero

SRC_DIR = src
BUILD_DIR = build
INCLUDE_DIR = include

SRCS = $(shell find $(SRC_DIR) -name "*.c")
OBJS = $(SRCS:$(SRC_DIR)/%.c=$(BUILD_DIR)/%.o)

CC = gcc
CFLAGS = -Wall -Wextra -Werror -I$(INCLUDE_DIR) -g
LDFLAGS = -lglfw -lGL -ldl -lm -lpthread

all: $(NAME)

$(NAME): $(OBJS)
 $(CC) $(CFLAGS) $(OBJS) -o $(NAME) $(LDFLAGS)

$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c
 mkdir -p $(dir $@)
 $(CC) $(CFLAGS) -c $< -o $@

clean:
 rm -rf $(BUILD_DIR)

fclean: clean
 rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
📋 3. Script Bash build_and_run.sh
Crée build_and_run.sh :

bash
Copier
Modifier
# !/bin/bash

echo "🛠️ Compilation du projet..."
make re

```c
if [ $? -eq 0 ]; then
 echo "🚀 Lancement du jeu !"
 ./project_zero
else
 echo "❌ Erreur de compilation."
fi
➔ Donne-lui les droits d'exécution :

```
bash
Copier
Modifier
chmod +x build_and_run.sh
📋 4. README.md minimal
markdown
Copier
Modifier
# Project Zero — Jeu Spatial 3D

🎮 Petit jeu de tir spatial en C/OpenGL 100% codé à la main.

## Compilation
```bash
./build_and_run.sh
Commandes
ZQSD: déplacer le vaisseau

Espace: tirer

Échap: pause

R: restart si game over ou victoire

Objectifs
Détruire un maximum d'ennemis sans perdre toutes ses vies !

Bon jeu 🚀

yaml
Copier
Modifier

---

# 📚 Résultat attendu

| Action | Résultat |
|:---|:---|
| `./build_and_run.sh` compile et lance ton jeu | ✅ |
| Arborescence claire et modulaire | ✅ |
| Projet prêt à être compressé et diffusé | ✅ |
| Aucun warning / erreur de compilation | ✅ |

---

# 🎯 Mini plan d'action Bloc 10 Partie 7 [🟢 Facile]

1. Réorganiser les fichiers,
2. Créer Makefile propre,
3. Créer script bash d'exécution,
4. Écrire README minimal.

---

# 📋 TDD minimal Bloc 10 Partie 7 [🟢 Facile]

| Test | Ce qui doit marcher |
|:---|:---|
| Compilation propre sans warning | ✅ |
| Exécution fonctionnelle via script | ✅ |
| Arborescence projet lisible | ✅ |

---

✅ **Bloc 10 — Partie 7 terminé proprement !**  [🟢 Facile]
Ton **premier vrai jeu en C sur moteur custom est officiellement terminé et exportable** 🎯🚀

---

# 📢 🎖️ Fin de Bloc 10 — Résumé [🟢 Facile]

Tu as maintenant :
- Un moteur graphique OpenGL PBR HDR Instancing 🎨
- Un moteur de jeu ECS propre et scalable 📦
- Un vrai jeu interactif complet 🛸
- Des systèmes de score, vie, HUD, états de jeu 🧠
- Un build final solide sous Linux / terminal 🎯

══════════════════════════════════════════════════════════════════════════
📋 FEUILLE DE PROGRESSION PERSONNELLE - FORMAT PAPIER
══════════════════════════════════════════════════════════════════════════

Cette feuille est entièrement facultative mais pensée pour motiver et suivre ta progression
durant la piscine et tout au long du cursus 42 personnel. Elle est faite pour être imprimée
et remplie à la main. Utilise-la comme carnet de route, checklist ou tableau de bord.

────────────────────────────────────────────────────────
🌱 PROGRESSION PAR NIVEAUX (symbolique et motivante)
────────────────────────────────────────────────────────

| Niveau | XP nécessaire  | Description                       |
|--------|----------------|-----------------------------------|
| 1      | 0              | Débutant (Git/Linux)              |
| 2      | 100            | Makefile validé et propre         |
| 3      | 250            | Pointeurs et malloc maîtrisés     |
| 4      | 500            | TDD utilisé sur projets           |
| 5      | 800            | Shell/Compilateur réalisé         |

────────────────────────────────────────────────────────
🧩 BADGES À COCHER - VERSION PAPIER
────────────────────────────────────────────────────────

[ ] Makefile Master - Créer un Makefile multi-fichiers
[ ] Pointer Slayer - Réussir 10 exos avec double pointeurs
[ ] TDD Master - Projet complet testé de A à Z
[ ] Git Ninja - Branches, rebase, merge maîtrisés
[ ] Shell Warrior - Shell fonctionnel avec parsing complexe

────────────────────────────────────────────────────────
📘 MODULES À SUIVRE - SUIVI MANUEL
────────────────────────────────────────────────────────

| Module              | Fait ? | Confiance (0-5) | À revoir ? |
|---------------------|--------|------------------|------------|
| Makefile            | [ ]    |                  | [ ]        |
| Git                 | [ ]    |                  | [ ]        |
| Pointeurs           | [ ]    |                  | [ ]        |
| TDD                 | [ ]    |                  | [ ]        |
| LibC avancée        | [ ]    |                  | [ ]        |
| GNL/Pipex/Minishell | [ ]    |                  | [ ]        |
| Graphisme/Réseau    | [ ]    |                  | [ ]        |
| OS / Compilateurs   | [ ]    |                  | [ ]        |

Conseil: Imprime cette feuille à la fin de chaque bloc ou mois de travail, coche ce que tu maîtrises,
et note ce que tu veux revoir plus tard. Tu peux aussi t'en servir pour planifier ta semaine.

══════════════════════════════════════════════════════════════════════════

## 📚 Références conseillées

Voici trois ouvrages que tu peux consulter tout au long de ton apprentissage pour approfondir chaque notion :

- **📘 Le guide complet du C — Claude Delannoy**  
  ➤ Une référence claire et progressive pour bien maîtriser le langage C, depuis les bases jusqu’aux pointeurs avancés.

- **💻 Programmation système en C sous Linux — Christophe Blaess**  
  ➤ Un excellent livre pour comprendre les appels systèmes, la gestion de processus, les fichiers, la mémoire, etc., dans un environnement Linux.

- **📗 C in a Nutshell — Peter Prinz & Tony Crawford**  
  ➤ Une bible de référence technique, concise et bien structurée, idéale pour retrouver rapidement la syntaxe ou les fonctions de la libc.

---
##📑 Table des matières

###📘 Piscine Boostée – Bloc 1 [🟢 Facile]
Partie 1/5 : Affichage & Premiers concepts
0.0.0) ft_putchar
0.0.1) ft_print_alphabet
0.0.2) ft_print_reverse_alphabet
0.0.3) ft_print_numbers
0.0.4) ft_is_negative
0.0.5) ft_print_comb
0.0.6) ft_print_comb2
0.0.7) ft_putnbr
0.0.8) ft_print_combn
(Module 1 — preprocessor/ — Fondamentaux du Préprocesseur C)
0.0.9) ft_ultimate_ft
Partie 2/5 : Pointeurs & chaînes
0.0.10) ft_swap
0.0.11) ft_div_mod
0.0.12) ft_ultimate_div_mod
0.0.13) ft_putstr
0.0.14) ft_strlen
0.0.15) ft_strcpy
0.0.16) ft_strncpy
0.0.17) ft_str_is_alpha
0.0.18) ft_str_is_numeric
0.0.19) ft_str_is_lowercase
Partie 3/5 : Chaînes & mémoire
0.0.20) ft_str_is_uppercase
0.0.21) ft_str_is_printable
0.0.22) ft_strupcase
0.0.23) ft_strlowcase
0.0.24) ft_strcapitalize
0.0.25) ft_strlcpy
0.0.26) ft_putstr_non_printable
0.0.27) ft_print_memory (Partie 1)
Partie 4/5 : Récursivité & Mathématiques
0.1.0) ft_recursive_factorial
0.1.1) ft_iterative_factorial
0.1.2) ft_recursive_power
0.1.3) ft_iterative_power
0.1.4) ft_fibonacci
0.1.5) ft_sqrt
0.1.6) ft_is_prime
0.1.7) ft_find_next_prime
Partie 5/5 : Bilan
Ce que tu as appris dans la Piscine

###📦 Bloc 2 — Libft++ Boostée [🟢 Facile]
Partie 1/7 : Fonctions de base
1.0) ft_strlen
1.1) ft_strcpy
1.2) ft_strdup
1.3) ft_strcmp
1.4) ft_strncpy
Partie 2/7 : Manipulation de mémoire
2.0) ft_memset
2.1) ft_bzero
2.2) ft_memcpy
2.3) ft_memmove
2.4) ft_memchr
Partie 3/7 : Comparaison & recherche
3.0) ft_memcmp
3.1) ft_strchr
3.2) ft_strrchr
3.3) ft_strncmp
3.4) ft_strnstr
Partie 4/7 : Conversion & substr
4.0) ft_calloc
4.1) ft_strdup (Rappel amélioré)
4.2) ft_atoi
4.3) ft_itoa
4.4) ft_substr
Partie 5/7 : Chaînes avancées
5.0) ft_strjoin
5.1) ft_strtrim
5.2) ft_split
5.3) ft_strmapi
5.4) ft_striteri
Partie 6/7 : Écriture dans des fichiers
6.0) ft_putchar_fd
6.1) ft_putstr_fd
6.2) ft_putendl_fd
6.3) ft_putnbr_fd
Partie 7/7 : Listes chaînées
7.0) ft_lstnew
7.1) ft_lstadd_front
7.2) ft_lstsize
7.3) ft_lstlast
7.4) ft_lstadd_back
7.5) ft_lstdelone
7.6) ft_lstclear
7.7) ft_lstiter
7.8) ft_lstmap
Partie 8 : Bonus pro
8.0) Créer un Makefile Pro
8.1) TDD Complet
8.2) Automatiser les tests

###🔄 Bloc 3 — GNL++ Boostée [🟡 Intermédiaire]
Partie 1 à 4 : Lecture ligne par ligne, stash, buffer, parsing
ft_strlen_gnl, ft_strchr_gnl, ft_strdup_gnl, ft_strjoin_gnl
Lecture en blocs (BUFFER_SIZE)
Extraction de lignes
Gestion de la mémoire restante

###🧵 Bloc 4 — Pipex++ Boosté [🟡 Intermédiaire]
Partie 1 à 4 : Processus, redirections, exécutions
Argument parsing, pipes, forks, execve
Exécution des commandes et communication
Finalisation et gestion des erreurs

###🐚 Bloc 5 — Minishell++ Boosté [🟠 Avancé]
Partie 1 à 9 : Shell, parsing, readline, signaux, pipes, logique
Modes avec et sans readline
Implémentation pas à pas d’un shell POSIX
Gestion avancée des erreurs et signaux

###🧠 Bloc 6 — Malloc++ Boosté [🟡 à 🔴]
Partie 1 à 6 : Gestion mémoire custom
Structures de blocs mémoire
malloc, free, realloc
Fusion des blocs, affichage, debug, tests

###🌐 Bloc 7 — Serveur Réseau TCP [🟡 à 🔴]
Partie 1 à 8 : Réseau bas niveau
Serveur mono-client, multi-client
Protocole TCP minimal
Commandes /msg, /who, broadcast
Client personnalisé
Modularité et refactorisation

###🎮 Bloc 8 — Moteur 3D OpenGL [🟠 Avancé]
Partie 1 à 9 : OpenGL, GLFW, Caméras, Shaders, Textures
Fenêtre OpenGL, Skybox
Contrôle FPS, ECS, Texturing
Lighting, PBR, Normal Mapping, Instancing

###🕹️ Bloc 9 — Renderer PBR & Shaders [🔴 Très avancé]
Partie 1 à 10 : Physically Based Rendering, ECS, scènes
Matériaux dynamiques
Lightmaps, HDR, Instancing, IBL
Architecture de scènes orientée ECS

###🚀 Bloc 10 — Jeu complet avec ton moteur [🟢 Facile]
Partie 1 à 7 : Joueur, ennemis, tirs, HUD
Contrôle caméra, projectiles, collisions
Effets visuels, menus, HUD
Build final Linux, TDD complet

###🌌 Project Zero — Jeu spatial 3D
Compilation, Résultats, Plan d’action, TDD minimal

###📥 Annexe
Contenu additionnel (Bloc 1 fusionné)
Includes utiles (libft.h, stdio.h, etc.)